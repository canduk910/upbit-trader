<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile.backend">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile.backend" />
              <option name="originalContent" value="# Backend Dockerfile for Upbit Trader&#10;FROM python:3.11-slim&#10;&#10;# Install basic dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \&#10;    build-essential \&#10;    gcc \&#10;    curl \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;COPY requirements.txt /app/&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Copy project&#10;COPY . /app&#10;&#10;# Add reusable entrypoint&#10;COPY scripts/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh&#10;RUN chmod +x /usr/local/bin/docker-entrypoint.sh&#10;ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]&#10;&#10;ENV PYTHONUNBUFFERED=1&#10;ENV PYTHONPATH=/app&#10;ENV REDIS_URL=redis://redis:6379/0&#10;&#10;EXPOSE 8000&#10;CMD [&quot;uvicorn&quot;, &quot;server.api:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;" />
              <option name="updatedContent" value="# Backend Dockerfile for Upbit Trader&#10;FROM python:3.11-slim&#10;&#10;# Install basic dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \&#10;    build-essential \&#10;    gcc \&#10;    curl \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;COPY requirements.txt /app/&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Copy project&#10;COPY . /app&#10;&#10;# Add reusable entrypoint&#10;COPY scripts/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh&#10;RUN chmod +x /usr/local/bin/docker-entrypoint.sh&#10;ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]&#10;&#10;ENV PYTHONUNBUFFERED=1&#10;ENV PYTHONPATH=/app&#10;ENV REDIS_URL=redis://redis:6379/0&#10;&#10;EXPOSE 8000&#10;CMD [&quot;uvicorn&quot;, &quot;server.api:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.override.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.override.yml" />
              <option name="originalContent" value="services:&#10;  backend:&#10;    env_file:&#10;      - server/.env&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: sh -c &quot;uvicorn server.api:app --app-dir /app --host 0.0.0.0 --port 8000 --reload --reload-dir /app/server&quot;&#10;    environment:&#10;      - REDIS_URL=redis://redis:6379/0&#10;    ports:&#10;      - &quot;8000:8000&quot;&#10;&#10;  ui:&#10;    env_file:&#10;      - server/.env&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: sh -c &quot;streamlit run ui/ui_dashboard.py --server.port 8501 --server.address 0.0.0.0&quot;&#10;    ports:&#10;      - &quot;8501:8501&quot;&#10;&#10;  bot:&#10;    env_file:&#10;      - server/.env&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: sh -c &quot;python -m server.bot&quot;&#10;&#10;  ws_listener_public:&#10;    env_file:&#10;      - server/.env&#10;    build:&#10;      context: .&#10;      dockerfile: Dockerfile.backend&#10;    container_name: upbit-trader-ws-listener-public-dev&#10;    working_dir: /app&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: python -m server.ws_listener_public&#10;    environment:&#10;      - PYTHONUNBUFFERED=1&#10;      - PYTHONPATH=/app&#10;      - REDIS_URL=redis://redis:6379/0&#10;&#10;  ws_listener_private:&#10;    env_file:&#10;      - server/.env&#10;    build:&#10;      context: .&#10;      dockerfile: Dockerfile.backend&#10;    container_name: upbit-trader-ws-listener-private-dev&#10;    working_dir: /app&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: python -m server.ws_listener_private&#10;    environment:&#10;      - PYTHONUNBUFFERED=1&#10;      - PYTHONPATH=/app&#10;      - REDIS_URL=redis://redis:6379/0&#10;" />
              <option name="updatedContent" value="services:&#10;  backend:&#10;    env_file:&#10;      - server/.env&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: sh -c &quot;uvicorn server.api:app --app-dir /app --host 0.0.0.0 --port 8000 --reload --reload-dir /app/server&quot;&#10;    environment:&#10;      - REDIS_URL=redis://redis:6379/0&#10;    ports:&#10;      - &quot;8000:8000&quot;&#10;&#10;  ui:&#10;    env_file:&#10;      - server/.env&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: sh -c &quot;streamlit run ui/ui_dashboard.py --server.port 8501 --server.address 0.0.0.0&quot;&#10;    ports:&#10;      - &quot;8501:8501&quot;&#10;&#10;  bot:&#10;    env_file:&#10;      - server/.env&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: sh -c &quot;python -m server.bot&quot;&#10;&#10;  ws_listener_public:&#10;    env_file:&#10;      - server/.env&#10;    build:&#10;      context: .&#10;      dockerfile: Dockerfile.backend&#10;    container_name: upbit-trader-ws-listener-public-dev&#10;    working_dir: /app&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: python -m server.ws_listener_public&#10;    environment:&#10;      - PYTHONUNBUFFERED=1&#10;      - PYTHONPATH=/app&#10;      - REDIS_URL=redis://redis:6379/0&#10;&#10;  ws_listener_private:&#10;    env_file:&#10;      - server/.env&#10;    build:&#10;      context: .&#10;      dockerfile: Dockerfile.backend&#10;    container_name: upbit-trader-ws-listener-private-dev&#10;    working_dir: /app&#10;    volumes:&#10;      - ./:/app:cached&#10;      - ./logs:/app/logs&#10;      - ./runtime:/app/runtime&#10;    command: python -m server.ws_listener_private&#10;    environment:&#10;      - PYTHONUNBUFFERED=1&#10;      - PYTHONPATH=/app&#10;      - REDIS_URL=redis://redis:6379/0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/runtime/config.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/runtime/config.json" />
              <option name="originalContent" value="{&#10;  &quot;strategy_name&quot;: &quot;VolatilityBreakout&quot;,&#10;  &quot;market&quot;: &quot;KRW-BTC&quot;,&#10;  &quot;timeframe&quot;: &quot;minute15&quot;,&#10;  &quot;candle_count&quot;: 200,&#10;  &quot;loop_interval_sec&quot;: 5,&#10;  &quot;order_settings&quot;: {&#10;    &quot;min_order_amount&quot;: 5500,&#10;    &quot;trade_amount_krw&quot;: 6000&#10;  },&#10;  &quot;use_kelly_criterion&quot;: true,&#10;  &quot;kelly_criterion&quot;: {&#10;    &quot;win_rate&quot;: 0.65,&#10;    &quot;payoff_ratio&quot;: 1.2,&#10;    &quot;fraction&quot;: 0.5&#10;  },&#10;  &quot;strategy_params&quot;: {&#10;    &quot;VolatilityBreakout&quot;: {&#10;      &quot;k_value&quot;: 0.02,&#10;      &quot;target_vol_pct&quot;: 30.0&#10;    }&#10;  },&#10;  &quot;ai_ensemble&quot;: {&#10;    &quot;strategy&quot;: &quot;UNANIMOUS&quot;,&#10;    &quot;openai_model&quot;: &quot;gpt-5-nano&quot;,&#10;    &quot;gemini_model&quot;: &quot;gemini-2.5-flash&quot;&#10;  },&#10;  &quot;bot_enabled&quot;: false,&#10;  &quot;bot_interval_sec&quot;: 5.0&#10;}" />
              <option name="updatedContent" value="{&#10;  &quot;strategy_name&quot;: &quot;VolatilityBreakout&quot;,&#10;  &quot;market&quot;: &quot;KRW-BTC&quot;,&#10;  &quot;timeframe&quot;: &quot;minute15&quot;,&#10;  &quot;candle_count&quot;: 200,&#10;  &quot;loop_interval_sec&quot;: 5,&#10;  &quot;order_settings&quot;: {&#10;    &quot;min_order_amount&quot;: 5500,&#10;    &quot;trade_amount_krw&quot;: 6000&#10;  },&#10;  &quot;use_kelly_criterion&quot;: true,&#10;  &quot;kelly_criterion&quot;: {&#10;    &quot;win_rate&quot;: 0.65,&#10;    &quot;payoff_ratio&quot;: 1.2,&#10;    &quot;fraction&quot;: 0.5&#10;  },&#10;  &quot;strategy_params&quot;: {&#10;    &quot;VolatilityBreakout&quot;: {&#10;      &quot;k_value&quot;: 0.02,&#10;      &quot;target_vol_pct&quot;: 30.0&#10;    }&#10;  },&#10;  &quot;ai_ensemble&quot;: {&#10;    &quot;strategy&quot;: &quot;UNANIMOUS&quot;,&#10;    &quot;openai_model&quot;: &quot;gpt-5-nano&quot;,&#10;    &quot;gemini_model&quot;: &quot;gemini-2.5-flash&quot;&#10;  },&#10;  &quot;bot_enabled&quot;: false,&#10;  &quot;bot_interval_sec&quot;: 5.0&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api.py" />
              <option name="originalContent" value="from fastapi import FastAPI, HTTPException # web framework&#10;from contextlib import asynccontextmanager # for lifespan management&#10;from pydantic import BaseModel # data validation, settings management&#10;from typing import Any, Dict, List, Optional # type hints&#10;import threading&#10;import time&#10;import os&#10;&#10;# 시간대 설정&#10;os.environ.setdefault('TZ', 'Asia/Seoul')&#10;try:&#10;    time.tzset()&#10;except Exception:&#10;    pass&#10;&#10;# 외부라이브러리 임포트&#10;import redis # Redis 클라이언트&#10;import json&#10;from concurrent.futures import ThreadPoolExecutor, as_completed # for parallel prefetching&#10;&#10;# 내부API 모듈 임포트&#10;from server import config               # 런타임 설정 관리&#10;from server.upbit_api import UpbitAPI   # 업비트 API 연동&#10;from server.logger import log           # 로깅 설정&#10;from server.history import history_store&#10;from server.history import order_history_store&#10;from server.history import ai_history_store&#10;from server.ws_listener_base import (&#10;    load_ws_stats,&#10;    summarize_ws_stats,&#10;    read_exec_history,&#10;)&#10;from server.ws_listener_private import PrivateWebsocketListener&#10;from server.ws_listener_public import PublicWebsocketlistener&#10;&#10;# Token Bucket 구현 for prefetch&#10;# 간단한 토큰 버킷(rate limiter) 구현&#10;# rate: 초당 토큰 생성 속도&#10;# capacity: 버킷 최대 토큰 수&#10;# consume(tokens, timeout): 지정된 토큰 수를 소비 시도, 타임아웃 내에 성공 여부 반환&#10;# 스레드 안전 구현&#10;# 사용 예시:&#10;# tb = TokenBucket(rate=5, capacity=10)  # 초당 5토큰, 최대 10토큰&#10;# if tb.consume(tokens=1, timeout=2.0):&#10;#     print(&quot;Token acquired&quot;)&#10;# else:&#10;#     print(&quot;Failed to acquire token within timeout&quot;)&#10;class TokenBucket:&#10;    def __init__(self, rate: float, capacity: float):&#10;        self.rate = float(rate)         # 토큰 생성 속도 (초당)&#10;        self.capacity = float(capacity) # 버킷 최대 용량&#10;        self._tokens = float(capacity)  # 현재 토큰 수&#10;        self._last = time.time()        # 마지막 토큰 갱신 시각&#10;        self._lock = threading.Lock()   # 스레드 안전을 위한 락&#10;&#10;    # 토큰 소비 메서드&#10;    # tokens: 소비할 토큰 수&#10;    # timeout: 최대 대기 시간 (초)&#10;    # 반환값: 성공 시 True, 실패 시 False&#10;    def consume(self, tokens: float = 1.0, timeout: float = 5.0) -&gt; bool:&#10;        end = time.time() + float(timeout)&#10;        while time.time() &lt; end:&#10;            with self._lock:&#10;                now = time.time()&#10;                elapsed = max(0.0, now - self._last)&#10;                self._tokens = min(self.capacity, self._tokens + elapsed * self.rate)&#10;                self._last = now&#10;                if self._tokens &gt;= tokens:&#10;                    self._tokens -= tokens&#10;                    return True&#10;            time.sleep(0.01)&#10;        return False&#10;&#10;&#10;# 세마포어 및 토큰 버킷 초기화 (스케줄러 시작 시)&#10;_prefetch_token_bucket: Optional[TokenBucket] = None&#10;_prefetch_semaphore: Optional[threading.BoundedSemaphore] = None&#10;&#10;# 기본 klines 캐시 TTL (초)&#10;# 환경변수 'KLINES_CACHE_TTL'로 설정 가능, 기본값 600초&#10;# 예: os.environ['KLINES_CACHE_TTL'] = '600'&#10;# (기본값 600초로 설정하여 중복 Upbit 요청 감소, 실시간성은 다소 희생, 값이 클수록 캐시 지속시간 증가)&#10;_KLINES_CACHE_TTL = int(os.getenv('KLINES_CACHE_TTL', str(600)))  # default 600s&#10;&#10;# Balances cache TTL (seconds)&#10;_BALANCES_CACHE_TTL = int(os.getenv('BALANCES_CACHE_TTL', '15'))&#10;&#10;# FastAPI 앱 생성 및 수명 주기 관리&#10;@asynccontextmanager&#10;async def lifespan(app: FastAPI): # 수명 주기 관리&#10;    # start prefetch scheduler on startup&#10;    try:&#10;        # read interval from config, default 30s&#10;        # if invalid, fallback to 30s&#10;        # prefetch interval 설정&#10;        # 기본값 30초&#10;        # 환경변수나 config.json의 'prefetch_interval_sec' 키로 설정 가능&#10;        interval = int(config._config.get('prefetch_interval_sec', 30))&#10;    except Exception:&#10;        interval = 30&#10;&#10;    # 스케쥴러 시작&#10;    start_prefetch_scheduler(interval=interval)&#10;    try:&#10;        start_ws_listener()&#10;        start_ticker_listener()&#10;    except Exception as exc:&#10;        log.warning(f'Failed to start websocket listener on startup: {exc}')&#10;    try:&#10;        yield&#10;    finally:&#10;        # 스케쥴러 중지&#10;        stop_prefetch_scheduler()&#10;        stop_ws_listener()&#10;        stop_ticker_listener()&#10;&#10;app = FastAPI(title=&quot;Upbit Trader Runtime API&quot;, lifespan=lifespan) # FastAPI 앱 생성&#10;&#10;# 데이터 모델 정의&#10;class ConfigPayload(BaseModel):&#10;    config: Dict[str, Any]&#10;&#10;# 배치 klines 요청 모델&#10;class KlinesBatchRequest(BaseModel):&#10;    tickers: List[str]&#10;    timeframe: Optional[str] = 'minute15'&#10;    count: Optional[int] = 100&#10;&#10;# 포지션 모델 정의&#10;class Position(BaseModel):&#10;    ticker: str&#10;    amount: float&#10;    avg_price: float&#10;    current_price: float&#10;    pnl: float&#10;&#10;# --- Background Prefetch Scheduler 및 캐시 관리 ---&#10;# 전역 상태 변수들&#10;# Prefetch 스레드 및 제어 변수&#10;# Simple in-memory watcher state (explicit typing to satisfy linters)&#10;_watcher: Dict[str, Any] = {&#10;    'running': False,&#10;    'thread': None,&#10;    'stop_event': None,&#10;}&#10;&#10;# 캐시 딕셔너리&#10;# Simple in-memory cache for batch klines: { key: (timestamp, data) }&#10;_klines_cache: Dict[str, Any] = {}&#10;&#10;&#10;# 레디스(Redis) 클라이언트 초기화&#10;# Redis setup (optional). Use local redis://localhost:6379 if REDIS_URL not set&#10;# 환경변수 'REDIS_URL'로 Redis URL 설정 가능&#10;REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')&#10;_redis_client = None&#10;try:&#10;    # Redis 클라이언트 생성 및 연결 테스트&#10;    _redis_client = redis.from_url(REDIS_URL, decode_responses=True)&#10;    # ping 테스트&#10;    _redis_client.ping()&#10;    log.info(f'Redis cache connected: {REDIS_URL}')&#10;except Exception as e:&#10;    _redis_client = None&#10;    log.warning(f'Redis not available ({REDIS_URL}): {e}. Falling back to in-memory cache')&#10;&#10;# 캐시 설정 함수&#10;# key: 캐시 키&#10;# value: 캐시 값&#10;# ttl: 캐시 만료 시간 (초)&#10;# 기본 TTL은 _KLINES_CACHE_TTL 사용&#10;# Redis 사용 가능 시 Redis에 저장, 아니면 메모리 내 딕셔너리에 저장&#10;# 캐시 조회 시 만료 시간 확인&#10;# 반환값: (타임스탬프, 값) 또는 None&#10;def _cache_set(key: str, value: Any, ttl: int = _KLINES_CACHE_TTL):&#10;    &quot;&quot;&quot;Set cache in Redis if available, else in-memory.&quot;&quot;&quot;&#10;    now = time.time()&#10;    if _redis_client:&#10;        try:&#10;            # store JSON string&#10;            import json as _json&#10;            payload = {'ts': now, 'value': value}&#10;            _redis_client.setex(key, ttl, _json.dumps(payload)) # set with expiry&#10;            return&#10;        except Exception:&#10;            pass&#10;    _klines_cache[key] = (now, value) # store in-memory&#10;&#10;# 캐시 조회 함수&#10;# key: 캐시 키&#10;# ttl: 캐시 만료 시간 (초)&#10;# 기본 TTL은 _KLINES_CACHE_TTL 사용&#10;# 반환값: (타임스탬프, 값) 또는 None&#10;def _cache_get(key: str, ttl: int = _KLINES_CACHE_TTL):&#10;    &quot;&quot;&quot;Get cache value. Return (timestamp, value) or None.&quot;&quot;&quot;&#10;    if _redis_client:&#10;        try:&#10;            import json as _json&#10;            s = _redis_client.get(key) # get JSON string&#10;            if not s:&#10;                return None&#10;            obj = _json.loads(s) # parse JSON&#10;            if time.time() - obj.get('ts', 0) &gt; ttl:&#10;                return None&#10;            return (obj.get('ts'), obj.get('value')) # return (timestamp, value)&#10;        except Exception:&#10;            return None&#10;    return _klines_cache.get(key) # return (timestamp, value) or None&#10;&#10;# Websocket listener state&#10;_ws_listener: Optional[PrivateWebsocketListener] = None&#10;_ticker_listener: Optional[PublicWebsocketlistener] = None&#10;&#10;def start_ws_listener() -&gt; None:&#10;    global _ws_listener&#10;    if _ws_listener and _ws_listener._thread and _ws_listener._thread.is_alive():&#10;        return&#10;    _ws_listener = PrivateWebsocketListener(redis_client=_redis_client)&#10;    _ws_listener.start()&#10;&#10;&#10;def start_ticker_listener() -&gt; None:&#10;    global _ticker_listener&#10;    if _ticker_listener and _ticker_listener._thread and _ticker_listener._thread.is_alive():&#10;        return&#10;    _ticker_listener = PublicWebsocketlistener(redis_client=_redis_client)&#10;    _ticker_listener.start()&#10;&#10;&#10;def stop_ws_listener() -&gt; None:&#10;    global _ws_listener&#10;    if _ws_listener:&#10;        _ws_listener.stop()&#10;&#10;&#10;def stop_ticker_listener() -&gt; None:&#10;    global _ticker_listener&#10;    if _ticker_listener:&#10;        _ticker_listener.stop()&#10;&#10;# Rate-limited Upbit klines fetcher&#10;# ticker_local: 업비트 로컬 티커명 (예: KRW-BTC)&#10;# timeframe: 캔들 시간대 (예: 'minute15')&#10;# count: 조회할 캔들 개수&#10;# 반환값: UpbitAPI.get_klines() 결과&#10;# 전역 토큰 버킷 및 세마포어를 사용하여 호출 제한 및 동시성 제어&#10;# 토큰 획득 및 세마포어 획득 시 타임아웃 처리&#10;# 예외 발생 시 호출 실패&#10;# 반환값: UpbitAPI.get_klines() 결과&#10;def _rate_limited_get_klines(ticker_local: str, timeframe: str, count: int):&#10;    # 전역 토큰 버킷 및 세마포어 사용&#10;    global _prefetch_token_bucket, _prefetch_semaphore&#10;&#10;    # 세마포어 및 토큰 획득 시도&#10;    # 타임아웃은 config의 'prefetch_token_wait_timeout' 키로 설정 가능, 기본 10초&#10;    # 실제 Upbit 호출 수행&#10;    # 예외 발생 시 호출 실패&#10;    acquired = False&#10;    try:&#10;        # 세마포어 획득 시도&#10;        if _prefetch_semaphore is not None:&#10;            # 세마포어 획득 (대기 시간 설정 기본값 10초)&#10;            acquired = _prefetch_semaphore.acquire(timeout=10)&#10;            if not acquired:&#10;                raise RuntimeError('prefetch_semaphore_timeout')&#10;&#10;        # 토큰 획득 시도&#10;        if _prefetch_token_bucket is not None:&#10;            # 토큰 대기 시간 설정&#10;            # 기본값 10초 (즉시 호출 선호), config의 'prefetch_token_wait_timeout' 키로 설정 가능&#10;            try:&#10;                token_wait = float(config._config.get('prefetch_token_wait_timeout', 10.0))&#10;            except Exception:&#10;                token_wait = 10.0&#10;            ok = _prefetch_token_bucket.consume(tokens=1.0, timeout=token_wait)&#10;            if not ok:&#10;                raise RuntimeError('rate_limited')&#10;        # 업비트 공용 API 호출 수행&#10;        # 반환값: UpbitAPI.get_klines() 결과&#10;        # 참고: UpbitAPI 인스턴스는 전역 _upbit_public 사용&#10;        # 이 인스턴스는 API 키를 사용하지 않음&#10;        return _upbit_public.get_klines(ticker_local, timeframe, count=count)&#10;    finally:&#10;        if acquired and _prefetch_semaphore is not None:&#10;            try:&#10;                _prefetch_semaphore.release() # 세마포어 해제&#10;            except Exception:&#10;                pass&#10;&#10;&#10;# 업비트 공용 API 인스턴스&#10;_upbit_public = UpbitAPI()&#10;&#10;# 업비트 인증(Private) API 인스턴스&#10;try:&#10;    access = getattr(config, 'UPBIT_ACCESS_KEY', None)&#10;    secret = getattr(config, 'UPBIT_SECRET_KEY', None)&#10;    if access and secret:&#10;        _upbit_private = UpbitAPI(access_key=access, secret_key=secret)&#10;        log.info('Upbit private API initialized with provided keys')&#10;    else:&#10;        _upbit_private = None&#10;        log.warning('Upbit API keys not provided: private endpoints will be unavailable')&#10;except Exception as e:&#10;    _upbit_private = None&#10;    log.warning(f'Failed to initialize Upbit private API: {e}')&#10;&#10;# 스케쥴러 스레드 및 제어 변수&#10;_prefetch_thread: Optional[threading.Thread] = None&#10;_prefetch_stop = threading.Event()&#10;_prefetch_index = 0&#10;&#10;# 루프 함수 - 주기적으로 universe의 티커들에 대해 klines를 미리 가져와 캐시에 저장&#10;# interval: 루프 주기 (초)&#10;# 기본값 30초&#10;def _prefetch_loop(interval: int = 30):&#10;    log.info('Prefetch scheduler started')&#10;    effective_interval = interval&#10;    while not _prefetch_stop.is_set():&#10;        try:&#10;            # 설정 읽기&#10;            cfg = config._config&#10;            # 티커 유니버스&#10;            universe = cfg.get('universe', [])&#10;            # 실행 중 설정 체크 (런타임 config에서 재정의 허용)&#10;            cfg_count = int(cfg.get('prefetch_count', 200))&#10;            # Redis 미사용 시 보수적으로 설정, upper bound 허용&#10;            if _redis_client is None:&#10;                # When Redis is missing, be conservative but allow a configurable upper bound&#10;                # Redis 미사용 시 최대값 설정, 기본 120, config의 'prefetch_no_redis_max_count' 키로 설정 가능&#10;                try:&#10;                    no_redis_max = int(cfg.get('prefetch_no_redis_max_count', 120))&#10;                except Exception:&#10;                    no_redis_max = 120&#10;                count = min(cfg_count, no_redis_max)&#10;                per_ticker_sleep = float(cfg.get('prefetch_sleep_sec', 1.0))&#10;                log.info('Redis not available: using conservative prefetch settings (count=%s, sleep=%.2f)', count, per_ticker_sleep)&#10;            else:&#10;                count = cfg_count&#10;                per_ticker_sleep = float(cfg.get('prefetch_sleep_sec', 0.2))&#10;&#10;            # Redis 미사용 시 최소 간격 보장&#10;            effective_interval = interval&#10;            if _redis_client is None:&#10;                effective_interval = max(interval, int(cfg.get('prefetch_min_interval_sec', 60)))&#10;            if universe:&#10;                # staggered batch processing to avoid bursts&#10;                batch_size = int(cfg.get('prefetch_batch_size', 5))     # batch size per run&#10;                parallelism = int(cfg.get('prefetch_parallelism', 3))   # max parallel fetches per batch&#10;                global _prefetch_index&#10;                n = len(universe)&#10;                if n == 0:&#10;                    pass&#10;                else:&#10;                    start = _prefetch_index % n # start index&#10;                    end = start + batch_size    # end index (exclusive)&#10;                    indices = list(range(start, min(end, n)))&#10;                    # wrap-around if needed&#10;                    if end &gt; n:&#10;                        indices += list(range(0, end - n))&#10;                    tickers_to_process = [universe[i] for i in indices]&#10;                    # advance index for next run&#10;                    _prefetch_index = (start + len(tickers_to_process)) % max(n,1)&#10;&#10;                    # helper to fetch and cache single ticker&#10;                    def _prefetch_single(ticker_local: str):&#10;                        try:&#10;                            key_local = f&quot;{ticker_local}|minute15|{count}&quot;&#10;                            cached_local = _cache_get(key_local)&#10;                            if cached_local and (time.time() - cached_local[0]) &lt; _KLINES_CACHE_TTL:&#10;                                return (ticker_local, True, 'cached')&#10;                            # use rate-limited fetch so prefetch respects global rate/concurrency limits&#10;                            klines_local = _rate_limited_get_klines(ticker_local, 'minute15', count=count)&#10;                            _cache_set(key_local, klines_local, ttl=_KLINES_CACHE_TTL)&#10;                            return (ticker_local, True, 'fetched')&#10;                        except Exception as exc:&#10;                            log.error(f'Prefetch ticker error for {ticker_local}: {exc}')&#10;                            return (ticker_local, False, str(exc))&#10;&#10;                    # run in ThreadPoolExecutor with limited parallelism&#10;                    with ThreadPoolExecutor(max_workers=min(parallelism, len(tickers_to_process))) as executor:&#10;                        futures = {executor.submit(_prefetch_single, t): t for t in tickers_to_process}&#10;                        for fut in as_completed(futures):&#10;                            try:&#10;                                ticker_res, ok, msg = fut.result()&#10;                                log.debug(f'Prefetch result: {ticker_res} ok={ok} info={msg}')&#10;                            except Exception as e:&#10;                                log.error(f'Prefetch future error: {e}')&#10;                    # after parallel batch, small pause to avoid immediate repeated calls&#10;                    time.sleep(per_ticker_sleep)&#10;        except Exception as e:&#10;            log.error(f'Prefetch error: {e}')&#10;        # wait using effective interval (recompute per loop)&#10;        try:&#10;            _prefetch_stop.wait(effective_interval)&#10;        except UnboundLocalError:&#10;            _prefetch_stop.wait(interval)&#10;    log.info('Prefetch scheduler stopped')&#10;&#10;# 스케쥴러 시작 함수&#10;# interval: 루프 주기 (초)&#10;# 기본값 30초&#10;def start_prefetch_scheduler(interval: int = 30):&#10;    global _prefetch_thread, _prefetch_stop&#10;    if _prefetch_thread is not None and _prefetch_thread.is_alive():&#10;        return&#10;    _prefetch_stop.clear()&#10;    # Redis 미사용 시 기본 간격 증가&#10;    # Upbit 호출 부담 축소를 위한 조치&#10;    # 기본 최소 60초&#10;    if _redis_client is None:&#10;        interval = max(interval, 60)&#10;        log.info('Redis not connected: starting prefetch with interval %s seconds', interval)&#10;    # Redis 미사용 시 기본 배치 크기 축소&#10;    if _redis_client is None:&#10;        try:&#10;            # 배치사이즈 기본 3으로 축소, config에 없으면 설정&#10;            if 'prefetch_batch_size' not in config._config:&#10;                config._config['prefetch_batch_size'] = 3&#10;        except Exception:&#10;            pass&#10;    # 프리페치 레이트 리미터 및 세마포어 초기화&#10;    # 설정값 읽기 및 기본값 적용&#10;    global _prefetch_token_bucket, _prefetch_semaphore # 전역 변수&#10;    try:&#10;        # 초당 5토큰&#10;        rate = int(config._config.get('prefetch_rate_per_sec', 5))&#10;    except Exception:&#10;        rate = 5&#10;    try:&#10;        # 용량은 rate와 같게&#10;        capacity = int(config._config.get('prefetch_rate_capacity', max(1, rate)))&#10;    except Exception:&#10;        capacity = max(1, rate)&#10;    try:&#10;        # 동시 3개&#10;        max_concurrent = int(config._config.get('prefetch_max_concurrent', 3))&#10;    except Exception:&#10;        max_concurrent = 3&#10;    try:&#10;        # 토큰 버킷 및 세마포어 초기화&#10;        _prefetch_token_bucket = TokenBucket(rate=float(rate), capacity=float(capacity))&#10;        _prefetch_semaphore = threading.BoundedSemaphore(max_concurrent)&#10;        log.info(f'Prefetch rate limiter initialized: rate={rate}/s, capacity={capacity}, max_concurrent={max_concurrent}')&#10;    except Exception as e:&#10;        _prefetch_token_bucket = None&#10;        _prefetch_semaphore = None&#10;        log.warning(f'Failed to initialize prefetch rate limiter: {e}')&#10;    _prefetch_thread = threading.Thread(target=_prefetch_loop, args=(interval,), daemon=True)&#10;    _prefetch_thread.start()&#10;&#10;# 스케쥴러 중지 함수&#10;# 스케쥴러 스레드 종료 대기 (최대 2초)&#10;# 기본값 30초&#10;def stop_prefetch_scheduler():&#10;    global _prefetch_thread, _prefetch_stop&#10;    _prefetch_stop.set()&#10;    if _prefetch_thread is not None:&#10;        _prefetch_thread.join(timeout=2)&#10;    _prefetch_thread = None&#10;&#10;&#10;@app.get(&quot;/health&quot;) # 헬스체크 엔드포인트&#10;def health():&#10;    return {&quot;status&quot;: &quot;ok&quot;}&#10;&#10;&#10;@app.get('/debug/status') # 디버그 상태 엔드포인트&#10;def debug_status():&#10;    &quot;&quot;&quot;Return diagnostic info: pyupbit presence, redis connection, prefetch thread state, universe size.&quot;&quot;&quot;&#10;    try:&#10;        import server.upbit_api as upbit_api&#10;        has_pyupbit = bool(getattr(upbit_api, '_HAS_PYUPBIT', False))&#10;    except Exception:&#10;        has_pyupbit = False&#10;&#10;    redis_up = False&#10;    try:&#10;        redis_up = _redis_client is not None&#10;    except Exception:&#10;        redis_up = False&#10;&#10;    prefetch_running = False&#10;    try:&#10;        prefetch_running = (_prefetch_thread is not None and _prefetch_thread.is_alive())&#10;    except Exception:&#10;        prefetch_running = False&#10;&#10;    universe_len = 0&#10;    try:&#10;        universe_len = len(config._config.get('universe', []))&#10;    except Exception:&#10;        universe_len = 0&#10;&#10;    return {&#10;        'pyupbit': has_pyupbit,&#10;        'redis': redis_up,&#10;        'prefetch_running': prefetch_running,&#10;        'prefetch_index': _prefetch_index,&#10;        'universe_len': universe_len,&#10;    }&#10;&#10;&#10;@app.get(&quot;/config&quot;) # 설정 조회 엔드포인트&#10;def get_config():&#10;    cfg = config._config&#10;    return {&quot;config&quot;: cfg}&#10;&#10;&#10;@app.post(&quot;/config&quot;) # 설정 저장 엔드포인트&#10;def post_config(payload: ConfigPayload):&#10;    new_cfg = payload.config&#10;    # 기본적인 검증: 반드시 strategy_name과 market이 있어야 함&#10;    if not isinstance(new_cfg, dict) or 'strategy_name' not in new_cfg or 'market' not in new_cfg:&#10;        raise HTTPException(status_code=400, detail=&quot;Invalid config payload. 'strategy_name' and 'market' required.&quot;)&#10;&#10;    success = config.save_config(new_cfg)&#10;    if not success:&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to save configuration&quot;)&#10;&#10;    # 저장 후 재로딩&#10;    config.reload_config()&#10;    return {&quot;status&quot;: &quot;saved&quot;}&#10;&#10;&#10;@app.post(&quot;/reload&quot;) # 설정 재로딩 엔드포인트&#10;def reload_config():&#10;    config.reload_config()&#10;    return {&quot;status&quot;: &quot;reloaded&quot;}&#10;&#10;&#10;# --- Screening endpoints ---&#10;# 변동성 상위 N개 티커 조회&#10;# market_prefix: 마켓 접두사 (기본값 &quot;KRW&quot;)&#10;# top_n: 상위 N개 (기본값 10)&#10;# timeframe: 변동성 계산에 사용할 시간대 (기본값 &quot;minute15&quot;)&#10;# 반환값: 변동성 상위 N개 티커 리스트&#10;# 변동성 계산은 (최고가 - 최저가) / 평균 종가 방식 사용&#10;# Upbit의 공용 kline 엔드포인트 사용&#10;# config.json의 'universe' 키에 티커 리스트가 없으면 기본 샘플 리스트 사용, 폴백 처리&#10;# 반환값: {&quot;top&quot;: [ {&quot;ticker&quot;: 티커명, &quot;volatility&quot;: 변동성}, ... ] }&#10;# 캐시 사용으로 중복 Upbit 호출 최소화&#10;# 캐시 TTL은 _KLINES_CACHE_TTL 사용&#10;# 예외 발생 시 해당 티커는 건너뜀&#10;@app.get(&quot;/screen/volatility_top&quot;) # 변동성 상위 티커 조회 엔드포인트&#10;def volatility_top(market_prefix: str = &quot;KRW&quot;, top_n: int = 10, timeframe: str = &quot;minute15&quot;):&#10;    cfg = config._config # 설정 읽기&#10;    universe = cfg.get('universe', []) # 유니버스 읽기&#10;    if not universe:&#10;        # 폴백: 기본 샘플 유니버스&#10;        universe = [f&quot;{market_prefix}-BTC&quot;, f&quot;{market_prefix}-ETH&quot;, f&quot;{market_prefix}-XRP&quot;, f&quot;{market_prefix}-ADA&quot;, f&quot;{market_prefix}-DOGE&quot;, f&quot;{market_prefix}-SOL&quot;, f&quot;{market_prefix}-DOT&quot;, f&quot;{market_prefix}-MATIC&quot;, f&quot;{market_prefix}-BCH&quot;, f&quot;{market_prefix}-LTC&quot;]&#10;&#10;    results = []&#10;    # Try to use internal cache to avoid hammering Upbit when checking multiple tickers&#10;    now = time.time()&#10;    for ticker in universe:&#10;        # 캐시 키 생성 (가장 최근 15캔들 기준)&#10;        key = f&quot;{ticker}|{timeframe}|15&quot;&#10;        # 캐시 조회&#10;        cached = _cache_get(key)&#10;        # 캐시 유효성 검사&#10;        if cached and (now - cached[0]) &lt; _KLINES_CACHE_TTL: # 캐시 유효 시&#10;            klines = cached[1] # 캐시된 값 사용&#10;        else:&#10;            try:&#10;                # Upbit에서 변동성 계산용 klines 조회 (rate-limited)&#10;                # 15캔들 기준 (폴백 200캔들 아님)&#10;                klines = _rate_limited_get_klines(ticker, timeframe, count=15)&#10;            except Exception as e:&#10;                log.warning(f'Rate-limited fetch failed for {ticker}: {e}')&#10;                klines = None&#10;            # 캐시 설정, None도 캐시하여 반복 실패 방지&#10;            _cache_set(key, klines, ttl=_KLINES_CACHE_TTL)&#10;        if not klines:&#10;            continue&#10;        highs = [float(k['high_price']) for k in klines]&#10;        lows = [float(k['low_price']) for k in klines]&#10;        closes = [float(k['trade_price']) for k in klines]&#10;        # 변동성 계산 : (최고가 - 최저가) / 평균 종가 방식&#10;        try:&#10;            vol = (max(highs) - min(lows)) / (sum(closes) / len(closes))&#10;        except Exception:&#10;            vol = 0&#10;        results.append({'ticker': ticker, 'volatility': vol})&#10;&#10;    # 변동성 기준 내림차순 정렬 후 상위 N개 반환&#10;    results_sorted = sorted(results, key=lambda x: x['volatility'], reverse=True)[:top_n]&#10;    return {&quot;top&quot;: results_sorted}&#10;&#10;&#10;# --- Background Event Watcher ---&#10;# 단순 폴링 기반 워처 구현&#10;# 워처는 별도 스레드에서 동작하며, 지정된 마켓의 klines를 주기적으로 조회&#10;# 지정된 조건에 부합하는 이벤트 발생 시 로그 출력&#10;# 조건은 JSON 배열로 전달되며, 각 조건은 다음과 같은 형태를 가짐&#10;# {&quot;type&quot;: &quot;volatility_breakout&quot;, &quot;k&quot;: 0.5} : 변동성 돌파 이벤트 (Larry Williams 스타일)&#10;# {&quot;type&quot;: &quot;volume_spike&quot;, &quot;multiplier&quot;: 3} : 거래량 급증 이벤트&#10;# 워처 시작 엔드포인트&#10;# 요청 본문 예시:&#10;# {&quot;market&quot;: &quot;KRW-BTC&quot;,&#10;# &quot;interval&quot;: 1,&#10;# &quot;callbacks&quot;:[&#10;#     {&quot;type&quot;:&quot;volatility_breakout&quot;, &quot;k&quot;:0.5},&#10;#     {&quot;type&quot;:&quot;volume_spike&quot;, &quot;multiplier&quot;:3}&#10;# ]}&#10;# 워처 중지 엔드포인트&#10;def _watcher_loop(stop_event, market: str, check_interval: float, callbacks: List[dict]):&#10;    &quot;&quot;&quot;Simple polling watcher that fetches latest klines and invokes callbacks when conditions met.&quot;&quot;&quot;&#10;    log.info(f&quot;Starting watcher loop for {market} (interval {check_interval}s)&quot;)&#10;    last_checked_time = None&#10;    while not stop_event.is_set():&#10;        try:&#10;            try:&#10;                # Upbit에서 최신 60캔들 조회 (rate-limited)&#10;                klines = _rate_limited_get_klines(market, 'minute1', count=60)&#10;            except Exception as e:&#10;                log.error(f'Watcher fetch rate-limited or failed for {market}: {e}')&#10;                klines = None&#10;&#10;            # 이벤트 체크&#10;            if klines:&#10;                # 최근 캔들&#10;                latest = klines[0]&#10;                # 변동성 체크용 15캔들 윈도우 준비&#10;                window = klines[:15]&#10;                highs = [float(k['high_price']) for k in window]&#10;                lows = [float(k['low_price']) for k in window]&#10;                volumes = [float(k['candle_acc_trade_volume']) for k in window]&#10;                closes = [float(k['trade_price']) for k in window]&#10;&#10;                # 변동성 돌파 체크 (간단화된 Larry Williams 스타일)&#10;                try:&#10;                    prev_close = closes[1]&#10;                    curr_close = closes[0]&#10;                    volatility_range = max(highs) - min(lows)&#10;                except Exception:&#10;                    prev_close = curr_close = volatility_range = None&#10;&#10;                # 콜백 조건 체크&#10;                if prev_close is not None and curr_close is not None: # 유효한 데이터 시&#10;                    avg_vol = sum(volumes[1:]) / (len(volumes)-1) if len(volumes) &gt; 1 else 0&#10;                    statuses = []&#10;                    for cb in callbacks:&#10;                        cb_type = cb.get('type')&#10;                        # 변동성 돌파 체크&#10;                        if cb_type == 'volatility_breakout':&#10;                            k = cb.get('k', 0.5)&#10;                            triggered = curr_close &gt; (prev_close + volatility_range * k)&#10;                            status = (&#10;                                f&quot;volatility_breakout(k={k}) current={curr_close:.0f} prev={prev_close:.0f} &quot;&#10;                                f&quot;range={volatility_range:.0f} triggered={triggered}&quot;&#10;                            )&#10;                            statuses.append(status)&#10;                            if triggered:&#10;                                log.info(f&quot;Watcher detected volatility breakout on {market} (k={k})&quot;)&#10;                        # 거래량 급증 체크&#10;                        elif cb_type == 'volume_spike':&#10;                            multiplier = cb.get('multiplier', 3)&#10;                            triggered = avg_vol and volumes[0] &gt; avg_vol * multiplier&#10;                            status = (&#10;                                f&quot;volume_spike(mult={multiplier}) current_vol={volumes[0]:.0f} avg_vol={avg_vol:.0f} &quot;&#10;                                f&quot;triggered={bool(triggered)}&quot;&#10;                            )&#10;                            statuses.append(status)&#10;                            if triggered:&#10;                                log.info(f&quot;Watcher detected volume spike on {market} (x{multiplier})&quot;)&#10;                        else:&#10;                            statuses.append(f&quot;unknown callback {cb}&quot;)&#10;                    config_desc = (f&quot;market={market} interval={check_interval}s callbacks={len(callbacks)}&quot;)&#10;                    log.info(f&quot;WatcherCheck: {config_desc} | { ' ; '.join(statuses)}&quot;)&#10;&#10;            time.sleep(check_interval)&#10;        except Exception as e:&#10;            log.error(f&quot;Error in watcher loop: {e}&quot;)&#10;            time.sleep(check_interval)&#10;    log.info(&quot;Watcher loop stopped.&quot;)&#10;&#10;# 워처 시작 엔드포인트&#10;# 요청 본문 예시:&#10;# {&quot;market&quot;: &quot;KRW-BTC&quot;,&#10;# &quot;interval&quot;: 1,&#10;# &quot;callbacks&quot;:[&#10;#     {&quot;type&quot;:&quot;volatility_breakout&quot;, &quot;k&quot;:0.5},&#10;#     {&quot;type&quot;:&quot;volume_spike&quot;, &quot;multiplier&quot;:3}&#10;# ]}&#10;@app.post(&quot;/watcher/start&quot;) # 워처 시작 엔드포인트&#10;def start_watcher(payload: Dict[str, Any]):&#10;    if _watcher['running']:&#10;        raise HTTPException(status_code=400, detail=&quot;Watcher already running&quot;)&#10;&#10;    # 파라미터 추출&#10;    market = payload.get('market', config.MARKET)   # 마켓 (기본값 config.MARKET)&#10;    interval = float(payload.get('interval', 1.0))  # 체크 간격 (초)&#10;    callbacks = payload.get('callbacks', [])        # 콜백 조건 리스트&#10;&#10;    # 워처 스레드 시작&#10;    stop_event = threading.Event()&#10;    # 워처 루프 스레드 생성 및 시작&#10;    t = threading.Thread(target=_watcher_loop, args=(stop_event, market, interval, callbacks), daemon=True)&#10;    _watcher['running'] = True              # 워처 상태 갱신&#10;    _watcher['thread'] = t                  # 워처 스레드 저장&#10;    _watcher['stop_event'] = stop_event     # 중지 이벤트 저장&#10;    t.start()&#10;    return {&quot;status&quot;: &quot;started&quot;}&#10;&#10;# 워처 중지 엔드포인트&#10;# 워처 중지 이벤트 설정 및 스레드 종료 대기&#10;# 워처 상태 초기화&#10;# 반환값: {&quot;status&quot;: &quot;stopped&quot;} 또는 {&quot;status&quot;: &quot;not_running&quot;}&#10;@app.post(&quot;/watcher/stop&quot;)&#10;def stop_watcher():&#10;    if not _watcher['running']:&#10;        return {&quot;status&quot;: &quot;not_running&quot;}&#10;    _watcher['stop_event'].set()&#10;    _watcher['thread'].join(timeout=5)&#10;    _watcher['running'] = False&#10;    _watcher['thread'] = None&#10;    _watcher['stop_event'] = None&#10;    return {&quot;status&quot;: &quot;stopped&quot;}&#10;&#10;# 배치 klines 조회 엔드포인트&#10;# 티커/타임프레임/카운트 조합별로 캐시 키 생성 (인메모리 또는 Redis)&#10;# 요청 본문 예시:&#10;# {&quot;tickers&quot;: [&quot;KRW-BTC&quot;,&quot;KRW-ETH&quot;], &quot;timeframe&quot;:&quot;minute15&quot;, &quot;count&quot;:100}&#10;# 반환값 예시:&#10;# {&quot;klines&quot;: {&quot;KRW-BTC&quot;: [...], &quot;KRW-ETH&quot;: [...]} }&#10;# 각 티커별로 klines를 조회하여 결과 딕셔너리에 저장&#10;# 내부적으로 캐시를 사용하여 중복 Upbit 호출 최소화&#10;# 캐시 TTL은 _KLINES_CACHE_TTL 사용&#10;# 캐시 미스 시 rate-limited fetcher를 사용하여 Upbit에서 klines 조회&#10;# 예외 발생 시 해당 티커는 None으로 설정&#10;@app.post('/klines_batch')&#10;def klines_batch(payload: KlinesBatchRequest):&#10;    req = payload.model_dump()&#10;    tickers = req.get('tickers', []) or []&#10;    timeframe = req.get('timeframe', 'minute15')&#10;    count = int(req.get('count', 100))&#10;&#10;    result = {}&#10;    now = time.time()&#10;    for ticker in tickers:&#10;        key = f&quot;{ticker}|{timeframe}|{count}&quot; # 캐시 키 생성&#10;        cached = _cache_get(key)&#10;        # 캐시 유효성 검사&#10;        # 캐시 유효 시 캐시된 값 사용&#10;        if cached and (now - cached[0]) &lt; _KLINES_CACHE_TTL:&#10;            result[ticker] = cached[1]&#10;            continue&#10;&#10;        # 카운트 이상인 캐시 항목 검색 시도 (인메모리 및 Redis 모두 지원)&#10;        # 가장 큰 count를 가진 항목 선택&#10;        # 캐시 미스 시 rate-limited fetcher 사용&#10;        klines = None&#10;        try:&#10;            # 가능한 경우 Redis에서 검색&#10;            if _redis_client:&#10;                try:&#10;                    pattern = f&quot;{ticker}|{timeframe}|*&quot;&#10;                    # 패턴 매칭 키 조회&#10;                    keys = _redis_client.keys(pattern)&#10;                    # 후보 탐색 및 선택 (요청보다 가장 큰 count)&#10;                    best = None&#10;                    best_cnt = 0&#10;                    for k in keys:&#10;                        try:&#10;                            # 키 파싱 [ticker, timeframe, count]&#10;                            parts = k.split('|')&#10;&#10;                            # 유효한 키 형식 시 (3개 이상 파트로 구성)&#10;                            if len(parts) &gt;= 3:&#10;                                # count 부분 (마지막 부분)&#10;                                kcnt = int(parts[-1])&#10;                                # 요청한 카운트보다 크고 현재 최상위 후보보다 큰 경우&#10;                                if kcnt &gt;= count and kcnt &gt; best_cnt:&#10;                                    best = k        # 후보 키 갱신&#10;                                    best_cnt = kcnt # 후보 카운트 갱신&#10;                        except Exception:&#10;                            continue&#10;                    # 후보 키가 발견된 경우&#10;                    if best:&#10;                        # 후보 키로 캐시 조회&#10;                        cached2 = _cache_get(best, ttl=_KLINES_CACHE_TTL)&#10;                        # 후보 캐시에서 klines 추출&#10;                        if cached2:&#10;                            klines_full = cached2[1]&#10;                            # 유효한 klines 시&#10;                            if isinstance(klines_full, list) and len(klines_full) &gt; 0:&#10;                                # 요청한 개수만큼 슬라이싱하여 반환&#10;                                klines = klines_full[-count:]&#10;                except Exception:&#10;                    pass&#10;            else:&#10;                # 인-메모리 캐시에서 후보 탐색&#10;                try:&#10;                    candidates = []&#10;                    # 인-메모리 캐시 순회&#10;                    for k, v in list(_klines_cache.items()):&#10;                        try:&#10;                            # 키 파싱 [ticker, timeframe, count]&#10;                            parts = k.split('|')&#10;                            # 유효한 키 형식 시 (3개 이상 파트로 구성)&#10;                            if parts[0] == ticker and parts[1] == timeframe:&#10;                                kcnt = int(parts[2])            # count 부분&#10;                                candidates.append((kcnt, v))    # 후보 리스트에 추가&#10;                        except Exception:&#10;                            continue&#10;                    # 후보 정렬 및 선택 (요청보다 큰 count)&#10;                    candidates = sorted(candidates, key=lambda x: x[0], reverse=True) # 내림차순 정렬&#10;                    for kcnt, v in candidates:&#10;                        if kcnt &gt;= count:&#10;                            klines_full = v[1]&#10;                            # 유효한 klines 시&#10;                            if isinstance(klines_full, list) and len(klines_full) &gt; 0:&#10;                                # 요청한 개수만큼 슬라이싱하여 반환&#10;                                klines = klines_full[-count:]&#10;                                break&#10;                except Exception:&#10;                    pass&#10;&#10;            # 캐시에서 발견되지 않은 경우 rate-limited fetcher 사용&#10;            if klines is None:&#10;                try:&#10;                    klines = _rate_limited_get_klines(ticker, timeframe, count=count)&#10;                except Exception as e:&#10;                    log.warning(f'Rate-limited batch fetch failed for {ticker}: {e}')&#10;                    klines = None&#10;        except Exception as e:&#10;            log.warning(f'klines_batch lookup error for {ticker}: {e}')&#10;            klines = None&#10;&#10;        # 캐시 설정 (실패 시에도 캐시하여 반복 실패 방지)&#10;        _cache_set(key, klines, ttl=_KLINES_CACHE_TTL)&#10;        result[ticker] = klines&#10;&#10;    return {'klines': result}&#10;&#10;# --- Private API Endpoints ---&#10;# 잔고 조회 엔드포인트&#10;# Upbit 개인 API 키를 사용하여 잔고 조회&#10;# 키가 구성되지 않은 경우 503 반환&#10;# 이 엔드포인트는 짧은 TTL(_BALANCES_CACHE_TTL)로 잔고를 캐시하여 반복된 Upbit 호출을 줄임&#10;# 반환값에는 추가 진단 필드 포함:&#10;#   - balances: Upbit에서 반환된 원시 잔고 리스트&#10;#   - reported_krw_balance: 잔고에서 보고된 KRW 잔고 (없으면 0)&#10;#   - cached: 응답이 서버 캐시에서 왔는지 여부&#10;#   - cached_ts: 캐시된 시점 타임스탬프&#10;@app.get('/balances')&#10;def get_balances():&#10;    # 잔고 조회 엔드포인트&#10;    if _upbit_private is None:&#10;        raise HTTPException(status_code=503, detail='Upbit API keys not configured on server; balances unavailable')&#10;&#10;    cache_key = 'upbit:balances:all'&#10;    now = time.time()&#10;&#10;    # 캐시 조회 시도&#10;    cached = _cache_get(cache_key, ttl=_BALANCES_CACHE_TTL)&#10;    if cached and (now - cached[0]) &lt; _BALANCES_CACHE_TTL:&#10;        bl = cached[1]&#10;        cached_flag = True&#10;        cached_ts = cached[0]&#10;        log.debug('Balances: cache hit')&#10;    else:&#10;        cached_flag = False&#10;        cached_ts = None&#10;        try:&#10;            bl = _upbit_private.get_balances()&#10;        except Exception as e:&#10;            log.error(f'Balances retrieval failed: {e}')&#10;            # 캐시가 존재하면 캐시된 값 반환 (최선의 노력)&#10;            if cached:&#10;                bl = cached[1]&#10;                cached_flag = True&#10;                cached_ts = cached[0]&#10;            else:&#10;                raise HTTPException(status_code=502, detail=f'Upbit API call failed: {e}')&#10;        # 캐시 설정 (실패 시에도 캐시하여 반복 실패 방지)&#10;        _cache_set(cache_key, bl, ttl=_BALANCES_CACHE_TTL)&#10;&#10;    # KRW 잔고 계산 (반환된 잔고에서)&#10;    # 'currency' 또는 'unit' 필드 사용&#10;    reported_krw = 0.0&#10;    try:&#10;        if isinstance(bl, list):&#10;            for item in bl:&#10;                # 업비트API /v1/accounts는 'currency'와 'balance' 필드를 가진 항목 반환&#10;                try:&#10;                    cur = str(item.get('currency') or item.get('unit') or '').upper()&#10;                    bal = float(item.get('balance') or 0.0)&#10;                except Exception:&#10;                    continue&#10;                if cur == 'KRW' or cur.startswith('KRW'):&#10;                    reported_krw += bal&#10;        elif isinstance(bl, dict):&#10;            # 딕셔너리 형태인 경우 'balances' 키에서 리스트 추출&#10;            lst = bl.get('balances') if 'balances' in bl else None&#10;            if isinstance(lst, list):&#10;                for item in lst:&#10;                    try:&#10;                        cur = str(item.get('currency') or item.get('unit') or '').upper()&#10;                        bal = float(item.get('balance') or 0.0)&#10;                    except Exception:&#10;                        continue&#10;                    if cur == 'KRW' or cur.startswith('KRW'):&#10;                        reported_krw += bal&#10;    except Exception:&#10;        reported_krw = 0.0&#10;&#10;    return {&#10;        'balances': bl,&#10;        'reported_krw_balance': reported_krw,&#10;        'cached': bool(cached_flag),&#10;        'cached_ts': cached_ts,&#10;    }&#10;&#10;# 포지션 조회 엔드포인트&#10;# Upbit 개인 API 키를 사용하여 잔고 조회 후 현재 가격과 결합하여 포지션 계산&#10;# 키가 구성되지 않은 경우 503 반환&#10;# 각 자산별 포지션 정보와 요약 총계 반환&#10;# 포지션 정보에는 다음 필드 포함:&#10;#   - symbol: 마켓 심볼 (예: KRW-BTC)&#10;#   - side: 포지션 방향 (항상 'LONG'으로 설정)&#10;#   - size: 보유 수량&#10;#   - entry_price: 평균 매수가 (없으면 null)&#10;#   - current_price: 현재 가격&#10;#   - unrealized_pnl: 미실현 손익 (없으면 null)&#10;#   - unrealized_pnl_rate: 미실현 손익률 (없으면 null)&#10;#   - notional_krw: 원화 기준 명목 가치&#10;# 요약 정보에는 다음 필드 포함:&#10;#   - total_equity_krw: 총 자산 가치 (원화 기준)&#10;#   - available_krw: 사용 가능한 원화 잔고&#10;#   - prices_fetched: 현재 가격을 성공적으로 조회한 자산 수&#10;#   - excluded_assets: 현재 가격을 조회하지 못해 제외된 자산 목록 (심볼 및 사유 포함)&#10;# 포지션 스냅샷은 히스토리 스토어에 기록됨&#10;# 반환값 예시:&#10;# {&#10;#   &quot;positions&quot;: [ {...}, {...}, ... ],&#10;#   &quot;total_equity_krw&quot;: 12345678.9,&#10;#   &quot;available_krw&quot;: 2345678.9,&#10;#   &quot;prices_fetched&quot;: 5,&#10;#   &quot;excluded_assets&quot;: [ {&quot;symbol&quot;: &quot;KRW-XYZ&quot;, &quot;reason&quot;: &quot;no_price&quot;}, ... ]&#10;# }&#10;@app.get(&quot;/positions&quot;)&#10;def get_positions():&#10;    if _upbit_private is None:&#10;        raise HTTPException(status_code=503, detail='Upbit API keys not configured on server; positions unavailable')&#10;&#10;    try:&#10;        bl = _upbit_private.get_balances() or []&#10;    except Exception as e:&#10;        log.error(f'Failed to retrieve balances for positions endpoint: {e}')&#10;        raise HTTPException(status_code=502, detail=f'Failed to retrieve balances: {e}')&#10;&#10;    positions = []&#10;    total_equity = 0.0&#10;    available_krw = 0.0&#10;&#10;    #시장리스트 작성 및 통화맵 작성 (가격 조회용)&#10;    markets = []&#10;    currency_map = {}&#10;    try:&#10;        for item in bl:&#10;            cur = str(item.get('currency') or item.get('unit') or '').upper()&#10;            bal = float(item.get('balance') or 0) if item is not None else 0.0&#10;            locked = float(item.get('locked') or 0) if item is not None else 0.0&#10;&#10;            # 원화 현금잔고 처리&#10;            if cur == 'KRW' or cur.startswith('KRW'):&#10;                available_krw += bal&#10;                total_equity += bal&#10;                continue&#10;            size = bal + locked&#10;            if size &lt;= 0:&#10;                continue&#10;            market = f'KRW-{cur}'&#10;            markets.append(market)&#10;            currency_map[market] = {&#10;                'currency': cur,&#10;                'size': size,&#10;                'avg_buy_price': float(item.get('avg_buy_price') or 0)&#10;            }&#10;    except Exception as e:&#10;        log.warning(f'Error while parsing balances for positions: {e}')&#10;&#10;    # 현재가격 조회 (1개 캔들 minute1, count=1) (조회수 제한 주의)&#10;    price_map = {}&#10;    for m in set(markets):&#10;        try:&#10;            kl = None&#10;            try:&#10;                kl = _rate_limited_get_klines(m, 'minute1', count=1)&#10;            except Exception as e:&#10;                log.warning(f'Price fetch failed for {m}: {e}')&#10;                kl = None&#10;            price = None&#10;            if kl and isinstance(kl, list) and len(kl) &gt; 0:&#10;                try:&#10;                    first = kl[0]&#10;                    price_candidate = None&#10;&#10;                    # 딕셔너리 레코드 작업&#10;                    # (Upbit API는 'trade_price' 사용)&#10;                    if isinstance(first, dict):&#10;                        price_candidate = first.get('trade_price') or first.get('close')&#10;                    else:&#10;                        # 속성 접근 시도 (일부 래퍼는 .close 또는 .trade_price 노출 가능)&#10;                        price_candidate = getattr(first, 'trade_price', None) or getattr(first, 'close', None)&#10;                    if price_candidate is None:&#10;                        price = None&#10;                    else:&#10;                        price = float(price_candidate)&#10;                except Exception:&#10;                    price = None&#10;            price_map[m] = price&#10;        except Exception as e:&#10;             log.warning(f'Unexpected error fetching price for {m}: {e}')&#10;             price_map[m] = None&#10;&#10;    # 포지션 구성 및 미실현 손익/명목 가치 계산&#10;    excluded_assets = []&#10;    for market, meta in currency_map.items():&#10;        cur = meta['currency']&#10;        size = float(meta['size'])&#10;        avg_price = float(meta.get('avg_buy_price') or 0.0)&#10;        current_price = price_map.get(market)&#10;&#10;        # 자산 현재 가격이 없으면 건너뛰고 보고&#10;        if current_price is None:&#10;            excluded_assets.append({'symbol': market, 'reason': 'no_price'})&#10;            continue&#10;&#10;        notional = size * float(current_price)&#10;        total_equity += notional&#10;        unrealized = None&#10;        unrealized_rate = None&#10;        if avg_price and avg_price &gt; 0:&#10;            unrealized = (float(current_price) - avg_price) * size&#10;            unrealized_rate = (float(current_price) - avg_price) / avg_price * 100&#10;&#10;        pos = {&#10;            'symbol': market,&#10;            'side': 'LONG',&#10;            'size': size,&#10;            'entry_price': avg_price if avg_price &gt; 0 else None,&#10;            'current_price': current_price,&#10;            'unrealized_pnl': unrealized,&#10;            'unrealized_pnl_rate': unrealized_rate,&#10;            'notional_krw': notional,&#10;        }&#10;        positions.append(pos)&#10;&#10;    # Also include list of excluded assets so UI can show a friendly message.&#10;    result = {&#10;        'positions': positions,&#10;        'total_equity_krw': total_equity,&#10;        'available_krw': available_krw,&#10;        'prices_fetched': len([p for p in price_map.values() if p is not None]),&#10;        'excluded_assets': excluded_assets,&#10;    }&#10;    history_store.record_snapshot({&#10;        'ts': time.time(),&#10;        'total_equity': total_equity,&#10;        'available_krw': available_krw,&#10;        'positions': [&#10;            {&#10;                'symbol': pos['symbol'],&#10;                'notional_krw': pos['notional_krw'],&#10;                'unrealized_pnl': pos['unrealized_pnl'],&#10;            }&#10;            for pos in positions&#10;        ],&#10;    })&#10;    return result&#10;&#10;&#10;@app.get('/ai/history')&#10;def get_ai_history(limit: int = 50):&#10;    try:&#10;        limit = max(1, min(int(limit), 200))&#10;    except Exception:&#10;        limit = 50&#10;    history = ai_history_store.get_history(limit=limit)&#10;    return {'items': history}&#10;&#10;&#10;@app.get('/positions/history')&#10;def get_positions_history(limit: int = 365, days: int = 365):&#10;    since = time.time() - float(days) * 86400&#10;    history = history_store.get_history(since=since, limit=limit)&#10;    return {'history': history}&#10;&#10;&#10;@app.post('/ws/start')&#10;def ws_start():&#10;    try:&#10;        start_ws_listener()&#10;        start_ticker_listener()&#10;        return {'status': 'started'}&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to start websocket listener: {exc}')&#10;&#10;@app.post('/ws/stop')&#10;def ws_stop():&#10;    try:&#10;        stop_ws_listener()&#10;        stop_ticker_listener()&#10;        return {'status': 'stopped'}&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to stop websocket listener: {exc}')&#10;&#10;@app.get('/ws/status')&#10;def ws_status():&#10;    running = bool(_ws_listener and _ws_listener._thread and _ws_listener._thread.is_alive())&#10;    return {'running': running, 'targets': _ws_listener.targets if _ws_listener else []}&#10;&#10;@app.get('/ws/stats')&#10;def ws_stats(last_hour_sec: int = 3600, recent_limit: int = 10):&#10;    raw_stats = load_ws_stats()&#10;    summary = summarize_ws_stats(raw_stats, last_hour_secs=last_hour_sec, recent_limit=recent_limit)&#10;    summary.update({&#10;        'running': bool(_ws_listener and _ws_listener._thread and _ws_listener._thread.is_alive()),&#10;        'targets': _ws_listener.targets if _ws_listener else [],&#10;    })&#10;    return summary&#10;&#10;@app.get('/ws/executions')&#10;def ws_executions(limit: int = 0):&#10;    try:&#10;        entries = read_exec_history(limit=limit)&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to load exec history: {exc}')&#10;    return {'executions': entries}&#10;&#10;@app.get('/ws/trades')&#10;def ws_trades(symbol: str, limit: int = 20):&#10;    if _redis_client is None:&#10;        raise HTTPException(status_code=503, detail='Redis cache unavailable; cannot read trades.')&#10;    if not symbol:&#10;        raise HTTPException(status_code=400, detail='symbol query parameter is required.')&#10;    max_limit = min(max(limit, 1), 200)&#10;    key = f'ws:trades:{symbol}'&#10;    raw = _redis_client.lrange(key, 0, max_limit - 1)&#10;    trades = []&#10;    try:&#10;        for item in raw:&#10;            import json as _json&#10;            trades.append(_json.loads(item))&#10;    except Exception:&#10;        trades = []&#10;    return {'symbol': symbol, 'trades': trades}&#10;&#10;&#10;def _ws_ticker_targets() -&gt; List[str]:&#10;    if _ws_listener:&#10;        return _ws_listener.targets&#10;    universe = config._config.get('universe')&#10;    if isinstance(universe, list) and universe:&#10;        return universe&#10;    return [&#10;        'KRW-BTC',&#10;        'KRW-ETH',&#10;        'KRW-ADA',&#10;        'KRW-XRP',&#10;        'KRW-SOL',&#10;    ]&#10;&#10;&#10;@app.get('/ws/ticker_data')&#10;def ws_ticker_data():&#10;    if _redis_client is None:&#10;        raise HTTPException(status_code=503, detail='Redis cache unavailable; cannot read ticker data.')&#10;    targets = _ws_ticker_targets()&#10;    payloads: List[Dict[str, Any]] = []&#10;    for symbol in targets:&#10;        key = f'ws:ticker:{symbol}'&#10;        raw = _redis_client.get(key)&#10;        if not raw:&#10;            continue&#10;        try:&#10;            data = json.loads(raw)&#10;        except Exception:&#10;            continue&#10;        payloads.append({&#10;            'symbol': symbol,&#10;            'opening_price': data.get('opening_price'),&#10;            'high_price': data.get('high_price'),&#10;            'low_price': data.get('low_price'),&#10;            'trade_price': data.get('trade_price') or data.get('trade_price'),&#10;            'prev_closing_price': data.get('prev_closing_price'),&#10;            'change': data.get('change'),&#10;            'timestamp': data.get('trade_timestamp') or data.get('timestamp'),&#10;        })&#10;    return {'tickers': payloads}&#10;&#10;# --- Trading Bot Control API ---&#10;&#10;# 봇 실행 중 여부 확인&#10;def _bot_running():&#10;    return config.BOT_ENABLED&#10;&#10;&#10;@app.post('/bot/control')&#10;def bot_control(payload: Dict[str, Any]):&#10;    enabled = payload.get('enabled')&#10;    interval = payload.get('interval_sec')&#10;    if enabled is None and interval is None:&#10;        raise HTTPException(status_code=400, detail='enabled or interval_sec required')&#10;    try:&#10;        updated = config.update_bot_control(bot_enabled=enabled, bot_interval_sec=interval)&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to update bot config: {exc}')&#10;    return {'status': 'updated', 'bot_enabled': config.BOT_ENABLED, 'bot_interval_sec': config.BOT_INTERVAL_SEC, 'updated': updated}&#10;&#10;&#10;@app.get('/bot/status')&#10;def bot_status():&#10;    return {&#10;        'bot_enabled': config.BOT_ENABLED,&#10;        'bot_interval_sec': config.BOT_INTERVAL_SEC,&#10;        'running': config.BOT_ENABLED,&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="from fastapi import FastAPI, HTTPException # web framework&#10;from contextlib import asynccontextmanager # for lifespan management&#10;from pydantic import BaseModel # data validation, settings management&#10;from typing import Any, Dict, List, Optional # type hints&#10;import threading&#10;import time&#10;import os&#10;&#10;# 시간대 설정&#10;os.environ.setdefault('TZ', 'Asia/Seoul')&#10;try:&#10;    time.tzset()&#10;except Exception:&#10;    pass&#10;&#10;# 외부라이브러리 임포트&#10;import redis # Redis 클라이언트&#10;import json&#10;from concurrent.futures import ThreadPoolExecutor, as_completed # for parallel prefetching&#10;&#10;# 내부API 모듈 임포트&#10;from server import config               # 런타임 설정 관리&#10;from server.upbit_api import UpbitAPI   # 업비트 API 연동&#10;from server.logger import log           # 로깅 설정&#10;from server.history import history_store&#10;from server.history import order_history_store&#10;from server.history import ai_history_store&#10;from server.ws_listener_base import (&#10;    load_ws_stats,&#10;    summarize_ws_stats,&#10;    read_exec_history,&#10;)&#10;from server.ws_listener_private import PrivateWebsocketListener&#10;from server.ws_listener_public import PublicWebsocketlistener&#10;&#10;# Token Bucket 구현 for prefetch&#10;# 간단한 토큰 버킷(rate limiter) 구현&#10;# rate: 초당 토큰 생성 속도&#10;# capacity: 버킷 최대 토큰 수&#10;# consume(tokens, timeout): 지정된 토큰 수를 소비 시도, 타임아웃 내에 성공 여부 반환&#10;# 스레드 안전 구현&#10;# 사용 예시:&#10;# tb = TokenBucket(rate=5, capacity=10)  # 초당 5토큰, 최대 10토큰&#10;# if tb.consume(tokens=1, timeout=2.0):&#10;#     print(&quot;Token acquired&quot;)&#10;# else:&#10;#     print(&quot;Failed to acquire token within timeout&quot;)&#10;class TokenBucket:&#10;    def __init__(self, rate: float, capacity: float):&#10;        self.rate = float(rate)         # 토큰 생성 속도 (초당)&#10;        self.capacity = float(capacity) # 버킷 최대 용량&#10;        self._tokens = float(capacity)  # 현재 토큰 수&#10;        self._last = time.time()        # 마지막 토큰 갱신 시각&#10;        self._lock = threading.Lock()   # 스레드 안전을 위한 락&#10;&#10;    # 토큰 소비 메서드&#10;    # tokens: 소비할 토큰 수&#10;    # timeout: 최대 대기 시간 (초)&#10;    # 반환값: 성공 시 True, 실패 시 False&#10;    def consume(self, tokens: float = 1.0, timeout: float = 5.0) -&gt; bool:&#10;        end = time.time() + float(timeout)&#10;        while time.time() &lt; end:&#10;            with self._lock:&#10;                now = time.time()&#10;                elapsed = max(0.0, now - self._last)&#10;                self._tokens = min(self.capacity, self._tokens + elapsed * self.rate)&#10;                self._last = now&#10;                if self._tokens &gt;= tokens:&#10;                    self._tokens -= tokens&#10;                    return True&#10;            time.sleep(0.01)&#10;        return False&#10;&#10;&#10;# 세마포어 및 토큰 버킷 초기화 (스케줄러 시작 시)&#10;_prefetch_token_bucket: Optional[TokenBucket] = None&#10;_prefetch_semaphore: Optional[threading.BoundedSemaphore] = None&#10;&#10;# 기본 klines 캐시 TTL (초)&#10;# 환경변수 'KLINES_CACHE_TTL'로 설정 가능, 기본값 600초&#10;# 예: os.environ['KLINES_CACHE_TTL'] = '600'&#10;# (기본값 600초로 설정하여 중복 Upbit 요청 감소, 실시간성은 다소 희생, 값이 클수록 캐시 지속시간 증가)&#10;_KLINES_CACHE_TTL = int(os.getenv('KLINES_CACHE_TTL', str(600)))  # default 600s&#10;&#10;# Balances cache TTL (seconds)&#10;_BALANCES_CACHE_TTL = int(os.getenv('BALANCES_CACHE_TTL', '15'))&#10;&#10;# FastAPI 앱 생성 및 수명 주기 관리&#10;@asynccontextmanager&#10;async def lifespan(app: FastAPI): # 수명 주기 관리&#10;    # start prefetch scheduler on startup&#10;    try:&#10;        # read interval from config, default 30s&#10;        # if invalid, fallback to 30s&#10;        # prefetch interval 설정&#10;        # 기본값 30초&#10;        # 환경변수나 config.json의 'prefetch_interval_sec' 키로 설정 가능&#10;        interval = int(config._config.get('prefetch_interval_sec', 30))&#10;    except Exception:&#10;        interval = 30&#10;&#10;    # 스케쥴러 시작&#10;    start_prefetch_scheduler(interval=interval)&#10;    try:&#10;        start_ws_listener()&#10;        start_ticker_listener()&#10;    except Exception as exc:&#10;        log.warning(f'Failed to start websocket listener on startup: {exc}')&#10;    try:&#10;        yield&#10;    finally:&#10;        # 스케쥴러 중지&#10;        stop_prefetch_scheduler()&#10;        stop_ws_listener()&#10;        stop_ticker_listener()&#10;&#10;app = FastAPI(title=&quot;Upbit Trader Runtime API&quot;, lifespan=lifespan) # FastAPI 앱 생성&#10;&#10;# 데이터 모델 정의&#10;class ConfigPayload(BaseModel):&#10;    config: Dict[str, Any]&#10;&#10;# 배치 klines 요청 모델&#10;class KlinesBatchRequest(BaseModel):&#10;    tickers: List[str]&#10;    timeframe: Optional[str] = 'minute15'&#10;    count: Optional[int] = 100&#10;&#10;# 포지션 모델 정의&#10;class Position(BaseModel):&#10;    ticker: str&#10;    amount: float&#10;    avg_price: float&#10;    current_price: float&#10;    pnl: float&#10;&#10;# --- Background Prefetch Scheduler 및 캐시 관리 ---&#10;# 전역 상태 변수들&#10;# Prefetch 스레드 및 제어 변수&#10;# Simple in-memory watcher state (explicit typing to satisfy linters)&#10;_watcher: Dict[str, Any] = {&#10;    'running': False,&#10;    'thread': None,&#10;    'stop_event': None,&#10;}&#10;&#10;# 캐시 딕셔너리&#10;# Simple in-memory cache for batch klines: { key: (timestamp, data) }&#10;_klines_cache: Dict[str, Any] = {}&#10;&#10;&#10;# 레디스(Redis) 클라이언트 초기화&#10;# Redis setup (optional). Use local redis://localhost:6379 if REDIS_URL not set&#10;# 환경변수 'REDIS_URL'로 Redis URL 설정 가능&#10;REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')&#10;_redis_client = None&#10;try:&#10;    # Redis 클라이언트 생성 및 연결 테스트&#10;    _redis_client = redis.from_url(REDIS_URL, decode_responses=True)&#10;    # ping 테스트&#10;    _redis_client.ping()&#10;    log.info(f'Redis cache connected: {REDIS_URL}')&#10;except Exception as e:&#10;    _redis_client = None&#10;    log.warning(f'Redis not available ({REDIS_URL}): {e}. Falling back to in-memory cache')&#10;&#10;# 캐시 설정 함수&#10;# key: 캐시 키&#10;# value: 캐시 값&#10;# ttl: 캐시 만료 시간 (초)&#10;# 기본 TTL은 _KLINES_CACHE_TTL 사용&#10;# Redis 사용 가능 시 Redis에 저장, 아니면 메모리 내 딕셔너리에 저장&#10;# 캐시 조회 시 만료 시간 확인&#10;# 반환값: (타임스탬프, 값) 또는 None&#10;def _cache_set(key: str, value: Any, ttl: int = _KLINES_CACHE_TTL):&#10;    &quot;&quot;&quot;Set cache in Redis if available, else in-memory.&quot;&quot;&quot;&#10;    now = time.time()&#10;    if _redis_client:&#10;        try:&#10;            # store JSON string&#10;            import json as _json&#10;            payload = {'ts': now, 'value': value}&#10;            _redis_client.setex(key, ttl, _json.dumps(payload)) # set with expiry&#10;            return&#10;        except Exception:&#10;            pass&#10;    _klines_cache[key] = (now, value) # store in-memory&#10;&#10;# 캐시 조회 함수&#10;# key: 캐시 키&#10;# ttl: 캐시 만료 시간 (초)&#10;# 기본 TTL은 _KLINES_CACHE_TTL 사용&#10;# 반환값: (타임스탬프, 값) 또는 None&#10;def _cache_get(key: str, ttl: int = _KLINES_CACHE_TTL):&#10;    &quot;&quot;&quot;Get cache value. Return (timestamp, value) or None.&quot;&quot;&quot;&#10;    if _redis_client:&#10;        try:&#10;            import json as _json&#10;            s = _redis_client.get(key) # get JSON string&#10;            if not s:&#10;                return None&#10;            obj = _json.loads(s) # parse JSON&#10;            if time.time() - obj.get('ts', 0) &gt; ttl:&#10;                return None&#10;            return (obj.get('ts'), obj.get('value')) # return (timestamp, value)&#10;        except Exception:&#10;            return None&#10;    return _klines_cache.get(key) # return (timestamp, value) or None&#10;&#10;# Websocket listener state&#10;_ws_listener: Optional[PrivateWebsocketListener] = None&#10;_ticker_listener: Optional[PublicWebsocketlistener] = None&#10;&#10;def start_ws_listener() -&gt; None:&#10;    global _ws_listener&#10;    if _ws_listener and _ws_listener._thread and _ws_listener._thread.is_alive():&#10;        return&#10;    _ws_listener = PrivateWebsocketListener(redis_client=_redis_client)&#10;    _ws_listener.start()&#10;&#10;&#10;def start_ticker_listener() -&gt; None:&#10;    global _ticker_listener&#10;    if _ticker_listener and _ticker_listener._thread and _ticker_listener._thread.is_alive():&#10;        return&#10;    _ticker_listener = PublicWebsocketlistener(redis_client=_redis_client)&#10;    _ticker_listener.start()&#10;&#10;&#10;def stop_ws_listener() -&gt; None:&#10;    global _ws_listener&#10;    if _ws_listener:&#10;        _ws_listener.stop()&#10;&#10;&#10;def stop_ticker_listener() -&gt; None:&#10;    global _ticker_listener&#10;    if _ticker_listener:&#10;        _ticker_listener.stop()&#10;&#10;# Rate-limited Upbit klines fetcher&#10;# ticker_local: 업비트 로컬 티커명 (예: KRW-BTC)&#10;# timeframe: 캔들 시간대 (예: 'minute15')&#10;# count: 조회할 캔들 개수&#10;# 반환값: UpbitAPI.get_klines() 결과&#10;# 전역 토큰 버킷 및 세마포어를 사용하여 호출 제한 및 동시성 제어&#10;# 토큰 획득 및 세마포어 획득 시 타임아웃 처리&#10;# 예외 발생 시 호출 실패&#10;# 반환값: UpbitAPI.get_klines() 결과&#10;def _rate_limited_get_klines(ticker_local: str, timeframe: str, count: int):&#10;    # 전역 토큰 버킷 및 세마포어 사용&#10;    global _prefetch_token_bucket, _prefetch_semaphore&#10;&#10;    # 세마포어 및 토큰 획득 시도&#10;    # 타임아웃은 config의 'prefetch_token_wait_timeout' 키로 설정 가능, 기본 10초&#10;    # 실제 Upbit 호출 수행&#10;    # 예외 발생 시 호출 실패&#10;    acquired = False&#10;    try:&#10;        # 세마포어 획득 시도&#10;        if _prefetch_semaphore is not None:&#10;            # 세마포어 획득 (대기 시간 설정 기본값 10초)&#10;            acquired = _prefetch_semaphore.acquire(timeout=10)&#10;            if not acquired:&#10;                raise RuntimeError('prefetch_semaphore_timeout')&#10;&#10;        # 토큰 획득 시도&#10;        if _prefetch_token_bucket is not None:&#10;            # 토큰 대기 시간 설정&#10;            # 기본값 10초 (즉시 호출 선호), config의 'prefetch_token_wait_timeout' 키로 설정 가능&#10;            try:&#10;                token_wait = float(config._config.get('prefetch_token_wait_timeout', 10.0))&#10;            except Exception:&#10;                token_wait = 10.0&#10;            ok = _prefetch_token_bucket.consume(tokens=1.0, timeout=token_wait)&#10;            if not ok:&#10;                raise RuntimeError('rate_limited')&#10;        # 업비트 공용 API 호출 수행&#10;        # 반환값: UpbitAPI.get_klines() 결과&#10;        # 참고: UpbitAPI 인스턴스는 전역 _upbit_public 사용&#10;        # 이 인스턴스는 API 키를 사용하지 않음&#10;        return _upbit_public.get_klines(ticker_local, timeframe, count=count)&#10;    finally:&#10;        if acquired and _prefetch_semaphore is not None:&#10;            try:&#10;                _prefetch_semaphore.release() # 세마포어 해제&#10;            except Exception:&#10;                pass&#10;&#10;&#10;# 업비트 공용 API 인스턴스&#10;_upbit_public = UpbitAPI()&#10;&#10;# 업비트 인증(Private) API 인스턴스&#10;try:&#10;    access = getattr(config, 'UPBIT_ACCESS_KEY', None)&#10;    secret = getattr(config, 'UPBIT_SECRET_KEY', None)&#10;    if access and secret:&#10;        _upbit_private = UpbitAPI(access_key=access, secret_key=secret)&#10;        log.info('Upbit private API initialized with provided keys')&#10;    else:&#10;        _upbit_private = None&#10;        log.warning('Upbit API keys not provided: private endpoints will be unavailable')&#10;except Exception as e:&#10;    _upbit_private = None&#10;    log.warning(f'Failed to initialize Upbit private API: {e}')&#10;&#10;# 스케쥴러 스레드 및 제어 변수&#10;_prefetch_thread: Optional[threading.Thread] = None&#10;_prefetch_stop = threading.Event()&#10;_prefetch_index = 0&#10;&#10;# 루프 함수 - 주기적으로 universe의 티커들에 대해 klines를 미리 가져와 캐시에 저장&#10;# interval: 루프 주기 (초)&#10;# 기본값 30초&#10;def _prefetch_loop(interval: int = 30):&#10;    log.info('Prefetch scheduler started')&#10;    effective_interval = interval&#10;    while not _prefetch_stop.is_set():&#10;        try:&#10;            # 설정 읽기&#10;            cfg = config._config&#10;            # 티커 유니버스&#10;            universe = cfg.get('universe', [])&#10;            # 실행 중 설정 체크 (런타임 config에서 재정의 허용)&#10;            cfg_count = int(cfg.get('prefetch_count', 200))&#10;            # Redis 미사용 시 보수적으로 설정, upper bound 허용&#10;            if _redis_client is None:&#10;                # When Redis is missing, be conservative but allow a configurable upper bound&#10;                # Redis 미사용 시 최대값 설정, 기본 120, config의 'prefetch_no_redis_max_count' 키로 설정 가능&#10;                try:&#10;                    no_redis_max = int(cfg.get('prefetch_no_redis_max_count', 120))&#10;                except Exception:&#10;                    no_redis_max = 120&#10;                count = min(cfg_count, no_redis_max)&#10;                per_ticker_sleep = float(cfg.get('prefetch_sleep_sec', 1.0))&#10;                log.info('Redis not available: using conservative prefetch settings (count=%s, sleep=%.2f)', count, per_ticker_sleep)&#10;            else:&#10;                count = cfg_count&#10;                per_ticker_sleep = float(cfg.get('prefetch_sleep_sec', 0.2))&#10;&#10;            # Redis 미사용 시 최소 간격 보장&#10;            effective_interval = interval&#10;            if _redis_client is None:&#10;                effective_interval = max(interval, int(cfg.get('prefetch_min_interval_sec', 60)))&#10;            if universe:&#10;                # staggered batch processing to avoid bursts&#10;                batch_size = int(cfg.get('prefetch_batch_size', 5))     # batch size per run&#10;                parallelism = int(cfg.get('prefetch_parallelism', 3))   # max parallel fetches per batch&#10;                global _prefetch_index&#10;                n = len(universe)&#10;                if n == 0:&#10;                    pass&#10;                else:&#10;                    start = _prefetch_index % n # start index&#10;                    end = start + batch_size    # end index (exclusive)&#10;                    indices = list(range(start, min(end, n)))&#10;                    # wrap-around if needed&#10;                    if end &gt; n:&#10;                        indices += list(range(0, end - n))&#10;                    tickers_to_process = [universe[i] for i in indices]&#10;                    # advance index for next run&#10;                    _prefetch_index = (start + len(tickers_to_process)) % max(n,1)&#10;&#10;                    # helper to fetch and cache single ticker&#10;                    def _prefetch_single(ticker_local: str):&#10;                        try:&#10;                            key_local = f&quot;{ticker_local}|minute15|{count}&quot;&#10;                            cached_local = _cache_get(key_local)&#10;                            if cached_local and (time.time() - cached_local[0]) &lt; _KLINES_CACHE_TTL:&#10;                                return (ticker_local, True, 'cached')&#10;                            # use rate-limited fetch so prefetch respects global rate/concurrency limits&#10;                            klines_local = _rate_limited_get_klines(ticker_local, 'minute15', count=count)&#10;                            _cache_set(key_local, klines_local, ttl=_KLINES_CACHE_TTL)&#10;                            return (ticker_local, True, 'fetched')&#10;                        except Exception as exc:&#10;                            log.error(f'Prefetch ticker error for {ticker_local}: {exc}')&#10;                            return (ticker_local, False, str(exc))&#10;&#10;                    # run in ThreadPoolExecutor with limited parallelism&#10;                    with ThreadPoolExecutor(max_workers=min(parallelism, len(tickers_to_process))) as executor:&#10;                        futures = {executor.submit(_prefetch_single, t): t for t in tickers_to_process}&#10;                        for fut in as_completed(futures):&#10;                            try:&#10;                                ticker_res, ok, msg = fut.result()&#10;                                log.debug(f'Prefetch result: {ticker_res} ok={ok} info={msg}')&#10;                            except Exception as e:&#10;                                log.error(f'Prefetch future error: {e}')&#10;                    # after parallel batch, small pause to avoid immediate repeated calls&#10;                    time.sleep(per_ticker_sleep)&#10;        except Exception as e:&#10;            log.error(f'Prefetch error: {e}')&#10;        # wait using effective interval (recompute per loop)&#10;        try:&#10;            _prefetch_stop.wait(effective_interval)&#10;        except UnboundLocalError:&#10;            _prefetch_stop.wait(interval)&#10;    log.info('Prefetch scheduler stopped')&#10;&#10;# 스케쥴러 시작 함수&#10;# interval: 루프 주기 (초)&#10;# 기본값 30초&#10;def start_prefetch_scheduler(interval: int = 30):&#10;    global _prefetch_thread, _prefetch_stop&#10;    if _prefetch_thread is not None and _prefetch_thread.is_alive():&#10;        return&#10;    _prefetch_stop.clear()&#10;    # Redis 미사용 시 기본 간격 증가&#10;    # Upbit 호출 부담 축소를 위한 조치&#10;    # 기본 최소 60초&#10;    if _redis_client is None:&#10;        interval = max(interval, 60)&#10;        log.info('Redis not connected: starting prefetch with interval %s seconds', interval)&#10;    # Redis 미사용 시 기본 배치 크기 축소&#10;    if _redis_client is None:&#10;        try:&#10;            # 배치사이즈 기본 3으로 축소, config에 없으면 설정&#10;            if 'prefetch_batch_size' not in config._config:&#10;                config._config['prefetch_batch_size'] = 3&#10;        except Exception:&#10;            pass&#10;    # 프리페치 레이트 리미터 및 세마포어 초기화&#10;    # 설정값 읽기 및 기본값 적용&#10;    global _prefetch_token_bucket, _prefetch_semaphore # 전역 변수&#10;    try:&#10;        # 초당 5토큰&#10;        rate = int(config._config.get('prefetch_rate_per_sec', 5))&#10;    except Exception:&#10;        rate = 5&#10;    try:&#10;        # 용량은 rate와 같게&#10;        capacity = int(config._config.get('prefetch_rate_capacity', max(1, rate)))&#10;    except Exception:&#10;        capacity = max(1, rate)&#10;    try:&#10;        # 동시 3개&#10;        max_concurrent = int(config._config.get('prefetch_max_concurrent', 3))&#10;    except Exception:&#10;        max_concurrent = 3&#10;    try:&#10;        # 토큰 버킷 및 세마포어 초기화&#10;        _prefetch_token_bucket = TokenBucket(rate=float(rate), capacity=float(capacity))&#10;        _prefetch_semaphore = threading.BoundedSemaphore(max_concurrent)&#10;        log.info(f'Prefetch rate limiter initialized: rate={rate}/s, capacity={capacity}, max_concurrent={max_concurrent}')&#10;    except Exception as e:&#10;        _prefetch_token_bucket = None&#10;        _prefetch_semaphore = None&#10;        log.warning(f'Failed to initialize prefetch rate limiter: {e}')&#10;    _prefetch_thread = threading.Thread(target=_prefetch_loop, args=(interval,), daemon=True)&#10;    _prefetch_thread.start()&#10;&#10;# 스케쥴러 중지 함수&#10;# 스케쥴러 스레드 종료 대기 (최대 2초)&#10;# 기본값 30초&#10;def stop_prefetch_scheduler():&#10;    global _prefetch_thread, _prefetch_stop&#10;    _prefetch_stop.set()&#10;    if _prefetch_thread is not None:&#10;        _prefetch_thread.join(timeout=2)&#10;    _prefetch_thread = None&#10;&#10;&#10;@app.get(&quot;/health&quot;) # 헬스체크 엔드포인트&#10;def health():&#10;    return {&quot;status&quot;: &quot;ok&quot;}&#10;&#10;&#10;@app.get('/debug/status') # 디버그 상태 엔드포인트&#10;def debug_status():&#10;    &quot;&quot;&quot;Return diagnostic info: pyupbit presence, redis connection, prefetch thread state, universe size.&quot;&quot;&quot;&#10;    try:&#10;        import server.upbit_api as upbit_api&#10;        has_pyupbit = bool(getattr(upbit_api, '_HAS_PYUPBIT', False))&#10;    except Exception:&#10;        has_pyupbit = False&#10;&#10;    redis_up = False&#10;    try:&#10;        redis_up = _redis_client is not None&#10;    except Exception:&#10;        redis_up = False&#10;&#10;    prefetch_running = False&#10;    try:&#10;        prefetch_running = (_prefetch_thread is not None and _prefetch_thread.is_alive())&#10;    except Exception:&#10;        prefetch_running = False&#10;&#10;    universe_len = 0&#10;    try:&#10;        universe_len = len(config._config.get('universe', []))&#10;    except Exception:&#10;        universe_len = 0&#10;&#10;    return {&#10;        'pyupbit': has_pyupbit,&#10;        'redis': redis_up,&#10;        'prefetch_running': prefetch_running,&#10;        'prefetch_index': _prefetch_index,&#10;        'universe_len': universe_len,&#10;    }&#10;&#10;&#10;@app.get(&quot;/config&quot;) # 설정 조회 엔드포인트&#10;def get_config():&#10;    cfg = config._config&#10;    return {&quot;config&quot;: cfg}&#10;&#10;&#10;@app.post(&quot;/config&quot;) # 설정 저장 엔드포인트&#10;def post_config(payload: ConfigPayload):&#10;    new_cfg = payload.config&#10;    # 기본적인 검증: 반드시 strategy_name과 market이 있어야 함&#10;    if not isinstance(new_cfg, dict) or 'strategy_name' not in new_cfg or 'market' not in new_cfg:&#10;        raise HTTPException(status_code=400, detail=&quot;Invalid config payload. 'strategy_name' and 'market' required.&quot;)&#10;&#10;    success = config.save_config(new_cfg)&#10;    if not success:&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to save configuration&quot;)&#10;&#10;    # 저장 후 재로딩&#10;    config.reload_config()&#10;    return {&quot;status&quot;: &quot;saved&quot;}&#10;&#10;&#10;@app.post(&quot;/reload&quot;) # 설정 재로딩 엔드포인트&#10;def reload_config():&#10;    config.reload_config()&#10;    return {&quot;status&quot;: &quot;reloaded&quot;}&#10;&#10;&#10;# --- Screening endpoints ---&#10;# 변동성 상위 N개 티커 조회&#10;# market_prefix: 마켓 접두사 (기본값 &quot;KRW&quot;)&#10;# top_n: 상위 N개 (기본값 10)&#10;# timeframe: 변동성 계산에 사용할 시간대 (기본값 &quot;minute15&quot;)&#10;# 반환값: 변동성 상위 N개 티커 리스트&#10;# 변동성 계산은 (최고가 - 최저가) / 평균 종가 방식 사용&#10;# Upbit의 공용 kline 엔드포인트 사용&#10;# config.json의 'universe' 키에 티커 리스트가 없으면 기본 샘플 리스트 사용, 폴백 처리&#10;# 반환값: {&quot;top&quot;: [ {&quot;ticker&quot;: 티커명, &quot;volatility&quot;: 변동성}, ... ] }&#10;# 캐시 사용으로 중복 Upbit 호출 최소화&#10;# 캐시 TTL은 _KLINES_CACHE_TTL 사용&#10;# 예외 발생 시 해당 티커는 건너뜀&#10;@app.get(&quot;/screen/volatility_top&quot;) # 변동성 상위 티커 조회 엔드포인트&#10;def volatility_top(market_prefix: str = &quot;KRW&quot;, top_n: int = 10, timeframe: str = &quot;minute15&quot;):&#10;    cfg = config._config # 설정 읽기&#10;    universe = cfg.get('universe', []) # 유니버스 읽기&#10;    if not universe:&#10;        # 폴백: 기본 샘플 유니버스&#10;        universe = [f&quot;{market_prefix}-BTC&quot;, f&quot;{market_prefix}-ETH&quot;, f&quot;{market_prefix}-XRP&quot;, f&quot;{market_prefix}-ADA&quot;, f&quot;{market_prefix}-DOGE&quot;, f&quot;{market_prefix}-SOL&quot;, f&quot;{market_prefix}-DOT&quot;, f&quot;{market_prefix}-MATIC&quot;, f&quot;{market_prefix}-BCH&quot;, f&quot;{market_prefix}-LTC&quot;]&#10;&#10;    results = []&#10;    # Try to use internal cache to avoid hammering Upbit when checking multiple tickers&#10;    now = time.time()&#10;    for ticker in universe:&#10;        # 캐시 키 생성 (가장 최근 15캔들 기준)&#10;        key = f&quot;{ticker}|{timeframe}|15&quot;&#10;        # 캐시 조회&#10;        cached = _cache_get(key)&#10;        # 캐시 유효성 검사&#10;        if cached and (now - cached[0]) &lt; _KLINES_CACHE_TTL: # 캐시 유효 시&#10;            klines = cached[1] # 캐시된 값 사용&#10;        else:&#10;            try:&#10;                # Upbit에서 변동성 계산용 klines 조회 (rate-limited)&#10;                # 15캔들 기준 (폴백 200캔들 아님)&#10;                klines = _rate_limited_get_klines(ticker, timeframe, count=15)&#10;            except Exception as e:&#10;                log.warning(f'Rate-limited fetch failed for {ticker}: {e}')&#10;                klines = None&#10;            # 캐시 설정, None도 캐시하여 반복 실패 방지&#10;            _cache_set(key, klines, ttl=_KLINES_CACHE_TTL)&#10;        if not klines:&#10;            continue&#10;        highs = [float(k['high_price']) for k in klines]&#10;        lows = [float(k['low_price']) for k in klines]&#10;        closes = [float(k['trade_price']) for k in klines]&#10;        # 변동성 계산 : (최고가 - 최저가) / 평균 종가 방식&#10;        try:&#10;            vol = (max(highs) - min(lows)) / (sum(closes) / len(closes))&#10;        except Exception:&#10;            vol = 0&#10;        results.append({'ticker': ticker, 'volatility': vol})&#10;&#10;    # 변동성 기준 내림차순 정렬 후 상위 N개 반환&#10;    results_sorted = sorted(results, key=lambda x: x['volatility'], reverse=True)[:top_n]&#10;    return {&quot;top&quot;: results_sorted}&#10;&#10;&#10;# --- Background Event Watcher ---&#10;# 단순 폴링 기반 워처 구현&#10;# 워처는 별도 스레드에서 동작하며, 지정된 마켓의 klines를 주기적으로 조회&#10;# 지정된 조건에 부합하는 이벤트 발생 시 로그 출력&#10;# 조건은 JSON 배열로 전달되며, 각 조건은 다음과 같은 형태를 가짐&#10;# {&quot;type&quot;: &quot;volatility_breakout&quot;, &quot;k&quot;: 0.5} : 변동성 돌파 이벤트 (Larry Williams 스타일)&#10;# {&quot;type&quot;: &quot;volume_spike&quot;, &quot;multiplier&quot;: 3} : 거래량 급증 이벤트&#10;# 워처 시작 엔드포인트&#10;# 요청 본문 예시:&#10;# {&quot;market&quot;: &quot;KRW-BTC&quot;,&#10;# &quot;interval&quot;: 1,&#10;# &quot;callbacks&quot;:[&#10;#     {&quot;type&quot;:&quot;volatility_breakout&quot;, &quot;k&quot;:0.5},&#10;#     {&quot;type&quot;:&quot;volume_spike&quot;, &quot;multiplier&quot;:3}&#10;# ]}&#10;# 워처 중지 엔드포인트&#10;def _watcher_loop(stop_event, market: str, check_interval: float, callbacks: List[dict]):&#10;    &quot;&quot;&quot;Simple polling watcher that fetches latest klines and invokes callbacks when conditions met.&quot;&quot;&quot;&#10;    log.info(f&quot;Starting watcher loop for {market} (interval {check_interval}s)&quot;)&#10;    last_checked_time = None&#10;    while not stop_event.is_set():&#10;        try:&#10;            try:&#10;                # Upbit에서 최신 60캔들 조회 (rate-limited)&#10;                klines = _rate_limited_get_klines(market, 'minute1', count=60)&#10;            except Exception as e:&#10;                log.error(f'Watcher fetch rate-limited or failed for {market}: {e}')&#10;                klines = None&#10;&#10;            # 이벤트 체크&#10;            if klines:&#10;                # 최근 캔들&#10;                latest = klines[0]&#10;                # 변동성 체크용 15캔들 윈도우 준비&#10;                window = klines[:15]&#10;                highs = [float(k['high_price']) for k in window]&#10;                lows = [float(k['low_price']) for k in window]&#10;                volumes = [float(k['candle_acc_trade_volume']) for k in window]&#10;                closes = [float(k['trade_price']) for k in window]&#10;&#10;                # 변동성 돌파 체크 (간단화된 Larry Williams 스타일)&#10;                try:&#10;                    prev_close = closes[1]&#10;                    curr_close = closes[0]&#10;                    volatility_range = max(highs) - min(lows)&#10;                except Exception:&#10;                    prev_close = curr_close = volatility_range = None&#10;&#10;                # 콜백 조건 체크&#10;                if prev_close is not None and curr_close is not None: # 유효한 데이터 시&#10;                    avg_vol = sum(volumes[1:]) / (len(volumes)-1) if len(volumes) &gt; 1 else 0&#10;                    statuses = []&#10;                    for cb in callbacks:&#10;                        cb_type = cb.get('type')&#10;                        # 변동성 돌파 체크&#10;                        if cb_type == 'volatility_breakout':&#10;                            k = cb.get('k', 0.5)&#10;                            triggered = curr_close &gt; (prev_close + volatility_range * k)&#10;                            status = (&#10;                                f&quot;volatility_breakout(k={k}) current={curr_close:.0f} prev={prev_close:.0f} &quot;&#10;                                f&quot;range={volatility_range:.0f} triggered={triggered}&quot;&#10;                            )&#10;                            statuses.append(status)&#10;                            if triggered:&#10;                                log.info(f&quot;Watcher detected volatility breakout on {market} (k={k})&quot;)&#10;                        # 거래량 급증 체크&#10;                        elif cb_type == 'volume_spike':&#10;                            multiplier = cb.get('multiplier', 3)&#10;                            triggered = avg_vol and volumes[0] &gt; avg_vol * multiplier&#10;                            status = (&#10;                                f&quot;volume_spike(mult={multiplier}) current_vol={volumes[0]:.0f} avg_vol={avg_vol:.0f} &quot;&#10;                                f&quot;triggered={bool(triggered)}&quot;&#10;                            )&#10;                            statuses.append(status)&#10;                            if triggered:&#10;                                log.info(f&quot;Watcher detected volume spike on {market} (x{multiplier})&quot;)&#10;                        else:&#10;                            statuses.append(f&quot;unknown callback {cb}&quot;)&#10;                    config_desc = (f&quot;market={market} interval={check_interval}s callbacks={len(callbacks)}&quot;)&#10;                    log.info(f&quot;WatcherCheck: {config_desc} | { ' ; '.join(statuses)}&quot;)&#10;&#10;            time.sleep(check_interval)&#10;        except Exception as e:&#10;            log.error(f&quot;Error in watcher loop: {e}&quot;)&#10;            time.sleep(check_interval)&#10;    log.info(&quot;Watcher loop stopped.&quot;)&#10;&#10;# 워처 시작 엔드포인트&#10;# 요청 본문 예시:&#10;# {&quot;market&quot;: &quot;KRW-BTC&quot;,&#10;# &quot;interval&quot;: 1,&#10;# &quot;callbacks&quot;:[&#10;#     {&quot;type&quot;:&quot;volatility_breakout&quot;, &quot;k&quot;:0.5},&#10;#     {&quot;type&quot;:&quot;volume_spike&quot;, &quot;multiplier&quot;:3}&#10;# ]}&#10;@app.post(&quot;/watcher/start&quot;) # 워처 시작 엔드포인트&#10;def start_watcher(payload: Dict[str, Any]):&#10;    if _watcher['running']:&#10;        raise HTTPException(status_code=400, detail=&quot;Watcher already running&quot;)&#10;&#10;    # 파라미터 추출&#10;    market = payload.get('market', config.MARKET)   # 마켓 (기본값 config.MARKET)&#10;    interval = float(payload.get('interval', 1.0))  # 체크 간격 (초)&#10;    callbacks = payload.get('callbacks', [])        # 콜백 조건 리스트&#10;&#10;    # 워처 스레드 시작&#10;    stop_event = threading.Event()&#10;    # 워처 루프 스레드 생성 및 시작&#10;    t = threading.Thread(target=_watcher_loop, args=(stop_event, market, interval, callbacks), daemon=True)&#10;    _watcher['running'] = True              # 워처 상태 갱신&#10;    _watcher['thread'] = t                  # 워처 스레드 저장&#10;    _watcher['stop_event'] = stop_event     # 중지 이벤트 저장&#10;    t.start()&#10;    return {&quot;status&quot;: &quot;started&quot;}&#10;&#10;# 워처 중지 엔드포인트&#10;# 워처 중지 이벤트 설정 및 스레드 종료 대기&#10;# 워처 상태 초기화&#10;# 반환값: {&quot;status&quot;: &quot;stopped&quot;} 또는 {&quot;status&quot;: &quot;not_running&quot;}&#10;@app.post(&quot;/watcher/stop&quot;)&#10;def stop_watcher():&#10;    if not _watcher['running']:&#10;        return {&quot;status&quot;: &quot;not_running&quot;}&#10;    _watcher['stop_event'].set()&#10;    _watcher['thread'].join(timeout=5)&#10;    _watcher['running'] = False&#10;    _watcher['thread'] = None&#10;    _watcher['stop_event'] = None&#10;    return {&quot;status&quot;: &quot;stopped&quot;}&#10;&#10;# 배치 klines 조회 엔드포인트&#10;# 티커/타임프레임/카운트 조합별로 캐시 키 생성 (인메모리 또는 Redis)&#10;# 요청 본문 예시:&#10;# {&quot;tickers&quot;: [&quot;KRW-BTC&quot;,&quot;KRW-ETH&quot;], &quot;timeframe&quot;:&quot;minute15&quot;, &quot;count&quot;:100}&#10;# 반환값 예시:&#10;# {&quot;klines&quot;: {&quot;KRW-BTC&quot;: [...], &quot;KRW-ETH&quot;: [...]} }&#10;# 각 티커별로 klines를 조회하여 결과 딕셔너리에 저장&#10;# 내부적으로 캐시를 사용하여 중복 Upbit 호출 최소화&#10;# 캐시 TTL은 _KLINES_CACHE_TTL 사용&#10;# 캐시 미스 시 rate-limited fetcher를 사용하여 Upbit에서 klines 조회&#10;# 예외 발생 시 해당 티커는 None으로 설정&#10;@app.post('/klines_batch')&#10;def klines_batch(payload: KlinesBatchRequest):&#10;    req = payload.model_dump()&#10;    tickers = req.get('tickers', []) or []&#10;    timeframe = req.get('timeframe', 'minute15')&#10;    count = int(req.get('count', 100))&#10;&#10;    result = {}&#10;    now = time.time()&#10;    for ticker in tickers:&#10;        key = f&quot;{ticker}|{timeframe}|{count}&quot; # 캐시 키 생성&#10;        cached = _cache_get(key)&#10;        # 캐시 유효성 검사&#10;        # 캐시 유효 시 캐시된 값 사용&#10;        if cached and (now - cached[0]) &lt; _KLINES_CACHE_TTL:&#10;            result[ticker] = cached[1]&#10;            continue&#10;&#10;        # 카운트 이상인 캐시 항목 검색 시도 (인메모리 및 Redis 모두 지원)&#10;        # 가장 큰 count를 가진 항목 선택&#10;        # 캐시 미스 시 rate-limited fetcher 사용&#10;        klines = None&#10;        try:&#10;            # 가능한 경우 Redis에서 검색&#10;            if _redis_client:&#10;                try:&#10;                    pattern = f&quot;{ticker}|{timeframe}|*&quot;&#10;                    # 패턴 매칭 키 조회&#10;                    keys = _redis_client.keys(pattern)&#10;                    # 후보 탐색 및 선택 (요청보다 가장 큰 count)&#10;                    best = None&#10;                    best_cnt = 0&#10;                    for k in keys:&#10;                        try:&#10;                            # 키 파싱 [ticker, timeframe, count]&#10;                            parts = k.split('|')&#10;&#10;                            # 유효한 키 형식 시 (3개 이상 파트로 구성)&#10;                            if len(parts) &gt;= 3:&#10;                                # count 부분 (마지막 부분)&#10;                                kcnt = int(parts[-1])&#10;                                # 요청한 카운트보다 크고 현재 최상위 후보보다 큰 경우&#10;                                if kcnt &gt;= count and kcnt &gt; best_cnt:&#10;                                    best = k        # 후보 키 갱신&#10;                                    best_cnt = kcnt # 후보 카운트 갱신&#10;                        except Exception:&#10;                            continue&#10;                    # 후보 키가 발견된 경우&#10;                    if best:&#10;                        # 후보 키로 캐시 조회&#10;                        cached2 = _cache_get(best, ttl=_KLINES_CACHE_TTL)&#10;                        # 후보 캐시에서 klines 추출&#10;                        if cached2:&#10;                            klines_full = cached2[1]&#10;                            # 유효한 klines 시&#10;                            if isinstance(klines_full, list) and len(klines_full) &gt; 0:&#10;                                # 요청한 개수만큼 슬라이싱하여 반환&#10;                                klines = klines_full[-count:]&#10;                except Exception:&#10;                    pass&#10;            else:&#10;                # 인-메모리 캐시에서 후보 탐색&#10;                try:&#10;                    candidates = []&#10;                    # 인-메모리 캐시 순회&#10;                    for k, v in list(_klines_cache.items()):&#10;                        try:&#10;                            # 키 파싱 [ticker, timeframe, count]&#10;                            parts = k.split('|')&#10;                            # 유효한 키 형식 시 (3개 이상 파트로 구성)&#10;                            if parts[0] == ticker and parts[1] == timeframe:&#10;                                kcnt = int(parts[2])            # count 부분&#10;                                candidates.append((kcnt, v))    # 후보 리스트에 추가&#10;                        except Exception:&#10;                            continue&#10;                    # 후보 정렬 및 선택 (요청보다 큰 count)&#10;                    candidates = sorted(candidates, key=lambda x: x[0], reverse=True) # 내림차순 정렬&#10;                    for kcnt, v in candidates:&#10;                        if kcnt &gt;= count:&#10;                            klines_full = v[1]&#10;                            # 유효한 klines 시&#10;                            if isinstance(klines_full, list) and len(klines_full) &gt; 0:&#10;                                # 요청한 개수만큼 슬라이싱하여 반환&#10;                                klines = klines_full[-count:]&#10;                                break&#10;                except Exception:&#10;                    pass&#10;&#10;            # 캐시에서 발견되지 않은 경우 rate-limited fetcher 사용&#10;            if klines is None:&#10;                try:&#10;                    klines = _rate_limited_get_klines(ticker, timeframe, count=count)&#10;                except Exception as e:&#10;                    log.warning(f'Rate-limited batch fetch failed for {ticker}: {e}')&#10;                    klines = None&#10;        except Exception as e:&#10;            log.warning(f'klines_batch lookup error for {ticker}: {e}')&#10;            klines = None&#10;&#10;        # 캐시 설정 (실패 시에도 캐시하여 반복 실패 방지)&#10;        _cache_set(key, klines, ttl=_KLINES_CACHE_TTL)&#10;        result[ticker] = klines&#10;&#10;    return {'klines': result}&#10;&#10;# --- Private API Endpoints ---&#10;# 잔고 조회 엔드포인트&#10;# Upbit 개인 API 키를 사용하여 잔고 조회&#10;# 키가 구성되지 않은 경우 503 반환&#10;# 이 엔드포인트는 짧은 TTL(_BALANCES_CACHE_TTL)로 잔고를 캐시하여 반복된 Upbit 호출을 줄임&#10;# 반환값에는 추가 진단 필드 포함:&#10;#   - balances: Upbit에서 반환된 원시 잔고 리스트&#10;#   - reported_krw_balance: 잔고에서 보고된 KRW 잔고 (없으면 0)&#10;#   - cached: 응답이 서버 캐시에서 왔는지 여부&#10;#   - cached_ts: 캐시된 시점 타임스탬프&#10;@app.get('/balances')&#10;def get_balances():&#10;    # 잔고 조회 엔드포인트&#10;    if _upbit_private is None:&#10;        raise HTTPException(status_code=503, detail='Upbit API keys not configured on server; balances unavailable')&#10;&#10;    cache_key = 'upbit:balances:all'&#10;    now = time.time()&#10;&#10;    # 캐시 조회 시도&#10;    cached = _cache_get(cache_key, ttl=_BALANCES_CACHE_TTL)&#10;    if cached and (now - cached[0]) &lt; _BALANCES_CACHE_TTL:&#10;        bl = cached[1]&#10;        cached_flag = True&#10;        cached_ts = cached[0]&#10;        log.debug('Balances: cache hit')&#10;    else:&#10;        cached_flag = False&#10;        cached_ts = None&#10;        try:&#10;            bl = _upbit_private.get_balances()&#10;        except Exception as e:&#10;            log.error(f'Balances retrieval failed: {e}')&#10;            # 캐시가 존재하면 캐시된 값 반환 (최선의 노력)&#10;            if cached:&#10;                bl = cached[1]&#10;                cached_flag = True&#10;                cached_ts = cached[0]&#10;            else:&#10;                raise HTTPException(status_code=502, detail=f'Upbit API call failed: {e}')&#10;        # 캐시 설정 (실패 시에도 캐시하여 반복 실패 방지)&#10;        _cache_set(cache_key, bl, ttl=_BALANCES_CACHE_TTL)&#10;&#10;    # KRW 잔고 계산 (반환된 잔고에서)&#10;    # 'currency' 또는 'unit' 필드 사용&#10;    reported_krw = 0.0&#10;    try:&#10;        if isinstance(bl, list):&#10;            for item in bl:&#10;                # 업비트API /v1/accounts는 'currency'와 'balance' 필드를 가진 항목 반환&#10;                try:&#10;                    cur = str(item.get('currency') or item.get('unit') or '').upper()&#10;                    bal = float(item.get('balance') or 0.0)&#10;                except Exception:&#10;                    continue&#10;                if cur == 'KRW' or cur.startswith('KRW'):&#10;                    reported_krw += bal&#10;        elif isinstance(bl, dict):&#10;            # 딕셔너리 형태인 경우 'balances' 키에서 리스트 추출&#10;            lst = bl.get('balances') if 'balances' in bl else None&#10;            if isinstance(lst, list):&#10;                for item in lst:&#10;                    try:&#10;                        cur = str(item.get('currency') or item.get('unit') or '').upper()&#10;                        bal = float(item.get('balance') or 0.0)&#10;                    except Exception:&#10;                        continue&#10;                    if cur == 'KRW' or cur.startswith('KRW'):&#10;                        reported_krw += bal&#10;    except Exception:&#10;        reported_krw = 0.0&#10;&#10;    return {&#10;        'balances': bl,&#10;        'reported_krw_balance': reported_krw,&#10;        'cached': bool(cached_flag),&#10;        'cached_ts': cached_ts,&#10;    }&#10;&#10;# 포지션 조회 엔드포인트&#10;# Upbit 개인 API 키를 사용하여 잔고 조회 후 현재 가격과 결합하여 포지션 계산&#10;# 키가 구성되지 않은 경우 503 반환&#10;# 각 자산별 포지션 정보와 요약 총계 반환&#10;# 포지션 정보에는 다음 필드 포함:&#10;#   - symbol: 마켓 심볼 (예: KRW-BTC)&#10;#   - side: 포지션 방향 (항상 'LONG'으로 설정)&#10;#   - size: 보유 수량&#10;#   - entry_price: 평균 매수가 (없으면 null)&#10;#   - current_price: 현재 가격&#10;#   - unrealized_pnl: 미실현 손익 (없으면 null)&#10;#   - unrealized_pnl_rate: 미실현 손익률 (없으면 null)&#10;#   - notional_krw: 원화 기준 명목 가치&#10;# 요약 정보에는 다음 필드 포함:&#10;#   - total_equity_krw: 총 자산 가치 (원화 기준)&#10;#   - available_krw: 사용 가능한 원화 잔고&#10;#   - prices_fetched: 현재 가격을 성공적으로 조회한 자산 수&#10;#   - excluded_assets: 현재 가격을 조회하지 못해 제외된 자산 목록 (심볼 및 사유 포함)&#10;# 포지션 스냅샷은 히스토리 스토어에 기록됨&#10;# 반환값 예시:&#10;# {&#10;#   &quot;positions&quot;: [ {...}, {...}, ... ],&#10;#   &quot;total_equity_krw&quot;: 12345678.9,&#10;#   &quot;available_krw&quot;: 2345678.9,&#10;#   &quot;prices_fetched&quot;: 5,&#10;#   &quot;excluded_assets&quot;: [ {&quot;symbol&quot;: &quot;KRW-XYZ&quot;, &quot;reason&quot;: &quot;no_price&quot;}, ... ]&#10;# }&#10;@app.get(&quot;/positions&quot;)&#10;def get_positions():&#10;    if _upbit_private is None:&#10;        raise HTTPException(status_code=503, detail='Upbit API keys not configured on server; positions unavailable')&#10;&#10;    try:&#10;        bl = _upbit_private.get_balances() or []&#10;    except Exception as e:&#10;        log.error(f'Failed to retrieve balances for positions endpoint: {e}')&#10;        raise HTTPException(status_code=502, detail=f'Failed to retrieve balances: {e}')&#10;&#10;    positions = []&#10;    total_equity = 0.0&#10;    available_krw = 0.0&#10;&#10;    #시장리스트 작성 및 통화맵 작성 (가격 조회용)&#10;    markets = []&#10;    currency_map = {}&#10;    try:&#10;        for item in bl:&#10;            cur = str(item.get('currency') or item.get('unit') or '').upper()&#10;            bal = float(item.get('balance') or 0) if item is not None else 0.0&#10;            locked = float(item.get('locked') or 0) if item is not None else 0.0&#10;&#10;            # 원화 현금잔고 처리&#10;            if cur == 'KRW' or cur.startswith('KRW'):&#10;                available_krw += bal&#10;                total_equity += bal&#10;                continue&#10;            size = bal + locked&#10;            if size &lt;= 0:&#10;                continue&#10;            market = f'KRW-{cur}'&#10;            markets.append(market)&#10;            currency_map[market] = {&#10;                'currency': cur,&#10;                'size': size,&#10;                'avg_buy_price': float(item.get('avg_buy_price') or 0)&#10;            }&#10;    except Exception as e:&#10;        log.warning(f'Error while parsing balances for positions: {e}')&#10;&#10;    # 현재가격 조회 (1개 캔들 minute1, count=1) (조회수 제한 주의)&#10;    price_map = {}&#10;    for m in set(markets):&#10;        try:&#10;            kl = None&#10;            try:&#10;                kl = _rate_limited_get_klines(m, 'minute1', count=1)&#10;            except Exception as e:&#10;                log.warning(f'Price fetch failed for {m}: {e}')&#10;                kl = None&#10;            price = None&#10;            if kl and isinstance(kl, list) and len(kl) &gt; 0:&#10;                try:&#10;                    first = kl[0]&#10;                    price_candidate = None&#10;&#10;                    # 딕셔너리 레코드 작업&#10;                    # (Upbit API는 'trade_price' 사용)&#10;                    if isinstance(first, dict):&#10;                        price_candidate = first.get('trade_price') or first.get('close')&#10;                    else:&#10;                        # 속성 접근 시도 (일부 래퍼는 .close 또는 .trade_price 노출 가능)&#10;                        price_candidate = getattr(first, 'trade_price', None) or getattr(first, 'close', None)&#10;                    if price_candidate is None:&#10;                        price = None&#10;                    else:&#10;                        price = float(price_candidate)&#10;                except Exception:&#10;                    price = None&#10;            price_map[m] = price&#10;        except Exception as e:&#10;             log.warning(f'Unexpected error fetching price for {m}: {e}')&#10;             price_map[m] = None&#10;&#10;    # 포지션 구성 및 미실현 손익/명목 가치 계산&#10;    excluded_assets = []&#10;    for market, meta in currency_map.items():&#10;        cur = meta['currency']&#10;        size = float(meta['size'])&#10;        avg_price = float(meta.get('avg_buy_price') or 0.0)&#10;        current_price = price_map.get(market)&#10;&#10;        # 자산 현재 가격이 없으면 건너뛰고 보고&#10;        if current_price is None:&#10;            excluded_assets.append({'symbol': market, 'reason': 'no_price'})&#10;            continue&#10;&#10;        notional = size * float(current_price)&#10;        total_equity += notional&#10;        unrealized = None&#10;        unrealized_rate = None&#10;        if avg_price and avg_price &gt; 0:&#10;            unrealized = (float(current_price) - avg_price) * size&#10;            unrealized_rate = (float(current_price) - avg_price) / avg_price * 100&#10;&#10;        pos = {&#10;            'symbol': market,&#10;            'side': 'LONG',&#10;            'size': size,&#10;            'entry_price': avg_price if avg_price &gt; 0 else None,&#10;            'current_price': current_price,&#10;            'unrealized_pnl': unrealized,&#10;            'unrealized_pnl_rate': unrealized_rate,&#10;            'notional_krw': notional,&#10;        }&#10;        positions.append(pos)&#10;&#10;    # Also include list of excluded assets so UI can show a friendly message.&#10;    result = {&#10;        'positions': positions,&#10;        'total_equity_krw': total_equity,&#10;        'available_krw': available_krw,&#10;        'prices_fetched': len([p for p in price_map.values() if p is not None]),&#10;        'excluded_assets': excluded_assets,&#10;    }&#10;    history_store.record_snapshot({&#10;        'ts': time.time(),&#10;        'total_equity': total_equity,&#10;        'available_krw': available_krw,&#10;        'positions': [&#10;            {&#10;                'symbol': pos['symbol'],&#10;                'notional_krw': pos['notional_krw'],&#10;                'unrealized_pnl': pos['unrealized_pnl'],&#10;            }&#10;            for pos in positions&#10;        ],&#10;    })&#10;    return result&#10;&#10;&#10;@app.get('/ai/history')&#10;def get_ai_history(limit: int = 50):&#10;    try:&#10;        limit = max(1, min(int(limit), 200))&#10;    except Exception:&#10;        limit = 50&#10;    history = ai_history_store.get_history(limit=limit)&#10;    return {'items': history}&#10;&#10;&#10;@app.get('/positions/history')&#10;def get_positions_history(limit: int = 365, days: int = 365):&#10;    since = time.time() - float(days) * 86400&#10;    history = history_store.get_history(since=since, limit=limit)&#10;    return {'history': history}&#10;&#10;&#10;@app.post('/ws/start')&#10;def ws_start():&#10;    try:&#10;        start_ws_listener()&#10;        start_ticker_listener()&#10;        return {'status': 'started'}&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to start websocket listener: {exc}')&#10;&#10;@app.post('/ws/stop')&#10;def ws_stop():&#10;    try:&#10;        stop_ws_listener()&#10;        stop_ticker_listener()&#10;        return {'status': 'stopped'}&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to stop websocket listener: {exc}')&#10;&#10;@app.get('/ws/status')&#10;def ws_status():&#10;    running = bool(_ws_listener and _ws_listener._thread and _ws_listener._thread.is_alive())&#10;    return {'running': running, 'targets': _ws_listener.targets if _ws_listener else []}&#10;&#10;@app.get('/ws/stats')&#10;def ws_stats(last_hour_sec: int = 3600, recent_limit: int = 10):&#10;    raw_stats = load_ws_stats()&#10;    summary = summarize_ws_stats(raw_stats, last_hour_secs=last_hour_sec, recent_limit=recent_limit)&#10;    summary.update({&#10;        'running': bool(_ws_listener and _ws_listener._thread and _ws_listener._thread.is_alive()),&#10;        'targets': _ws_listener.targets if _ws_listener else [],&#10;    })&#10;    return summary&#10;&#10;@app.get('/ws/executions')&#10;def ws_executions(limit: int = 0):&#10;    try:&#10;        entries = read_exec_history(limit=limit)&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to load exec history: {exc}')&#10;    return {'executions': entries}&#10;&#10;@app.get('/ws/trades')&#10;def ws_trades(symbol: str, limit: int = 20):&#10;    if _redis_client is None:&#10;        raise HTTPException(status_code=503, detail='Redis cache unavailable; cannot read trades.')&#10;    if not symbol:&#10;        raise HTTPException(status_code=400, detail='symbol query parameter is required.')&#10;    max_limit = min(max(limit, 1), 200)&#10;    key = f'ws:trades:{symbol}'&#10;    raw = _redis_client.lrange(key, 0, max_limit - 1)&#10;    trades = []&#10;    try:&#10;        for item in raw:&#10;            import json as _json&#10;            trades.append(_json.loads(item))&#10;    except Exception:&#10;        trades = []&#10;    return {'symbol': symbol, 'trades': trades}&#10;&#10;&#10;def _ws_ticker_targets() -&gt; List[str]:&#10;    if _ws_listener:&#10;        return _ws_listener.targets&#10;    universe = config._config.get('universe')&#10;    if isinstance(universe, list) and universe:&#10;        return universe&#10;    return [&#10;        'KRW-BTC',&#10;        'KRW-ETH',&#10;        'KRW-ADA',&#10;        'KRW-XRP',&#10;        'KRW-SOL',&#10;    ]&#10;&#10;&#10;@app.get('/ws/ticker_data')&#10;def ws_ticker_data():&#10;    if _redis_client is None:&#10;        raise HTTPException(status_code=503, detail='Redis cache unavailable; cannot read ticker data.')&#10;    targets = _ws_ticker_targets()&#10;    payloads: List[Dict[str, Any]] = []&#10;    for symbol in targets:&#10;        key = f'ws:ticker:{symbol}'&#10;        raw = _redis_client.get(key)&#10;        if not raw:&#10;            continue&#10;        try:&#10;            data = json.loads(raw)&#10;        except Exception:&#10;            continue&#10;        payloads.append({&#10;            'symbol': symbol,&#10;            'opening_price': data.get('opening_price'),&#10;            'high_price': data.get('high_price'),&#10;            'low_price': data.get('low_price'),&#10;            'trade_price': data.get('trade_price') or data.get('trade_price'),&#10;            'prev_closing_price': data.get('prev_closing_price'),&#10;            'change': data.get('change'),&#10;            'timestamp': data.get('trade_timestamp') or data.get('timestamp'),&#10;        })&#10;    return {'tickers': payloads}&#10;&#10;# --- Trading Bot Control API ---&#10;&#10;# 봇 실행 중 여부 확인&#10;def _bot_running():&#10;    return config.BOT_ENABLED&#10;&#10;&#10;@app.post('/bot/control')&#10;def bot_control(payload: Dict[str, Any]):&#10;    enabled = payload.get('enabled')&#10;    interval = payload.get('interval_sec')&#10;    if enabled is None and interval is None:&#10;        raise HTTPException(status_code=400, detail='enabled or interval_sec required')&#10;    try:&#10;        updated = config.update_bot_control(bot_enabled=enabled, bot_interval_sec=interval)&#10;    except Exception as exc:&#10;        raise HTTPException(status_code=500, detail=f'Failed to update bot config: {exc}')&#10;    return {'status': 'updated', 'bot_enabled': config.BOT_ENABLED, 'bot_interval_sec': config.BOT_INTERVAL_SEC, 'updated': updated}&#10;&#10;&#10;@app.get('/bot/status')&#10;def bot_status():&#10;    return {&#10;        'bot_enabled': config.BOT_ENABLED,&#10;        'bot_interval_sec': config.BOT_INTERVAL_SEC,&#10;        'running': config.BOT_ENABLED,&#10;    }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/config.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/config.py" />
              <option name="originalContent" value="import os&#10;import json&#10;from dotenv import load_dotenv&#10;from typing import Dict, Any, Optional&#10;from server.logger import log&#10;&#10;# --- 1. .env 파일에서 민감 정보 로드 ---&#10;# server 디렉토리 기준으로 .env 파일 경로 설정&#10;dotenv_path = os.path.join(os.path.dirname(__file__), '.env')&#10;if os.path.exists(dotenv_path):&#10;    load_dotenv(dotenv_path)&#10;    log.info(&quot;.env file loaded successfully.&quot;)&#10;else:&#10;    log.warning(&quot;server/.env file not found. Please create one with your API keys.&quot;)&#10;&#10;# 환경 변수에서 API 키 가져오기 (따옴표/공백 제거)&#10;def _read_env(key: str) -&gt; str | None:&#10;    val = os.getenv(key)&#10;    if val is None:&#10;        return None&#10;    val = val.strip()&#10;    if (val.startswith('&quot;') and val.endswith('&quot;')) or (val.startswith(&quot;'&quot;) and val.endswith(&quot;'&quot;)):&#10;        val = val[1:-1]&#10;    return val or None&#10;&#10;UPBIT_ACCESS_KEY = _read_env(&quot;UPBIT_ACCESS_KEY&quot;)&#10;UPBIT_SECRET_KEY = _read_env(&quot;UPBIT_SECRET_KEY&quot;)&#10;OPENAI_API_KEY = _read_env(&quot;OPENAI_API_KEY&quot;)&#10;GEMINI_API_KEY = _read_env(&quot;GEMINI_API_KEY&quot;)&#10;&#10;# --- 2. runtime/config.json 파일에서 설정 파라미터 로드 ---&#10;def _get_runtime_config_path():&#10;    project_root = os.path.dirname(os.path.dirname(__file__))&#10;    return os.path.join(project_root, 'runtime', 'config.json')&#10;&#10;&#10;def _migrate_config_schema(cfg: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Normalize legacy config keys to the current schema without mutating the original dict.&quot;&quot;&quot;&#10;    normalized = json.loads(json.dumps(cfg)) if isinstance(cfg, dict) else {}&#10;    strategy_params = normalized.setdefault('strategy_params', {})&#10;    vb_params = strategy_params.setdefault('VolatilityBreakout', {})&#10;    legacy = normalized.pop('vb_target_vol_pct', None)&#10;    if 'target_vol_pct' not in vb_params and legacy is not None:&#10;        try:&#10;            vb_params['target_vol_pct'] = float(legacy)&#10;        except (TypeError, ValueError):&#10;            vb_params['target_vol_pct'] = 30.0&#10;    if 'target_vol_pct' not in vb_params:&#10;        vb_params['target_vol_pct'] = 30.0&#10;    return normalized&#10;&#10;&#10;def load_config() -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;config.json 파일에서 설정을 로드하여 반환합니다.&quot;&quot;&quot;&#10;    config_path = _get_runtime_config_path()&#10;    try:&#10;        with open(config_path, 'r', encoding='utf-8') as f:&#10;            config_data = json.load(f)&#10;        log.info(&quot;runtime/config.json file loaded successfully.&quot;)&#10;        return _migrate_config_schema(config_data)&#10;    except FileNotFoundError:&#10;        log.error(&quot;runtime/config.json not found! Please create a configuration file in runtime directory.&quot;)&#10;        return {}&#10;    except json.JSONDecodeError:&#10;        log.error(&quot;Error decoding runtime/config.json. Please check for syntax errors.&quot;)&#10;        return {}&#10;&#10;&#10;def save_config(new_config: Dict[str, Any]) -&gt; bool:&#10;    &quot;&quot;&quot;config.json 파일에 설정을 저장합니다. 안전을 위해 기존 파일을 백업합니다.&#10;&#10;    :param new_config: 저장할 설정 딕셔너리&#10;    :return: 저장 성공 여부&#10;    &quot;&quot;&quot;&#10;    config_path = _get_runtime_config_path()&#10;    backup_path = config_path + '.bak'&#10;    try:&#10;        # 기존 파일 백업&#10;        if os.path.exists(config_path):&#10;            os.replace(config_path, backup_path)&#10;            log.info(f&quot;Existing config.json backed up to {backup_path}&quot;)&#10;&#10;        normalized = _migrate_config_schema(new_config)&#10;        with open(config_path, 'w', encoding='utf-8') as f:&#10;            json.dump(normalized, f, ensure_ascii=False, indent=2)&#10;        log.info(&quot;New configuration saved to runtime/config.json&quot;)&#10;        return True&#10;    except Exception as e:&#10;        log.error(f&quot;Failed to save runtime/config.json: {e}&quot;)&#10;        # 백업 복원 시도&#10;        if os.path.exists(backup_path):&#10;            os.replace(backup_path, config_path)&#10;            log.info(&quot;Restored original config.json from backup due to failure.&quot;)&#10;        return False&#10;&#10;&#10;# 즉시 로드하여 전역 설정 변수로 노출&#10;_config = load_config()&#10;&#10;&#10;def _sync_globals_from_config(cfg: Dict[str, Any]):&#10;    &quot;&quot;&quot;로드된 `_config` 딕셔너리의 값을 모듈 전역 변수로 동기화합니다.&#10;    이 함수는 `reload_config()` 호출 시 기존 전역 변수들이 최신 값으로 갱신되도록 보장합니다.&#10;    &quot;&quot;&quot;&#10;    global STRATEGY_NAME, MARKET, TIMEFRAME, CANDLE_COUNT, LOOP_INTERVAL_SEC&#10;    global MIN_ORDER_AMOUNT, TRADE_AMOUNT_KRW&#10;    global USE_KELLY_CRITERION, KELLY_WIN_RATE, KELLY_PAYOFF_RATIO, KELLY_FRACTION&#10;    global RSI_PERIOD, RSI_OVERSOLD, RSI_OVERBOUGHT&#10;    global VB_K_VALUE, VB_TARGET_VOL_PCT, DM_WINDOW&#10;    global ENSEMBLE_STRATEGY, OPENAI_MODEL, GEMINI_MODEL&#10;    global BOT_ENABLED, BOT_INTERVAL_SEC, BOT_SELL_COOLDOWN_SEC&#10;&#10;    STRATEGY_NAME = cfg.get(&quot;strategy_name&quot;, &quot;RSI&quot;)&#10;    MARKET = cfg.get(&quot;market&quot;, &quot;KRW-BTC&quot;)&#10;    TIMEFRAME = cfg.get(&quot;timeframe&quot;, &quot;minute5&quot;)&#10;    CANDLE_COUNT = cfg.get(&quot;candle_count&quot;, 200)&#10;    LOOP_INTERVAL_SEC = cfg.get(&quot;loop_interval_sec&quot;, 5)&#10;&#10;    _order_settings = cfg.get(&quot;order_settings&quot;, {})&#10;    MIN_ORDER_AMOUNT = _order_settings.get(&quot;min_order_amount&quot;, 5500)&#10;    TRADE_AMOUNT_KRW = _order_settings.get(&quot;trade_amount_krw&quot;, 6000)&#10;&#10;    USE_KELLY_CRITERION = cfg.get(&quot;use_kelly_criterion&quot;, False)&#10;    _kelly_settings = cfg.get(&quot;kelly_criterion&quot;, {})&#10;    KELLY_WIN_RATE = _kelly_settings.get(&quot;win_rate&quot;, 0.5)&#10;    KELLY_PAYOFF_RATIO = _kelly_settings.get(&quot;payoff_ratio&quot;, 1.0)&#10;    KELLY_FRACTION = _kelly_settings.get(&quot;fraction&quot;, 0.5)&#10;&#10;    _strategy_params = cfg.get(&quot;strategy_params&quot;, {})&#10;    _rsi_params = _strategy_params.get(&quot;RSI&quot;, {})&#10;    RSI_PERIOD = _rsi_params.get(&quot;period&quot;, 14)&#10;    RSI_OVERSOLD = _rsi_params.get(&quot;oversold&quot;, 30)&#10;    RSI_OVERBOUGHT = _rsi_params.get(&quot;overbought&quot;, 70)&#10;&#10;    _vb_params = _strategy_params.get(&quot;VolatilityBreakout&quot;, {})&#10;    VB_K_VALUE = _vb_params.get(&quot;k_value&quot;, 0.5)&#10;    VB_TARGET_VOL_PCT = _vb_params.get(&quot;target_vol_pct&quot;, 30.0)&#10;&#10;    _dm_params = _strategy_params.get(&quot;DualMomentum&quot;, {})&#10;    DM_WINDOW = _dm_params.get(&quot;window&quot;, 12)&#10;&#10;    _ai_ensemble_settings = cfg.get(&quot;ai_ensemble&quot;, {})&#10;    ENSEMBLE_STRATEGY = _ai_ensemble_settings.get(&quot;strategy&quot;, &quot;UNANIMOUS&quot;)&#10;    OPENAI_MODEL = _ai_ensemble_settings.get(&quot;openai_model&quot;, &quot;gpt-5.1-nano&quot;)&#10;    GEMINI_MODEL = _ai_ensemble_settings.get(&quot;gemini_model&quot;, &quot;gemini-2.5-flash&quot;)&#10;&#10;    bot_enabled = cfg.get(&quot;bot_enabled&quot;)&#10;    if bot_enabled is None:&#10;        bot_enabled = True&#10;    BOT_ENABLED = bool(bot_enabled)&#10;    BOT_INTERVAL_SEC = float(cfg.get(&quot;bot_interval_sec&quot;, 5.0))&#10;    BOT_SELL_COOLDOWN_SEC = float(cfg.get(&quot;bot_sell_cooldown_sec&quot;, 120.0))&#10;&#10;&#10;# 초기 로드 이후 전역 변수 동기화&#10;_sync_globals_from_config(_config)&#10;&#10;# expose some convenience getters&#10;def get_setting(key: str, default=None):&#10;    value = _config.get(key, default)&#10;    if value is None:&#10;        value = os.environ.get(key, default)&#10;    return value&#10;&#10;&#10;def reload_config():&#10;    global _config&#10;    _config = load_config()&#10;    # 로드된 config로 전역 변수 동기화&#10;    _sync_globals_from_config(_config)&#10;    log.info(&quot;Configuration reloaded.&quot;)&#10;    return _config&#10;&#10;&#10;# --- 기존 전역 변수화 (하위 모듈 호환성 유지) ---&#10;STRATEGY_NAME = _config.get(&quot;strategy_name&quot;, &quot;RSI&quot;)&#10;MARKET = _config.get(&quot;market&quot;, &quot;KRW-BTC&quot;)&#10;TIMEFRAME = _config.get(&quot;timeframe&quot;, &quot;minute5&quot;)&#10;CANDLE_COUNT = _config.get(&quot;candle_count&quot;, 200)&#10;LOOP_INTERVAL_SEC = _config.get(&quot;loop_interval_sec&quot;, 5)&#10;&#10;_order_settings = _config.get(&quot;order_settings&quot;, {})&#10;MIN_ORDER_AMOUNT = _order_settings.get(&quot;min_order_amount&quot;, 5500)&#10;TRADE_AMOUNT_KRW = _order_settings.get(&quot;trade_amount_krw&quot;, 6000)&#10;&#10;USE_KELLY_CRITERION = _config.get(&quot;use_kelly_criterion&quot;, False)&#10;_kelly_settings = _config.get(&quot;kelly_criterion&quot;, {})&#10;KELLY_WIN_RATE = _kelly_settings.get(&quot;win_rate&quot;, 0.5)&#10;KELLY_PAYOFF_RATIO = _kelly_settings.get(&quot;payoff_ratio&quot;, 1.0)&#10;KELLY_FRACTION = _kelly_settings.get(&quot;fraction&quot;, 0.5)&#10;&#10;_strategy_params = _config.get(&quot;strategy_params&quot;, {})&#10;_rsi_params = _strategy_params.get(&quot;RSI&quot;, {})&#10;RSI_PERIOD = _rsi_params.get(&quot;period&quot;, 14)&#10;RSI_OVERSOLD = _rsi_params.get(&quot;oversold&quot;, 30)&#10;RSI_OVERBOUGHT = _rsi_params.get(&quot;overbought&quot;, 70)&#10;&#10;_vb_params = _config.get(&quot;strategy_params&quot;, {}).get(&quot;VolatilityBreakout&quot;, {})&#10;VB_K_VALUE = _vb_params.get(&quot;k_value&quot;, 0.5)&#10;VB_TARGET_VOL_PCT = _vb_params.get(&quot;target_vol_pct&quot;, 30.0)&#10;&#10;_dm_params = _strategy_params.get(&quot;DualMomentum&quot;, {})&#10;DM_WINDOW = _dm_params.get(&quot;window&quot;, 12)&#10;&#10;_ai_ensemble_settings = _config.get(&quot;ai_ensemble&quot;, {})&#10;ENSEMBLE_STRATEGY = _ai_ensemble_settings.get(&quot;strategy&quot;, &quot;UNANIMOUS&quot;)&#10;OPENAI_MODEL = _ai_ensemble_settings.get(&quot;openai_model&quot;, &quot;gpt-5.1-nano&quot;)&#10;GEMINI_MODEL = _ai_ensemble_settings.get(&quot;gemini_model&quot;, &quot;gemini-2.5-flash&quot;)&#10;&#10;BOT_ENABLED = _config.get(&quot;bot_enabled&quot;, True)&#10;BOT_INTERVAL_SEC = float(_config.get(&quot;bot_interval_sec&quot;, 5.0))&#10;BOT_SELL_COOLDOWN_SEC = float(_config.get(&quot;bot_sell_cooldown_sec&quot;, 120.0))&#10;&#10;log.info(f&quot;Configuration loaded: Strategy='{STRATEGY_NAME}', Market='{MARKET}'&quot;)&#10;log.debug(f&quot;Volatility breakout target volatility pct set to {VB_TARGET_VOL_PCT}&quot;)&#10;&#10;&#10;def update_bot_control(bot_enabled: Optional[bool] = None, bot_interval_sec: Optional[float] = None, bot_sell_cooldown_sec: Optional[float] = None):&#10;    &quot;&quot;&quot;Update bot control values and persist them.&quot;&quot;&quot;&#10;    global _config&#10;    updated = False&#10;    if bot_enabled is not None:&#10;        _config['bot_enabled'] = bool(bot_enabled)&#10;        updated = True&#10;    if bot_interval_sec is not None:&#10;        _config['bot_interval_sec'] = float(bot_interval_sec)&#10;        updated = True&#10;    if bot_sell_cooldown_sec is not None:&#10;        _config['bot_sell_cooldown_sec'] = float(bot_sell_cooldown_sec)&#10;        updated = True&#10;    if updated:&#10;        save_config(_config)&#10;        reload_config()&#10;    return updated&#10;" />
              <option name="updatedContent" value="import os&#10;import json&#10;from dotenv import load_dotenv&#10;from typing import Dict, Any, Optional&#10;from server.logger import log&#10;&#10;# --- 1. .env 파일에서 민감 정보 로드 ---&#10;# server 디렉토리 기준으로 .env 파일 경로 설정&#10;dotenv_path = os.path.join(os.path.dirname(__file__), '.env')&#10;if os.path.exists(dotenv_path):&#10;    load_dotenv(dotenv_path)&#10;    log.info(&quot;.env file loaded successfully.&quot;)&#10;else:&#10;    log.warning(&quot;server/.env file not found. Please create one with your API keys.&quot;)&#10;&#10;# 환경 변수에서 API 키 가져오기 (따옴표/공백 제거)&#10;def _read_env(key: str) -&gt; str | None:&#10;    val = os.getenv(key)&#10;    if val is None:&#10;        return None&#10;    val = val.strip()&#10;    if (val.startswith('&quot;') and val.endswith('&quot;')) or (val.startswith(&quot;'&quot;) and val.endswith(&quot;'&quot;)):&#10;        val = val[1:-1]&#10;    return val or None&#10;&#10;UPBIT_ACCESS_KEY = _read_env(&quot;UPBIT_ACCESS_KEY&quot;)&#10;UPBIT_SECRET_KEY = _read_env(&quot;UPBIT_SECRET_KEY&quot;)&#10;OPENAI_API_KEY = _read_env(&quot;OPENAI_API_KEY&quot;)&#10;GEMINI_API_KEY = _read_env(&quot;GEMINI_API_KEY&quot;)&#10;&#10;# --- 2. runtime/config.json 파일에서 설정 파라미터 로드 ---&#10;def _get_runtime_config_path():&#10;    project_root = os.path.dirname(os.path.dirname(__file__))&#10;    return os.path.join(project_root, 'runtime', 'config.json')&#10;&#10;&#10;def _migrate_config_schema(cfg: Dict[str, Any]) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Normalize legacy config keys to the current schema without mutating the original dict.&quot;&quot;&quot;&#10;    normalized = json.loads(json.dumps(cfg)) if isinstance(cfg, dict) else {}&#10;    strategy_params = normalized.setdefault('strategy_params', {})&#10;    vb_params = strategy_params.setdefault('VolatilityBreakout', {})&#10;    legacy = normalized.pop('vb_target_vol_pct', None)&#10;    if 'target_vol_pct' not in vb_params and legacy is not None:&#10;        try:&#10;            vb_params['target_vol_pct'] = float(legacy)&#10;        except (TypeError, ValueError):&#10;            vb_params['target_vol_pct'] = 30.0&#10;    if 'target_vol_pct' not in vb_params:&#10;        vb_params['target_vol_pct'] = 30.0&#10;    return normalized&#10;&#10;&#10;def load_config() -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;config.json 파일에서 설정을 로드하여 반환합니다.&quot;&quot;&quot;&#10;    config_path = _get_runtime_config_path()&#10;    try:&#10;        with open(config_path, 'r', encoding='utf-8') as f:&#10;            config_data = json.load(f)&#10;        log.info(&quot;runtime/config.json file loaded successfully.&quot;)&#10;        return _migrate_config_schema(config_data)&#10;    except FileNotFoundError:&#10;        log.error(&quot;runtime/config.json not found! Please create a configuration file in runtime directory.&quot;)&#10;        return {}&#10;    except json.JSONDecodeError:&#10;        log.error(&quot;Error decoding runtime/config.json. Please check for syntax errors.&quot;)&#10;        return {}&#10;&#10;&#10;def save_config(new_config: Dict[str, Any]) -&gt; bool:&#10;    &quot;&quot;&quot;config.json 파일에 설정을 저장합니다. 안전을 위해 기존 파일을 백업합니다.&#10;&#10;    :param new_config: 저장할 설정 딕셔너리&#10;    :return: 저장 성공 여부&#10;    &quot;&quot;&quot;&#10;    config_path = _get_runtime_config_path()&#10;    backup_path = config_path + '.bak'&#10;    try:&#10;        # 기존 파일 백업&#10;        if os.path.exists(config_path):&#10;            os.replace(config_path, backup_path)&#10;            log.info(f&quot;Existing config.json backed up to {backup_path}&quot;)&#10;&#10;        normalized = _migrate_config_schema(new_config)&#10;        with open(config_path, 'w', encoding='utf-8') as f:&#10;            json.dump(normalized, f, ensure_ascii=False, indent=2)&#10;        log.info(&quot;New configuration saved to runtime/config.json&quot;)&#10;        return True&#10;    except Exception as e:&#10;        log.error(f&quot;Failed to save runtime/config.json: {e}&quot;)&#10;        # 백업 복원 시도&#10;        if os.path.exists(backup_path):&#10;            os.replace(backup_path, config_path)&#10;            log.info(&quot;Restored original config.json from backup due to failure.&quot;)&#10;        return False&#10;&#10;&#10;# 즉시 로드하여 전역 설정 변수로 노출&#10;_config = load_config()&#10;&#10;&#10;def _sync_globals_from_config(cfg: Dict[str, Any]):&#10;    &quot;&quot;&quot;로드된 `_config` 딕셔너리의 값을 모듈 전역 변수로 동기화합니다.&#10;    이 함수는 `reload_config()` 호출 시 기존 전역 변수들이 최신 값으로 갱신되도록 보장합니다.&#10;    &quot;&quot;&quot;&#10;    global STRATEGY_NAME, MARKET, TIMEFRAME, CANDLE_COUNT, LOOP_INTERVAL_SEC&#10;    global MIN_ORDER_AMOUNT, TRADE_AMOUNT_KRW&#10;    global USE_KELLY_CRITERION, KELLY_WIN_RATE, KELLY_PAYOFF_RATIO, KELLY_FRACTION&#10;    global RSI_PERIOD, RSI_OVERSOLD, RSI_OVERBOUGHT&#10;    global VB_K_VALUE, VB_TARGET_VOL_PCT, DM_WINDOW&#10;    global ENSEMBLE_STRATEGY, OPENAI_MODEL, GEMINI_MODEL&#10;    global BOT_ENABLED, BOT_INTERVAL_SEC, BOT_SELL_COOLDOWN_SEC&#10;&#10;    STRATEGY_NAME = cfg.get(&quot;strategy_name&quot;, &quot;RSI&quot;)&#10;    MARKET = cfg.get(&quot;market&quot;, &quot;KRW-BTC&quot;)&#10;    TIMEFRAME = cfg.get(&quot;timeframe&quot;, &quot;minute5&quot;)&#10;    CANDLE_COUNT = cfg.get(&quot;candle_count&quot;, 200)&#10;    LOOP_INTERVAL_SEC = cfg.get(&quot;loop_interval_sec&quot;, 5)&#10;&#10;    _order_settings = cfg.get(&quot;order_settings&quot;, {})&#10;    MIN_ORDER_AMOUNT = _order_settings.get(&quot;min_order_amount&quot;, 5500)&#10;    TRADE_AMOUNT_KRW = _order_settings.get(&quot;trade_amount_krw&quot;, 6000)&#10;&#10;    USE_KELLY_CRITERION = cfg.get(&quot;use_kelly_criterion&quot;, False)&#10;    _kelly_settings = cfg.get(&quot;kelly_criterion&quot;, {})&#10;    KELLY_WIN_RATE = _kelly_settings.get(&quot;win_rate&quot;, 0.5)&#10;    KELLY_PAYOFF_RATIO = _kelly_settings.get(&quot;payoff_ratio&quot;, 1.0)&#10;    KELLY_FRACTION = _kelly_settings.get(&quot;fraction&quot;, 0.5)&#10;&#10;    _strategy_params = cfg.get(&quot;strategy_params&quot;, {})&#10;    _rsi_params = _strategy_params.get(&quot;RSI&quot;, {})&#10;    RSI_PERIOD = _rsi_params.get(&quot;period&quot;, 14)&#10;    RSI_OVERSOLD = _rsi_params.get(&quot;oversold&quot;, 30)&#10;    RSI_OVERBOUGHT = _rsi_params.get(&quot;overbought&quot;, 70)&#10;&#10;    _vb_params = _strategy_params.get(&quot;VolatilityBreakout&quot;, {})&#10;    VB_K_VALUE = _vb_params.get(&quot;k_value&quot;, 0.5)&#10;    VB_TARGET_VOL_PCT = _vb_params.get(&quot;target_vol_pct&quot;, 30.0)&#10;&#10;    _dm_params = _strategy_params.get(&quot;DualMomentum&quot;, {})&#10;    DM_WINDOW = _dm_params.get(&quot;window&quot;, 12)&#10;&#10;    _ai_ensemble_settings = cfg.get(&quot;ai_ensemble&quot;, {})&#10;    ENSEMBLE_STRATEGY = _ai_ensemble_settings.get(&quot;strategy&quot;, &quot;UNANIMOUS&quot;)&#10;    OPENAI_MODEL = _ai_ensemble_settings.get(&quot;openai_model&quot;, &quot;gpt-5.1-nano&quot;)&#10;    GEMINI_MODEL = _ai_ensemble_settings.get(&quot;gemini_model&quot;, &quot;gemini-2.5-flash&quot;)&#10;&#10;    bot_enabled = cfg.get(&quot;bot_enabled&quot;)&#10;    if bot_enabled is None:&#10;        bot_enabled = True&#10;    BOT_ENABLED = bool(bot_enabled)&#10;    BOT_INTERVAL_SEC = float(cfg.get(&quot;bot_interval_sec&quot;, 5.0))&#10;    BOT_SELL_COOLDOWN_SEC = float(cfg.get(&quot;bot_sell_cooldown_sec&quot;, 120.0))&#10;&#10;&#10;# 초기 로드 이후 전역 변수 동기화&#10;_sync_globals_from_config(_config)&#10;&#10;# expose some convenience getters&#10;def get_setting(key: str, default=None):&#10;    value = _config.get(key, default)&#10;    if value is None:&#10;        value = os.environ.get(key, default)&#10;    return value&#10;&#10;&#10;def reload_config():&#10;    global _config&#10;    _config = load_config()&#10;    # 로드된 config로 전역 변수 동기화&#10;    _sync_globals_from_config(_config)&#10;    log.info(&quot;Configuration reloaded.&quot;)&#10;    return _config&#10;&#10;&#10;# --- 기존 전역 변수화 (하위 모듈 호환성 유지) ---&#10;STRATEGY_NAME = _config.get(&quot;strategy_name&quot;, &quot;RSI&quot;)&#10;MARKET = _config.get(&quot;market&quot;, &quot;KRW-BTC&quot;)&#10;TIMEFRAME = _config.get(&quot;timeframe&quot;, &quot;minute5&quot;)&#10;CANDLE_COUNT = _config.get(&quot;candle_count&quot;, 200)&#10;LOOP_INTERVAL_SEC = _config.get(&quot;loop_interval_sec&quot;, 5)&#10;&#10;_order_settings = _config.get(&quot;order_settings&quot;, {})&#10;MIN_ORDER_AMOUNT = _order_settings.get(&quot;min_order_amount&quot;, 5500)&#10;TRADE_AMOUNT_KRW = _order_settings.get(&quot;trade_amount_krw&quot;, 6000)&#10;&#10;USE_KELLY_CRITERION = _config.get(&quot;use_kelly_criterion&quot;, False)&#10;_kelly_settings = _config.get(&quot;kelly_criterion&quot;, {})&#10;KELLY_WIN_RATE = _kelly_settings.get(&quot;win_rate&quot;, 0.5)&#10;KELLY_PAYOFF_RATIO = _kelly_settings.get(&quot;payoff_ratio&quot;, 1.0)&#10;KELLY_FRACTION = _kelly_settings.get(&quot;fraction&quot;, 0.5)&#10;&#10;_strategy_params = _config.get(&quot;strategy_params&quot;, {})&#10;_rsi_params = _strategy_params.get(&quot;RSI&quot;, {})&#10;RSI_PERIOD = _rsi_params.get(&quot;period&quot;, 14)&#10;RSI_OVERSOLD = _rsi_params.get(&quot;oversold&quot;, 30)&#10;RSI_OVERBOUGHT = _rsi_params.get(&quot;overbought&quot;, 70)&#10;&#10;_vb_params = _config.get(&quot;strategy_params&quot;, {}).get(&quot;VolatilityBreakout&quot;, {})&#10;VB_K_VALUE = _vb_params.get(&quot;k_value&quot;, 0.5)&#10;VB_TARGET_VOL_PCT = _vb_params.get(&quot;target_vol_pct&quot;, 30.0)&#10;&#10;_dm_params = _strategy_params.get(&quot;DualMomentum&quot;, {})&#10;DM_WINDOW = _dm_params.get(&quot;window&quot;, 12)&#10;&#10;_ai_ensemble_settings = _config.get(&quot;ai_ensemble&quot;, {})&#10;ENSEMBLE_STRATEGY = _ai_ensemble_settings.get(&quot;strategy&quot;, &quot;UNANIMOUS&quot;)&#10;OPENAI_MODEL = _ai_ensemble_settings.get(&quot;openai_model&quot;, &quot;gpt-5.1-nano&quot;)&#10;GEMINI_MODEL = _ai_ensemble_settings.get(&quot;gemini_model&quot;, &quot;gemini-2.5-flash&quot;)&#10;&#10;BOT_ENABLED = _config.get(&quot;bot_enabled&quot;, True)&#10;BOT_INTERVAL_SEC = float(_config.get(&quot;bot_interval_sec&quot;, 5.0))&#10;BOT_SELL_COOLDOWN_SEC = float(_config.get(&quot;bot_sell_cooldown_sec&quot;, 120.0))&#10;&#10;log.info(f&quot;Configuration loaded: Strategy='{STRATEGY_NAME}', Market='{MARKET}'&quot;)&#10;log.debug(f&quot;Volatility breakout target volatility pct set to {VB_TARGET_VOL_PCT}&quot;)&#10;&#10;&#10;def update_bot_control(bot_enabled: Optional[bool] = None, bot_interval_sec: Optional[float] = None, bot_sell_cooldown_sec: Optional[float] = None):&#10;    &quot;&quot;&quot;Update bot control values and persist them.&quot;&quot;&quot;&#10;    global _config&#10;    updated = False&#10;    if bot_enabled is not None:&#10;        _config['bot_enabled'] = bool(bot_enabled)&#10;        updated = True&#10;    if bot_interval_sec is not None:&#10;        _config['bot_interval_sec'] = float(bot_interval_sec)&#10;        updated = True&#10;    if bot_sell_cooldown_sec is not None:&#10;        _config['bot_sell_cooldown_sec'] = float(bot_sell_cooldown_sec)&#10;        updated = True&#10;    if updated:&#10;        save_config(_config)&#10;        reload_config()&#10;    return updated" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/history.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/history.py" />
              <option name="originalContent" value="import json&#10;import os&#10;import threading&#10;import time&#10;from pathlib import Path&#10;from typing import Any, Dict, List, Optional&#10;&#10;HISTORY_DIR = Path(__file__).resolve().parents[1] / &quot;runtime&quot; / &quot;history&quot;&#10;HISTORY_FILE = HISTORY_DIR / &quot;positions_history.json&quot;&#10;MAX_ENTRIES = int(os.getenv(&quot;POSITIONS_HISTORY_MAX_ENTRIES&quot;, &quot;720&quot;))&#10;MIN_INTERVAL_SEC = int(os.getenv(&quot;POSITIONS_HISTORY_MIN_INTERVAL_SEC&quot;, &quot;900&quot;))&#10;ORDER_HISTORY_FILE = HISTORY_DIR / &quot;order_history.json&quot;&#10;ORDER_HISTORY_MAX = int(os.getenv(&quot;ORDER_HISTORY_MAX_ENTRIES&quot;, &quot;1024&quot;))&#10;AI_HISTORY_FILE = HISTORY_DIR / &quot;ai_decisions.json&quot;&#10;AI_HISTORY_MAX = int(os.getenv(&quot;AI_HISTORY_MAX_ENTRIES&quot;, &quot;1024&quot;))&#10;&#10;&#10;def _ensure_dir() -&gt; None:&#10;    HISTORY_DIR.mkdir(parents=True, exist_ok=True)&#10;&#10;&#10;class HistoryStore:&#10;    def __init__(self, path: Path = HISTORY_FILE, max_entries: int = MAX_ENTRIES, min_interval: int = MIN_INTERVAL_SEC):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        self.min_interval = min_interval&#10;        self.lock = threading.Lock()&#10;        _ensure_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception:&#10;            pass&#10;&#10;    def record_snapshot(self, snapshot: Dict[str, Any]) -&gt; bool:&#10;        now = snapshot.get(&quot;ts&quot;) or time.time()&#10;        snapshot[&quot;ts&quot;] = float(now)&#10;        with self.lock:&#10;            data = self._load()&#10;            last_ts = float(data[-1].get(&quot;ts&quot;, 0)) if data else 0&#10;            if now - last_ts &lt; self.min_interval:&#10;                return False&#10;            data.append(snapshot)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;        return True&#10;&#10;    def get_history(self, since: Optional[float] = None, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:&#10;        with self.lock:&#10;            data = self._load()&#10;        if since is not None:&#10;            data = [item for item in data if float(item.get(&quot;ts&quot;, 0)) &gt;= since]&#10;        if limit is not None and limit &lt; len(data):&#10;            data = data[-limit:]&#10;        return data&#10;&#10;&#10;history_store = HistoryStore()&#10;&#10;&#10;class OrderHistoryStore:&#10;    def __init__(self, path: Path = ORDER_HISTORY_FILE, max_entries: int = ORDER_HISTORY_MAX):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        self.lock = threading.Lock()&#10;        _ensure_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception:&#10;            pass&#10;&#10;    def record(self, entry: Dict[str, Any]) -&gt; None:&#10;        entry.setdefault(&quot;ts&quot;, time.time())&#10;        with self.lock:&#10;            data = self._load()&#10;            data.append(entry)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;&#10;&#10;order_history_store = OrderHistoryStore()&#10;&#10;&#10;class AIHistoryStore:&#10;    def __init__(self, path: Path = AI_HISTORY_FILE, max_entries: int = AI_HISTORY_MAX):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        self.lock = threading.Lock()&#10;        _ensure_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception:&#10;            pass&#10;&#10;    def record(self, entry: Dict[str, Any]) -&gt; None:&#10;        entry.setdefault(&quot;ts&quot;, time.time())&#10;        with self.lock:&#10;            data = self._load()&#10;            data.append(entry)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;&#10;    def get_history(self, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:&#10;        with self.lock:&#10;            data = self._load()&#10;        if limit is not None and limit &gt; 0 and len(data) &gt; limit:&#10;            data = data[-limit:]&#10;        return data&#10;&#10;&#10;ai_history_store = AIHistoryStore()&#10;" />
              <option name="updatedContent" value="import json&#10;import os&#10;import threading&#10;import time&#10;from pathlib import Path&#10;from typing import Any, Dict, List, Optional&#10;&#10;HISTORY_DIR = Path(__file__).resolve().parents[1] / &quot;runtime&quot; / &quot;history&quot;&#10;HISTORY_FILE = HISTORY_DIR / &quot;positions_history.json&quot;&#10;MAX_ENTRIES = int(os.getenv(&quot;POSITIONS_HISTORY_MAX_ENTRIES&quot;, &quot;720&quot;))&#10;MIN_INTERVAL_SEC = int(os.getenv(&quot;POSITIONS_HISTORY_MIN_INTERVAL_SEC&quot;, &quot;900&quot;))&#10;ORDER_HISTORY_FILE = HISTORY_DIR / &quot;order_history.json&quot;&#10;ORDER_HISTORY_MAX = int(os.getenv(&quot;ORDER_HISTORY_MAX_ENTRIES&quot;, &quot;1024&quot;))&#10;AI_HISTORY_FILE = HISTORY_DIR / &quot;ai_decisions.json&quot;&#10;AI_HISTORY_MAX = int(os.getenv(&quot;AI_HISTORY_MAX_ENTRIES&quot;, &quot;1024&quot;))&#10;&#10;&#10;def _ensure_dir() -&gt; None:&#10;    HISTORY_DIR.mkdir(parents=True, exist_ok=True)&#10;&#10;&#10;class HistoryStore:&#10;    def __init__(self, path: Path = HISTORY_FILE, max_entries: int = MAX_ENTRIES, min_interval: int = MIN_INTERVAL_SEC):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        self.min_interval = min_interval&#10;        self.lock = threading.Lock()&#10;        _ensure_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception:&#10;            pass&#10;&#10;    def record_snapshot(self, snapshot: Dict[str, Any]) -&gt; bool:&#10;        now = snapshot.get(&quot;ts&quot;) or time.time()&#10;        snapshot[&quot;ts&quot;] = float(now)&#10;        with self.lock:&#10;            data = self._load()&#10;            last_ts = float(data[-1].get(&quot;ts&quot;, 0)) if data else 0&#10;            if now - last_ts &lt; self.min_interval:&#10;                return False&#10;            data.append(snapshot)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;        return True&#10;&#10;    def get_history(self, since: Optional[float] = None, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:&#10;        with self.lock:&#10;            data = self._load()&#10;        if since is not None:&#10;            data = [item for item in data if float(item.get(&quot;ts&quot;, 0)) &gt;= since]&#10;        if limit is not None and limit &lt; len(data):&#10;            data = data[-limit:]&#10;        return data&#10;&#10;&#10;history_store = HistoryStore()&#10;&#10;&#10;class OrderHistoryStore:&#10;    def __init__(self, path: Path = ORDER_HISTORY_FILE, max_entries: int = ORDER_HISTORY_MAX):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        self.lock = threading.Lock()&#10;        _ensure_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception:&#10;            pass&#10;&#10;    def record(self, entry: Dict[str, Any]) -&gt; None:&#10;        entry.setdefault(&quot;ts&quot;, time.time())&#10;        with self.lock:&#10;            data = self._load()&#10;            data.append(entry)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;&#10;&#10;order_history_store = OrderHistoryStore()&#10;&#10;&#10;class AIHistoryStore:&#10;    def __init__(self, path: Path = AI_HISTORY_FILE, max_entries: int = AI_HISTORY_MAX):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        self.lock = threading.Lock()&#10;        _ensure_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception:&#10;            pass&#10;&#10;    def record(self, entry: Dict[str, Any]) -&gt; None:&#10;        entry.setdefault(&quot;ts&quot;, time.time())&#10;        with self.lock:&#10;            data = self._load()&#10;            data.append(entry)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;&#10;    def get_history(self, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:&#10;        with self.lock:&#10;            data = self._load()&#10;        if limit is not None and limit &gt; 0 and len(data) &gt; limit:&#10;            data = data[-limit:]&#10;        return data&#10;&#10;&#10;ai_history_store = AIHistoryStore()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/money_manager.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/money_manager.py" />
              <option name="originalContent" value="from server.logger import log&#10;&#10;#  Kelly Criterion 기반 자금 관리자&#10;# Kelly Criterion: f* = (p*b - (1-p)) / b&#10;# f* = 최적 베팅 비율&#10;# p = 승률 (0 &lt; p &lt; 1)&#10;# b = 평균 이익 / 평균 손실 (payoff ratio, b &gt; 0)&#10;# 참고: https://en.wikipedia.org/wiki/Kelly_criterion&#10;# 예시: 승률 60%, 손익비 1.5인 전략의 경우&#10;# f* = (0.6*1.5 - 0.4) / 1.5 = 0.4 (즉, 자산의 40%를 투자)&#10;# 단, 실제 투자에서는 변동성을 고려하여 절반 켈리(Half Kelly) 등을 권장합니다.&#10;&#10;class KellyCriterionManager:&#10;&#10;    # 켈리 기준 자금 관리자 초기화&#10;    def __init__(self, win_rate=0.4, payoff_ratio=2.0, fraction=0.5, risk_per_trade=0.02):&#10;&#10;        #:param win_rate: 전략의 승률 (0 &lt; win_rate &lt; 1)&#10;        #:param payoff_ratio: 평균 이익 / 평균 손실 (payoff_ratio &gt; 0)&#10;        #:param fraction: 계산된 켈리 비율에 적용할 비중 (e.g., 0.5 for Half Kelly)&#10;        #:param risk_per_trade: 1회 트레이딩 당 계좌 대비 최대 손실 허용 비율 (기본 2%)&#10;        if not (0 &lt; win_rate &lt; 1):&#10;            raise ValueError(&quot;Win rate must be between 0 and 1.&quot;)&#10;        if payoff_ratio &lt;= 0:&#10;            raise ValueError(&quot;Payoff ratio must be greater than 0.&quot;)&#10;        if not (0 &lt; fraction &lt;= 1):&#10;            raise ValueError(&quot;Kelly fraction must be between 0 and 1.&quot;)&#10;&#10;        # 멤버 변수 설정&#10;        self.win_rate = win_rate&#10;        self.payoff_ratio = payoff_ratio&#10;        self.fraction = fraction&#10;        self.risk_per_trade = risk_per_trade&#10;&#10;        # 켈리 공식: f = (p*b - (1-p)) / b&#10;        # p = win_rate, b = payoff_ratio&#10;        kelly_f = ((self.win_rate * self.payoff_ratio) - (1 - self.win_rate)) / self.payoff_ratio&#10;&#10;        # 음수일 경우 0으로 설정하여 손실 방지&#10;        self.kelly_fraction = max(0, kelly_f) * self.fraction  # 음수일 경우 0으로&#10;&#10;        log.info(&quot;Kelly Criterion Initialized.&quot;)&#10;        log.info(f&quot;  - Win Rate: {self.win_rate:.2%}&quot;)&#10;        log.info(f&quot;  - Payoff Ratio: {self.payoff_ratio:.2f}&quot;)&#10;        log.info(f&quot;  - Applied Kelly Fraction (f): {self.kelly_fraction:.2%}&quot;)&#10;        log.info(f&quot;  - Risk per Trade: {self.risk_per_trade:.2%}&quot;)&#10;&#10;    # 총 자산 대비 투자 금액 계산&#10;    # 총 자산의 일정 비율을 켈리 공식에 따라 투자 금액으로 산정&#10;    # e.g., 총 자산 1,000,000 KRW, 켈리 비율 20% -&gt; 200,000 KRW 투자&#10;    # 반환값: 투자할 금액 (float)&#10;    #:param total_balance: 총 자산 (e.g., KRW 잔고)&#10;    #:return: (float) 투자할 금액&#10;    # 계산된 투자 금액 반환&#10;    # 총 자산이 0이거나 켈리 비율이 0인 경우 0 반환&#10;    # 로그에 계산된 투자 금액 출력&#10;    # e.g., &quot;Calculated trade amount: 200,000 KRW (Balance: 1,000,000 * Kelly: 20.00%)&quot;&#10;    # 반환값: 투자할 금액 (float)&#10;    def calculate_trade_amount(self, total_balance):&#10;        if self.kelly_fraction &lt;= 0:&#10;            log.warning(&quot;Kelly fraction is 0 or negative. No investment is advised.&quot;)&#10;            return 0&#10;&#10;        # 총 자산이 0인 경우 0 반환&#10;        if total_balance &lt;= 0:&#10;            log.warning(&quot;Total balance is 0 or negative. No investment can be made.&quot;)&#10;            return 0&#10;&#10;        trade_amount = total_balance * self.kelly_fraction&#10;        log.info(f&quot;Calculated trade amount: {trade_amount:,.0f} KRW (Balance: {total_balance:,.0f} * Kelly: {self.kelly_fraction:.2%})&quot;)&#10;        return trade_amount&#10;&#10;    # 매수 진입 시 적절한 투자 금액과 수량 계산&#10;    # 리스크 관리와 켈리 기준을 모두 고려하여 최종 투자 금액 산정&#10;    #   [로직 설명]&#10;    #    1. 리스크 기반 계산 (Survival): 손절 나갔을 때 계좌의 R(2%)만 잃도록 수량 설정.&#10;    #       - 공식: 허용 손실금액 / (매수가 - 손절가)&#10;    #    2. 켈리 기반 계산 (Growth): 켈리 비중만큼 투자.&#10;    #    3. 최종 결정: 두 값 중 더 '안전한(작은)' 값을 선택하고, 시장 상황(market_factor)을 곱함.&#10;    #&#10;    #    # input&#10;    #    :param total_balance: 현재 계좌 총액 (KRW)&#10;    #    :param entry_price: 진입 예정 가격&#10;    #    :param stop_loss_price: 손절 예정 가격&#10;    #    :param market_factor: 시장 상황 점수 (0.0 ~ 1.0, 1.0=상승장 풀배팅, 0.5=보수적, 0.0=매매금지)&#10;&#10;    #    # return: {&#10;    #        'trade_amount': 투자할 총 금액 (KRW),&#10;    #        'quantity': 구매할 코인 수량,&#10;    #        'risk_amount': 예상 손실 금액,&#10;    #        'reason': 계산 근거&#10;    #    }&#10;    def get_position_size(self, total_balance, entry_price, stop_loss_price, market_factor=1.0):&#10;        if total_balance &lt;= 0 or entry_price &lt;= 0:&#10;            return {'trade_amount': 0, 'quantity': 0, 'reason': &quot;Invalid Balance or Price&quot;}&#10;&#10;        # 1. 1회 최대 허용 손실금액 (R) 계산&#10;        # 예: 1억 계좌, 2% 리스크 -&gt; 200만원 (엑셀의 '2% 금액')&#10;        max_risk_amount = total_balance * self.risk_per_trade&#10;&#10;        # 2. 주당 리스크 (Stop Loss Gap)&#10;        # 예: 1000원에 사서 920원에 손절 -&gt; 주당 80원 리스크&#10;        risk_per_share = entry_price - stop_loss_price&#10;&#10;        if risk_per_share &lt;= 0:&#10;            log.warning(&quot;Stop loss price is higher than entry price (Long Position). Adjusting Logic.&quot;)&#10;            risk_per_share = entry_price * 0.01  # 방어 코드&#10;&#10;        stop_loss_percent = risk_per_share / entry_price&#10;&#10;        # 3. 리스크 기반 최대 진입 수량 (Position Sizing based on Risk)&#10;        # 공식: 내가 감당할 총 손실 / 주당 손실&#10;        quantity_by_risk = max_risk_amount / risk_per_share&#10;        amount_by_risk = quantity_by_risk * entry_price&#10;&#10;        # 4. 켈리 기반 투자 금액 (Position Sizing based on Kelly)&#10;        amount_by_kelly = total_balance * self.kelly_fraction&#10;&#10;        # 5. 최종 금액 선정 (안전한 쪽 선택) &amp; 시장 팩터 반영&#10;        # 켈리가 너무 공격적이면 리스크 관리 룰을 따르고,&#10;        # 리스크 룰이 너무 크면 켈리(자금성장 최적화)를 따름.&#10;        safe_factor = max(0.0, min(1.0, market_factor if market_factor is not None else 1.0))&#10;        final_amount = min(amount_by_risk, amount_by_kelly) * safe_factor&#10;&#10;        # 최소 주문 금액(예: 업비트 5000원) 처리 등은 봇 로직에서 하겠지만 여기선 0 처리&#10;        final_amount = max(0, final_amount)&#10;        final_quantity = final_amount / entry_price&#10;&#10;        # 로그 출력&#10;        log.info(f&quot;[Money Mgmt] Balance: {total_balance:,.0f} KRW | Market Factor: {market_factor}&quot;)&#10;        log.info(f&quot; -&gt; Risk Limit (R={self.risk_per_trade:.1%}): Max Loss {max_risk_amount:,.0f} KRW&quot;)&#10;        log.info(f&quot; -&gt; Stop Loss: {stop_loss_percent:.2%} (Gap: {risk_per_share:,.0f} KRW)&quot;)&#10;        log.info(f&quot; -&gt; Sizing (Risk): {amount_by_risk:,.0f} KRW vs (Kelly): {amount_by_kelly:,.0f} KRW&quot;)&#10;        log.info(f&quot; -&gt; Final Check: Invest {final_amount:,.0f} KRW (Qty: {final_quantity:.4f})&quot;)&#10;&#10;        return {&#10;            'trade_amount': final_amount,&#10;            'quantity': final_quantity,&#10;            'risk_amount': final_quantity * risk_per_share,  # 실제 예상 손실액&#10;            'stop_loss_pct': stop_loss_percent&#10;        }&#10;" />
              <option name="updatedContent" value="from server.logger import log&#10;&#10;#  Kelly Criterion 기반 자금 관리자&#10;# Kelly Criterion: f* = (p*b - (1-p)) / b&#10;# f* = 최적 베팅 비율&#10;# p = 승률 (0 &lt; p &lt; 1)&#10;# b = 평균 이익 / 평균 손실 (payoff ratio, b &gt; 0)&#10;# 참고: https://en.wikipedia.org/wiki/Kelly_criterion&#10;# 예시: 승률 60%, 손익비 1.5인 전략의 경우&#10;# f* = (0.6*1.5 - 0.4) / 1.5 = 0.4 (즉, 자산의 40%를 투자)&#10;# 단, 실제 투자에서는 변동성을 고려하여 절반 켈리(Half Kelly) 등을 권장합니다.&#10;&#10;class KellyCriterionManager:&#10;&#10;    # 켈리 기준 자금 관리자 초기화&#10;    def __init__(self, win_rate=0.4, payoff_ratio=2.0, fraction=0.5, risk_per_trade=0.02):&#10;&#10;        #:param win_rate: 전략의 승률 (0 &lt; win_rate &lt; 1)&#10;        #:param payoff_ratio: 평균 이익 / 평균 손실 (payoff_ratio &gt; 0)&#10;        #:param fraction: 계산된 켈리 비율에 적용할 비중 (e.g., 0.5 for Half Kelly)&#10;        #:param risk_per_trade: 1회 트레이딩 당 계좌 대비 최대 손실 허용 비율 (기본 2%)&#10;        if not (0 &lt; win_rate &lt; 1):&#10;            raise ValueError(&quot;Win rate must be between 0 and 1.&quot;)&#10;        if payoff_ratio &lt;= 0:&#10;            raise ValueError(&quot;Payoff ratio must be greater than 0.&quot;)&#10;        if not (0 &lt; fraction &lt;= 1):&#10;            raise ValueError(&quot;Kelly fraction must be between 0 and 1.&quot;)&#10;&#10;        # 멤버 변수 설정&#10;        self.win_rate = win_rate&#10;        self.payoff_ratio = payoff_ratio&#10;        self.fraction = fraction&#10;        self.risk_per_trade = risk_per_trade&#10;&#10;        # 켈리 공식: f = (p*b - (1-p)) / b&#10;        # p = win_rate, b = payoff_ratio&#10;        kelly_f = ((self.win_rate * self.payoff_ratio) - (1 - self.win_rate)) / self.payoff_ratio&#10;&#10;        # 음수일 경우 0으로 설정하여 손실 방지&#10;        self.kelly_fraction = max(0, kelly_f) * self.fraction  # 음수일 경우 0으로&#10;&#10;        log.info(&quot;Kelly Criterion Initialized.&quot;)&#10;        log.info(f&quot;  - Win Rate: {self.win_rate:.2%}&quot;)&#10;        log.info(f&quot;  - Payoff Ratio: {self.payoff_ratio:.2f}&quot;)&#10;        log.info(f&quot;  - Applied Kelly Fraction (f): {self.kelly_fraction:.2%}&quot;)&#10;        log.info(f&quot;  - Risk per Trade: {self.risk_per_trade:.2%}&quot;)&#10;&#10;    # 총 자산 대비 투자 금액 계산&#10;    # 총 자산의 일정 비율을 켈리 공식에 따라 투자 금액으로 산정&#10;    # e.g., 총 자산 1,000,000 KRW, 켈리 비율 20% -&gt; 200,000 KRW 투자&#10;    # 반환값: 투자할 금액 (float)&#10;    #:param total_balance: 총 자산 (e.g., KRW 잔고)&#10;    #:return: (float) 투자할 금액&#10;    # 계산된 투자 금액 반환&#10;    # 총 자산이 0이거나 켈리 비율이 0인 경우 0 반환&#10;    # 로그에 계산된 투자 금액 출력&#10;    # e.g., &quot;Calculated trade amount: 200,000 KRW (Balance: 1,000,000 * Kelly: 20.00%)&quot;&#10;    # 반환값: 투자할 금액 (float)&#10;    def calculate_trade_amount(self, total_balance):&#10;        if self.kelly_fraction &lt;= 0:&#10;            log.warning(&quot;Kelly fraction is 0 or negative. No investment is advised.&quot;)&#10;            return 0&#10;&#10;        # 총 자산이 0인 경우 0 반환&#10;        if total_balance &lt;= 0:&#10;            log.warning(&quot;Total balance is 0 or negative. No investment can be made.&quot;)&#10;            return 0&#10;&#10;        trade_amount = total_balance * self.kelly_fraction&#10;        log.info(f&quot;Calculated trade amount: {trade_amount:,.0f} KRW (Balance: {total_balance:,.0f} * Kelly: {self.kelly_fraction:.2%})&quot;)&#10;        return trade_amount&#10;&#10;    # 매수 진입 시 적절한 투자 금액과 수량 계산&#10;    # 리스크 관리와 켈리 기준을 모두 고려하여 최종 투자 금액 산정&#10;    #   [로직 설명]&#10;    #    1. 리스크 기반 계산 (Survival): 손절 나갔을 때 계좌의 R(2%)만 잃도록 수량 설정.&#10;    #       - 공식: 허용 손실금액 / (매수가 - 손절가)&#10;    #    2. 켈리 기반 계산 (Growth): 켈리 비중만큼 투자.&#10;    #    3. 최종 결정: 두 값 중 더 '안전한(작은)' 값을 선택하고, 시장 상황(market_factor)을 곱함.&#10;    #&#10;    #    # input&#10;    #    :param total_balance: 현재 계좌 총액 (KRW)&#10;    #    :param entry_price: 진입 예정 가격&#10;    #    :param stop_loss_price: 손절 예정 가격&#10;    #    :param market_factor: 시장 상황 점수 (0.0 ~ 1.0, 1.0=상승장 풀배팅, 0.5=보수적, 0.0=매매금지)&#10;&#10;    #    # return: {&#10;    #        'trade_amount': 투자할 총 금액 (KRW),&#10;    #        'quantity': 구매할 코인 수량,&#10;    #        'risk_amount': 예상 손실 금액,&#10;    #        'reason': 계산 근거&#10;    #    }&#10;    def get_position_size(self, total_balance, entry_price, stop_loss_price, market_factor=1.0):&#10;        if total_balance &lt;= 0 or entry_price &lt;= 0:&#10;            return {'trade_amount': 0, 'quantity': 0, 'reason': &quot;Invalid Balance or Price&quot;}&#10;&#10;        # 1. 1회 최대 허용 손실금액 (R) 계산&#10;        # 예: 1억 계좌, 2% 리스크 -&gt; 200만원 (엑셀의 '2% 금액')&#10;        max_risk_amount = total_balance * self.risk_per_trade&#10;&#10;        # 2. 주당 리스크 (Stop Loss Gap)&#10;        # 예: 1000원에 사서 920원에 손절 -&gt; 주당 80원 리스크&#10;        risk_per_share = entry_price - stop_loss_price&#10;&#10;        if risk_per_share &lt;= 0:&#10;            log.warning(&quot;Stop loss price is higher than entry price (Long Position). Adjusting Logic.&quot;)&#10;            risk_per_share = entry_price * 0.01  # 방어 코드&#10;&#10;        stop_loss_percent = risk_per_share / entry_price&#10;&#10;        # 3. 리스크 기반 최대 진입 수량 (Position Sizing based on Risk)&#10;        # 공식: 내가 감당할 총 손실 / 주당 손실&#10;        quantity_by_risk = max_risk_amount / risk_per_share&#10;        amount_by_risk = quantity_by_risk * entry_price&#10;&#10;        # 4. 켈리 기반 투자 금액 (Position Sizing based on Kelly)&#10;        amount_by_kelly = total_balance * self.kelly_fraction&#10;&#10;        # 5. 최종 금액 선정 (안전한 쪽 선택) &amp; 시장 팩터 반영&#10;        # 켈리가 너무 공격적이면 리스크 관리 룰을 따르고,&#10;        # 리스크 룰이 너무 크면 켈리(자금성장 최적화)를 따름.&#10;        safe_factor = max(0.0, min(1.0, market_factor if market_factor is not None else 1.0))&#10;        final_amount = min(amount_by_risk, amount_by_kelly) * safe_factor&#10;&#10;        # 최소 주문 금액(예: 업비트 5000원) 처리 등은 봇 로직에서 하겠지만 여기선 0 처리&#10;        final_amount = max(0, final_amount)&#10;        final_quantity = final_amount / entry_price&#10;&#10;        # 로그 출력&#10;        log.info(f&quot;[Money Mgmt] Balance: {total_balance:,.0f} KRW | Market Factor: {market_factor}&quot;)&#10;        log.info(f&quot; -&gt; Risk Limit (R={self.risk_per_trade:.1%}): Max Loss {max_risk_amount:,.0f} KRW&quot;)&#10;        log.info(f&quot; -&gt; Stop Loss: {stop_loss_percent:.2%} (Gap: {risk_per_share:,.0f} KRW)&quot;)&#10;        log.info(f&quot; -&gt; Sizing (Risk): {amount_by_risk:,.0f} KRW vs (Kelly): {amount_by_kelly:,.0f} KRW&quot;)&#10;        log.info(f&quot; -&gt; Final Check: Invest {final_amount:,.0f} KRW (Qty: {final_quantity:.4f})&quot;)&#10;&#10;        return {&#10;            'trade_amount': final_amount,&#10;            'quantity': final_quantity,&#10;            'risk_amount': final_quantity * risk_per_share,  # 실제 예상 손실액&#10;            'stop_loss_pct': stop_loss_percent&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/order_executor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/order_executor.py" />
              <option name="originalContent" value="from dataclasses import dataclass, field&#10;import math&#10;import queue&#10;import threading&#10;import time&#10;from typing import Any, Callable, Dict, Optional&#10;&#10;import server.config as config&#10;from server.history import order_history_store&#10;from server.logger import log&#10;from server.upbit_api import UpbitAPI&#10;&#10;&#10;@dataclass&#10;class OrderRequest:&#10;    action: str&#10;    symbol: str&#10;    amount_krw: float = 0.0&#10;    volume: float = 0.0&#10;    reason: str = &quot;&quot;&#10;    callback: Optional[Callable[[bool, Dict[str, Any]], None]] = None&#10;    metadata: Dict[str, Any] = field(default_factory=dict)&#10;    trade_amount: Optional[float] = None&#10;    target_quantity: Optional[float] = None&#10;    entry_price: Optional[float] = None&#10;    stop_loss_price: Optional[float] = None&#10;    take_profit_price: Optional[float] = None&#10;    market_factor: Optional[float] = None&#10;    risk_amount: Optional[float] = None&#10;&#10;&#10;class OrderExecutor:&#10;    def __init__(self, api: UpbitAPI, min_order_amount: float = config.MIN_ORDER_AMOUNT):&#10;        self.api = api&#10;        self.min_order_amount = float(min_order_amount)&#10;        self._queue: queue.Queue[Optional[OrderRequest]] = queue.Queue()&#10;        self._stop_event = threading.Event()&#10;        self._thread = threading.Thread(target=self._run, daemon=True)&#10;        self._started = False&#10;&#10;    def start(self) -&gt; None:&#10;        if self._started:&#10;            return&#10;        self._started = True&#10;        self._thread.start()&#10;        log.info(&quot;OrderExecutor thread started.&quot;)&#10;&#10;    def stop(self) -&gt; None:&#10;        self._stop_event.set()&#10;        self._queue.put(None)&#10;        if self._thread.is_alive():&#10;            self._thread.join(timeout=3)&#10;        log.info(&quot;OrderExecutor thread stopped.&quot;)&#10;&#10;    def submit(self, request: OrderRequest) -&gt; None:&#10;        if request.action not in (&quot;BUY&quot;, &quot;SELL&quot;):&#10;            log.warning(f&quot;Unsupported order action: {request.action}&quot;)&#10;            return&#10;        self._queue.put(request)&#10;        log.info(f&quot;OrderRequest queued: {request.action} {request.symbol}&quot;)&#10;&#10;    def _run(self) -&gt; None:&#10;        while not self._stop_event.is_set():&#10;            try:&#10;                request = self._queue.get(timeout=1)&#10;            except queue.Empty:&#10;                continue&#10;            if request is None:&#10;                break&#10;            result = self._process_request(request)&#10;            self._queue.task_done()&#10;            if request.callback:&#10;                try:&#10;                    request.callback(result.get(&quot;success&quot;, False), result)&#10;                except Exception as exc:&#10;                    log.warning(f&quot;Order callback failed: {exc}&quot;)&#10;&#10;    def _process_request(self, request: OrderRequest) -&gt; Dict[str, Any]:&#10;        entry: Dict[str, Any] = {&#10;            &quot;ts&quot;: time.time(),&#10;            &quot;action&quot;: request.action,&#10;            &quot;symbol&quot;: request.symbol,&#10;            &quot;amount_krw&quot;: request.amount_krw,&#10;            &quot;volume&quot;: request.volume,&#10;            &quot;reason&quot;: request.reason,&#10;            &quot;metadata&quot;: request.metadata,&#10;            &quot;trade_amount&quot;: request.trade_amount,&#10;            &quot;target_quantity&quot;: request.target_quantity,&#10;            &quot;entry_price&quot;: request.entry_price,&#10;            &quot;stop_loss_price&quot;: request.stop_loss_price,&#10;            &quot;take_profit_price&quot;: request.take_profit_price,&#10;            &quot;market_factor&quot;: request.market_factor,&#10;            &quot;risk_amount&quot;: request.risk_amount,&#10;        }&#10;&#10;        if request.action == &quot;BUY&quot;:&#10;            payload = self._handle_buy(request)&#10;        else:&#10;            payload = self._handle_sell(request)&#10;&#10;        entry[&quot;success&quot;] = payload.get(&quot;success&quot;, False)&#10;        entry[&quot;details&quot;] = payload.get(&quot;message&quot;)&#10;        entry[&quot;response&quot;] = payload.get(&quot;response&quot;)&#10;        order_history_store.record(entry)&#10;        return payload&#10;&#10;    def _handle_buy(self, request: OrderRequest) -&gt; Dict[str, Any]:&#10;        if request.amount_krw &lt; self.min_order_amount:&#10;            msg = f&quot;주문금액({request.amount_krw:.0f} KRW)이 최소 주문금액({self.min_order_amount:.0f} KRW)보다 작습니다.&quot;&#10;            log.warning(msg)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;        available_krw = self.api.get_balance(&quot;KRW&quot;) or 0.0&#10;        if available_krw &lt; request.amount_krw:&#10;            msg = f&quot;원화 잔액 부족. 필요: {request.amount_krw:.0f}, 현재: {available_krw:.0f}&quot;&#10;            log.warning(msg)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;        if request.entry_price:&#10;            log.info(&#10;                &quot;[Bracket] entry=%.0f stop=%.0f take=%.0f qty=%.6f risk=%.0f factor=%.2f&quot;&#10;                % (&#10;                    request.entry_price,&#10;                    request.stop_loss_price or 0,&#10;                    request.take_profit_price or 0,&#10;                    request.target_quantity or 0,&#10;                    request.risk_amount or 0,&#10;                    request.market_factor or 0,&#10;                )&#10;            )&#10;&#10;        try:&#10;            response = self.api.place_order(request.symbol, &quot;bid&quot;, ord_type=&quot;price&quot;, price=request.amount_krw)&#10;            log.info(f&quot;BUY order executed: {request.symbol} {request.amount_krw:.0f} KRW&quot;)&#10;            return {&quot;success&quot;: True, &quot;message&quot;: &quot;BUY order executed&quot;, &quot;response&quot;: response}&#10;        except Exception as exc:&#10;            msg = f&quot;BUY 주문 실패: {exc}&quot;&#10;            log.error(msg, exc_info=True)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;    def _handle_sell(self, request: OrderRequest) -&gt; Dict[str, Any]:&#10;        coin_symbol = request.symbol.split(&quot;-&quot;)[-1]&#10;        volume = request.volume&#10;        if not volume or math.isclose(volume, 0.0):&#10;            volume = self.api.get_balance(coin_symbol)&#10;        if not volume or math.isclose(volume, 0.0):&#10;            msg = f&quot;{coin_symbol} 잔고가 없습니다.&quot;&#10;            log.warning(msg)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;        try:&#10;            response = self.api.place_order(request.symbol, &quot;ask&quot;, ord_type=&quot;market&quot;, volume=volume)&#10;            log.info(f&quot;SELL order executed: {request.symbol} {volume:.8f} units&quot;)&#10;            return {&quot;success&quot;: True, &quot;message&quot;: &quot;SELL order executed&quot;, &quot;response&quot;: response}&#10;        except Exception as exc:&#10;            msg = f&quot;SELL 주문 실패: {exc}&quot;&#10;            log.error(msg, exc_info=True)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;" />
              <option name="updatedContent" value="from dataclasses import dataclass, field&#10;import math&#10;import queue&#10;import threading&#10;import time&#10;from typing import Any, Callable, Dict, Optional&#10;&#10;import server.config as config&#10;from server.history import order_history_store&#10;from server.logger import log&#10;from server.upbit_api import UpbitAPI&#10;&#10;&#10;@dataclass&#10;class OrderRequest:&#10;    action: str&#10;    symbol: str&#10;    amount_krw: float = 0.0&#10;    volume: float = 0.0&#10;    reason: str = &quot;&quot;&#10;    callback: Optional[Callable[[bool, Dict[str, Any]], None]] = None&#10;    metadata: Dict[str, Any] = field(default_factory=dict)&#10;    trade_amount: Optional[float] = None&#10;    target_quantity: Optional[float] = None&#10;    entry_price: Optional[float] = None&#10;    stop_loss_price: Optional[float] = None&#10;    take_profit_price: Optional[float] = None&#10;    market_factor: Optional[float] = None&#10;    risk_amount: Optional[float] = None&#10;&#10;&#10;class OrderExecutor:&#10;    def __init__(self, api: UpbitAPI, min_order_amount: float = config.MIN_ORDER_AMOUNT):&#10;        self.api = api&#10;        self.min_order_amount = float(min_order_amount)&#10;        self._queue: queue.Queue[Optional[OrderRequest]] = queue.Queue()&#10;        self._stop_event = threading.Event()&#10;        self._thread = threading.Thread(target=self._run, daemon=True)&#10;        self._started = False&#10;&#10;    def start(self) -&gt; None:&#10;        if self._started:&#10;            return&#10;        self._started = True&#10;        self._thread.start()&#10;        log.info(&quot;OrderExecutor thread started.&quot;)&#10;&#10;    def stop(self) -&gt; None:&#10;        self._stop_event.set()&#10;        self._queue.put(None)&#10;        if self._thread.is_alive():&#10;            self._thread.join(timeout=3)&#10;        log.info(&quot;OrderExecutor thread stopped.&quot;)&#10;&#10;    def submit(self, request: OrderRequest) -&gt; None:&#10;        if request.action not in (&quot;BUY&quot;, &quot;SELL&quot;):&#10;            log.warning(f&quot;Unsupported order action: {request.action}&quot;)&#10;            return&#10;        self._queue.put(request)&#10;        log.info(f&quot;OrderRequest queued: {request.action} {request.symbol}&quot;)&#10;&#10;    def _run(self) -&gt; None:&#10;        while not self._stop_event.is_set():&#10;            try:&#10;                request = self._queue.get(timeout=1)&#10;            except queue.Empty:&#10;                continue&#10;            if request is None:&#10;                break&#10;            result = self._process_request(request)&#10;            self._queue.task_done()&#10;            if request.callback:&#10;                try:&#10;                    request.callback(result.get(&quot;success&quot;, False), result)&#10;                except Exception as exc:&#10;                    log.warning(f&quot;Order callback failed: {exc}&quot;)&#10;&#10;    def _process_request(self, request: OrderRequest) -&gt; Dict[str, Any]:&#10;        entry: Dict[str, Any] = {&#10;            &quot;ts&quot;: time.time(),&#10;            &quot;action&quot;: request.action,&#10;            &quot;symbol&quot;: request.symbol,&#10;            &quot;amount_krw&quot;: request.amount_krw,&#10;            &quot;volume&quot;: request.volume,&#10;            &quot;reason&quot;: request.reason,&#10;            &quot;metadata&quot;: request.metadata,&#10;            &quot;trade_amount&quot;: request.trade_amount,&#10;            &quot;target_quantity&quot;: request.target_quantity,&#10;            &quot;entry_price&quot;: request.entry_price,&#10;            &quot;stop_loss_price&quot;: request.stop_loss_price,&#10;            &quot;take_profit_price&quot;: request.take_profit_price,&#10;            &quot;market_factor&quot;: request.market_factor,&#10;            &quot;risk_amount&quot;: request.risk_amount,&#10;        }&#10;&#10;        if request.action == &quot;BUY&quot;:&#10;            payload = self._handle_buy(request)&#10;        else:&#10;            payload = self._handle_sell(request)&#10;&#10;        entry[&quot;success&quot;] = payload.get(&quot;success&quot;, False)&#10;        entry[&quot;details&quot;] = payload.get(&quot;message&quot;)&#10;        entry[&quot;response&quot;] = payload.get(&quot;response&quot;)&#10;        order_history_store.record(entry)&#10;        return payload&#10;&#10;    def _handle_buy(self, request: OrderRequest) -&gt; Dict[str, Any]:&#10;        if request.amount_krw &lt; self.min_order_amount:&#10;            msg = f&quot;주문금액({request.amount_krw:.0f} KRW)이 최소 주문금액({self.min_order_amount:.0f} KRW)보다 작습니다.&quot;&#10;            log.warning(msg)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;        available_krw = self.api.get_balance(&quot;KRW&quot;) or 0.0&#10;        if available_krw &lt; request.amount_krw:&#10;            msg = f&quot;원화 잔액 부족. 필요: {request.amount_krw:.0f}, 현재: {available_krw:.0f}&quot;&#10;            log.warning(msg)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;        if request.entry_price:&#10;            log.info(&#10;                &quot;[Bracket] entry=%.0f stop=%.0f take=%.0f qty=%.6f risk=%.0f factor=%.2f&quot;&#10;                % (&#10;                    request.entry_price,&#10;                    request.stop_loss_price or 0,&#10;                    request.take_profit_price or 0,&#10;                    request.target_quantity or 0,&#10;                    request.risk_amount or 0,&#10;                    request.market_factor or 0,&#10;                )&#10;            )&#10;&#10;        try:&#10;            response = self.api.place_order(request.symbol, &quot;bid&quot;, ord_type=&quot;price&quot;, price=request.amount_krw)&#10;            log.info(f&quot;BUY order executed: {request.symbol} {request.amount_krw:.0f} KRW&quot;)&#10;            return {&quot;success&quot;: True, &quot;message&quot;: &quot;BUY order executed&quot;, &quot;response&quot;: response}&#10;        except Exception as exc:&#10;            msg = f&quot;BUY 주문 실패: {exc}&quot;&#10;            log.error(msg, exc_info=True)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;    def _handle_sell(self, request: OrderRequest) -&gt; Dict[str, Any]:&#10;        coin_symbol = request.symbol.split(&quot;-&quot;)[-1]&#10;        volume = request.volume&#10;        if not volume or math.isclose(volume, 0.0):&#10;            volume = self.api.get_balance(coin_symbol)&#10;        if not volume or math.isclose(volume, 0.0):&#10;            msg = f&quot;{coin_symbol} 잔고가 없습니다.&quot;&#10;            log.warning(msg)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}&#10;&#10;        try:&#10;            response = self.api.place_order(request.symbol, &quot;ask&quot;, ord_type=&quot;market&quot;, volume=volume)&#10;            log.info(f&quot;SELL order executed: {request.symbol} {volume:.8f} units&quot;)&#10;            return {&quot;success&quot;: True, &quot;message&quot;: &quot;SELL order executed&quot;, &quot;response&quot;: response}&#10;        except Exception as exc:&#10;            msg = f&quot;SELL 주문 실패: {exc}&quot;&#10;            log.error(msg, exc_info=True)&#10;            return {&quot;success&quot;: False, &quot;message&quot;: msg}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/upbit_api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/upbit_api.py" />
              <option name="originalContent" value="import jwt&#10;import uuid&#10;import hashlib&#10;from urllib.parse import urlencode&#10;import requests&#10;import time&#10;from typing import Optional&#10;from server.logger import log&#10;try:&#10;    import pyupbit&#10;    _HAS_PYUPBIT = True&#10;except Exception:&#10;    pyupbit = None&#10;    _HAS_PYUPBIT = False&#10;&#10;# pandas and pytz may be available via pyupbit dependencies; import safely&#10;try:&#10;    import pandas as pd&#10;    import pytz&#10;    _HAS_PANDAS = True&#10;except Exception:&#10;    pd = None&#10;    pytz = None&#10;    _HAS_PANDAS = False&#10;&#10;&#10;class UpbitAPI:&#10;    &quot;&quot;&quot;&#10;    업비트 API 연동 클래스&#10;    JWT 인증 및 주요 API 호출 기능&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, access_key=None, secret_key=None):&#10;        self.access_key = access_key&#10;        self.secret_key = secret_key&#10;        self.server_url = &quot;https://api.upbit.com&quot;&#10;&#10;    def _generate_auth_token(self, query_params=None):&#10;        &quot;&quot;&quot;&#10;        API 요청을 위한 JWT 인증 토큰 생성 (키가 없으면 None 반환)&#10;        &quot;&quot;&quot;&#10;        if not self.access_key or not self.secret_key:&#10;            return None&#10;&#10;        payload = {&#10;            'access_key': self.access_key,&#10;            'nonce': str(uuid.uuid4()),&#10;        }&#10;&#10;        # 쿼리 파라미터가 있는 경우, 페이로드에 해시값 추가&#10;        if query_params:&#10;            query_string = urlencode(query_params, doseq=True).encode(&quot;utf-8&quot;)&#10;            m = hashlib.sha512()&#10;            m.update(query_string)&#10;            query_hash = m.hexdigest()&#10;            payload['query_hash'] = query_hash&#10;            payload['query_hash_alg'] = 'SHA512'&#10;&#10;        # JWT 생성&#10;        jwt_token = jwt.encode(payload, self.secret_key, algorithm=&quot;HS256&quot;)&#10;        authorize_token = f&quot;Bearer {jwt_token}&quot;&#10;        return authorize_token&#10;&#10;    def _send_request(self, method, endpoint, params=None, data=None, headers=None):&#10;        &quot;&quot;&quot;&#10;        업비트 API에 요청 전송&#10;        &quot;&quot;&quot;&#10;        url = self.server_url + endpoint&#10;&#10;        # 바디 및 쿼리 설정&#10;        query = params if method in ['GET', 'DELETE'] else None&#10;        body = data if method in ['POST', 'PUT'] else None&#10;&#10;        auth_token = self._generate_auth_token(query or body)&#10;&#10;        if headers is None:&#10;            headers = {}&#10;        if auth_token:&#10;            headers['Authorization'] = auth_token&#10;&#10;        # Implement retry on 429 and some transient network errors&#10;        max_retries = 5&#10;        backoff_base = 0.5&#10;        last_exc = None&#10;        for attempt in range(1, max_retries + 1):&#10;            try:&#10;                if method == 'GET':&#10;                    response = requests.get(url, headers=headers, params=params, timeout=10)&#10;                elif method == 'POST':&#10;                    headers['Content-Type'] = 'application/json'&#10;                    response = requests.post(url, headers=headers, json=data, timeout=10)&#10;                elif method == 'DELETE':&#10;                    response = requests.delete(url, headers=headers, params=params, timeout=10)&#10;                else:&#10;                    raise ValueError(f&quot;Unsupported HTTP method: {method}&quot;)&#10;&#10;                # If rate-limited, backoff and retry&#10;                if response.status_code == 429:&#10;                    wait = backoff_base * (2 ** (attempt - 1))&#10;                    jitter = random.uniform(0, 0.5)&#10;                    total_wait = wait + jitter&#10;                    log.warning(f'Upbit API rate limit hit (429). retry {attempt}/{max_retries} after {total_wait:.2f}s')&#10;                    time.sleep(total_wait)&#10;                    last_exc = requests.exceptions.HTTPError('429 Too Many Requests')&#10;                    continue&#10;&#10;                response.raise_for_status()&#10;                # small pause to avoid tight loops&#10;                time.sleep(0.12)&#10;                return response.json()&#10;            except requests.exceptions.HTTPError as http_err:&#10;                last_exc = http_err&#10;                status = getattr(getattr(http_err, 'response', None), 'status_code', None)&#10;                # if not rate-limited, don't retry further&#10;                if status != 429:&#10;                    txt = getattr(http_err, 'response', None)&#10;                    extra = ''&#10;                    try:&#10;                        if txt is not None:&#10;                            extra = f&quot; - {txt.text}&quot;&#10;                    except Exception:&#10;                        extra = ''&#10;                    log.error(f&quot;HTTP error occurred: {http_err}{extra}&quot;)&#10;                    break&#10;                # else loop will retry&#10;            except requests.exceptions.RequestException as req_e:&#10;                last_exc = req_e&#10;                # transient network error -&gt; backoff and retry&#10;                wait = backoff_base * (2 ** (attempt - 1)) + random.uniform(0, 0.5)&#10;                log.warning(f'Network error during Upbit API call: {req_e}. retry {attempt}/{max_retries} after {wait:.2f}s')&#10;                time.sleep(wait)&#10;                continue&#10;            except Exception as e:&#10;                last_exc = e&#10;                log.error(f&quot;An error occurred: {e}&quot;)&#10;                break&#10;&#10;        # Retries exhausted or non-retryable error&#10;        return None&#10;&#10;    # --- Public API Methods ---&#10;&#10;    def get_balances(self):&#10;        &quot;&quot;&quot;&#10;        전체 계좌 잔고 조회 (인증 필요)&#10;        &quot;&quot;&quot;&#10;        endpoint = &quot;/v1/accounts&quot;&#10;        return self._send_request('GET', endpoint)&#10;&#10;    def get_balance(self, ticker=&quot;KRW&quot;):&#10;        &quot;&quot;&quot;&#10;        특정 화폐/코인의 잔고 조회&#10;        &quot;&quot;&quot;&#10;        balances = self.get_balances()&#10;        if balances:&#10;            for b in balances:&#10;                if b.get('currency') == ticker:&#10;                    try:&#10;                        return float(b.get('balance', 0))&#10;                    except Exception:&#10;                        return 0.0&#10;        return 0.0&#10;&#10;    def get_klines(self, market, timeframe=&quot;minute1&quot;, count=200):&#10;        &quot;&quot;&quot;&#10;        캔들(시세) 조회: timeframe 문자열을 Upbit 엔드포인트로 매핑하여 호출합니다.&#10;        지원 예: 'minute1', 'minute3', 'minute5', 'minute15', 'minute60', 'day'&#10;        &quot;&quot;&quot;&#10;        # 매핑&#10;        tf = timeframe.lower()&#10;        if tf.startswith('minute'):&#10;            # minuteN -&gt; /v1/candles/minutes/N&#10;            try:&#10;                n = int(tf.replace('minute', ''))&#10;                endpoint = f&quot;/v1/candles/minutes/{n}&quot;&#10;            except Exception:&#10;                endpoint = &quot;/v1/candles/minutes/1&quot;&#10;        elif tf in ('day', 'days'):&#10;            endpoint = &quot;/v1/candles/days&quot;&#10;        elif tf in ('week', 'weeks'):&#10;            endpoint = &quot;/v1/candles/weeks&quot;&#10;        elif tf in ('month', 'months'):&#10;            endpoint = &quot;/v1/candles/months&quot;&#10;        else:&#10;            # fallback&#10;            endpoint = f&quot;/v1/candles/{tf}&quot;&#10;&#10;        # Try pyupbit if available for convenience and reliability&#10;        tf = timeframe.lower()&#10;        if _HAS_PYUPBIT:&#10;            try:&#10;                # pyupbit uses periods like &quot;minute&quot; string: use the numeric mapping&#10;                if tf.startswith('minute'):&#10;                    n = int(tf.replace('minute',''))&#10;                    interval_str = f&quot;minute{n}&quot;&#10;                    df = pyupbit.get_ohlcv(market, interval=interval_str, count=count)&#10;                elif tf in ('day','days'):&#10;                    df = pyupbit.get_ohlcv(market, interval='day', count=count)&#10;                elif tf in ('week','weeks'):&#10;                    df = pyupbit.get_ohlcv(market, interval='week', count=count)&#10;                elif tf in ('month','months'):&#10;                    df = pyupbit.get_ohlcv(market, interval='month', count=count)&#10;                else:&#10;                    # fallback to requests-based endpoint&#10;                    df = None&#10;                if df is not None:&#10;                    records = []&#10;                    # convert index to KST-aware ISO strings when possible&#10;                    for idx, row in df.iterrows():&#10;                        ts_str = None&#10;                        try:&#10;                            if _HAS_PANDAS and isinstance(idx, pd.Timestamp):&#10;                                # if naive, assume UTC and localize; then convert to Asia/Seoul&#10;                                if idx.tzinfo is None:&#10;                                    idx_utc = idx.tz_localize('UTC')&#10;                                else:&#10;                                    idx_utc = idx.tz_convert('UTC') if idx.tzinfo else idx.tz_localize('UTC')&#10;                                if pytz:&#10;                                    kst = pytz.timezone('Asia/Seoul')&#10;                                    idx_kst = idx_utc.tz_convert(kst)&#10;                                    ts_str = idx_kst.isoformat()&#10;                                else:&#10;                                    ts_str = idx_utc.isoformat()&#10;                            else:&#10;                                # fallback: str(idx)&#10;                                ts_str = str(idx)&#10;                        except Exception:&#10;                            ts_str = str(idx)&#10;                        records.append({'candle_date_time_kst': ts_str, 'opening_price': row['open'], 'high_price': row['high'], 'low_price': row['low'], 'trade_price': row['close'], 'candle_acc_trade_volume': row['volume']})&#10;                    return records&#10;            except Exception as e:&#10;                log.warning(f'pyupbit get_klines failed, falling back to HTTP: {e}')&#10;&#10;        params = {'market': market, 'count': count}&#10;        return self._send_request('GET', endpoint, params=params)&#10;&#10;    def get_orderbook(self, markets):&#10;        if isinstance(markets, (list, tuple)):&#10;            market_param = ','.join(markets)&#10;        else:&#10;            market_param = markets&#10;        data = self._send_request('GET', '/v1/orderbook', params={'markets': market_param})&#10;        if data and isinstance(data, list):&#10;            return data&#10;        return None&#10;&#10;    def place_order(self, market: str, side: str, ord_type: str = 'price', price: Optional[float] = None, volume: Optional[float] = None):&#10;        payload = {&#10;            'market': market,&#10;            'side': side,&#10;            'ord_type': ord_type,&#10;        }&#10;        if ord_type == 'price':&#10;            if price is None:&#10;                raise ValueError('price is required for ord_type=&quot;price&quot;')&#10;            payload['price'] = price&#10;        elif ord_type == 'market':&#10;            if volume is None:&#10;                raise ValueError(&quot;volume is required for market sell (ord_type='market')&quot;)&#10;            payload[&quot;volume&quot;] = str(volume)&#10;        elif ord_type == 'limit':&#10;            if price is None or volume is None:&#10;                raise ValueError('price and volume are required for ord_type=&quot;limit&quot;')&#10;            payload['price'] = price&#10;            payload['volume'] = volume&#10;        else:&#10;            raise ValueError(f&quot;Unsupported ord_type: {ord_type}&quot;)&#10;&#10;        return self._send_request('POST', '/v1/orders', data=payload)&#10;" />
              <option name="updatedContent" value="import jwt&#10;import uuid&#10;import hashlib&#10;from urllib.parse import urlencode&#10;import requests&#10;import time&#10;from typing import Optional&#10;from server.logger import log&#10;try:&#10;    import pyupbit&#10;    _HAS_PYUPBIT = True&#10;except Exception:&#10;    pyupbit = None&#10;    _HAS_PYUPBIT = False&#10;&#10;# pandas and pytz may be available via pyupbit dependencies; import safely&#10;try:&#10;    import pandas as pd&#10;    import pytz&#10;    _HAS_PANDAS = True&#10;except Exception:&#10;    pd = None&#10;    pytz = None&#10;    _HAS_PANDAS = False&#10;&#10;&#10;class UpbitAPI:&#10;    &quot;&quot;&quot;&#10;    업비트 API 연동 클래스&#10;    JWT 인증 및 주요 API 호출 기능&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, access_key=None, secret_key=None):&#10;        self.access_key = access_key&#10;        self.secret_key = secret_key&#10;        self.server_url = &quot;https://api.upbit.com&quot;&#10;&#10;    def _generate_auth_token(self, query_params=None):&#10;        &quot;&quot;&quot;&#10;        API 요청을 위한 JWT 인증 토큰 생성 (키가 없으면 None 반환)&#10;        &quot;&quot;&quot;&#10;        if not self.access_key or not self.secret_key:&#10;            return None&#10;&#10;        payload = {&#10;            'access_key': self.access_key,&#10;            'nonce': str(uuid.uuid4()),&#10;        }&#10;&#10;        # 쿼리 파라미터가 있는 경우, 페이로드에 해시값 추가&#10;        if query_params:&#10;            query_string = urlencode(query_params, doseq=True).encode(&quot;utf-8&quot;)&#10;            m = hashlib.sha512()&#10;            m.update(query_string)&#10;            query_hash = m.hexdigest()&#10;            payload['query_hash'] = query_hash&#10;            payload['query_hash_alg'] = 'SHA512'&#10;&#10;        # JWT 생성&#10;        jwt_token = jwt.encode(payload, self.secret_key, algorithm=&quot;HS256&quot;)&#10;        authorize_token = f&quot;Bearer {jwt_token}&quot;&#10;        return authorize_token&#10;&#10;    def _send_request(self, method, endpoint, params=None, data=None, headers=None):&#10;        &quot;&quot;&quot;&#10;        업비트 API에 요청 전송&#10;        &quot;&quot;&quot;&#10;        url = self.server_url + endpoint&#10;&#10;        # 바디 및 쿼리 설정&#10;        query = params if method in ['GET', 'DELETE'] else None&#10;        body = data if method in ['POST', 'PUT'] else None&#10;&#10;        auth_token = self._generate_auth_token(query or body)&#10;&#10;        if headers is None:&#10;            headers = {}&#10;        if auth_token:&#10;            headers['Authorization'] = auth_token&#10;&#10;        # Implement retry on 429 and some transient network errors&#10;        max_retries = 5&#10;        backoff_base = 0.5&#10;        last_exc = None&#10;        for attempt in range(1, max_retries + 1):&#10;            try:&#10;                if method == 'GET':&#10;                    response = requests.get(url, headers=headers, params=params, timeout=10)&#10;                elif method == 'POST':&#10;                    headers['Content-Type'] = 'application/json'&#10;                    response = requests.post(url, headers=headers, json=data, timeout=10)&#10;                elif method == 'DELETE':&#10;                    response = requests.delete(url, headers=headers, params=params, timeout=10)&#10;                else:&#10;                    raise ValueError(f&quot;Unsupported HTTP method: {method}&quot;)&#10;&#10;                # If rate-limited, backoff and retry&#10;                if response.status_code == 429:&#10;                    wait = backoff_base * (2 ** (attempt - 1))&#10;                    jitter = random.uniform(0, 0.5)&#10;                    total_wait = wait + jitter&#10;                    log.warning(f'Upbit API rate limit hit (429). retry {attempt}/{max_retries} after {total_wait:.2f}s')&#10;                    time.sleep(total_wait)&#10;                    last_exc = requests.exceptions.HTTPError('429 Too Many Requests')&#10;                    continue&#10;&#10;                response.raise_for_status()&#10;                # small pause to avoid tight loops&#10;                time.sleep(0.12)&#10;                return response.json()&#10;            except requests.exceptions.HTTPError as http_err:&#10;                last_exc = http_err&#10;                status = getattr(getattr(http_err, 'response', None), 'status_code', None)&#10;                # if not rate-limited, don't retry further&#10;                if status != 429:&#10;                    txt = getattr(http_err, 'response', None)&#10;                    extra = ''&#10;                    try:&#10;                        if txt is not None:&#10;                            extra = f&quot; - {txt.text}&quot;&#10;                    except Exception:&#10;                        extra = ''&#10;                    log.error(f&quot;HTTP error occurred: {http_err}{extra}&quot;)&#10;                    break&#10;                # else loop will retry&#10;            except requests.exceptions.RequestException as req_e:&#10;                last_exc = req_e&#10;                # transient network error -&gt; backoff and retry&#10;                wait = backoff_base * (2 ** (attempt - 1)) + random.uniform(0, 0.5)&#10;                log.warning(f'Network error during Upbit API call: {req_e}. retry {attempt}/{max_retries} after {wait:.2f}s')&#10;                time.sleep(wait)&#10;                continue&#10;            except Exception as e:&#10;                last_exc = e&#10;                log.error(f&quot;An error occurred: {e}&quot;)&#10;                break&#10;&#10;        # Retries exhausted or non-retryable error&#10;        return None&#10;&#10;    # --- Public API Methods ---&#10;&#10;    def get_balances(self):&#10;        &quot;&quot;&quot;&#10;        전체 계좌 잔고 조회 (인증 필요)&#10;        &quot;&quot;&quot;&#10;        endpoint = &quot;/v1/accounts&quot;&#10;        return self._send_request('GET', endpoint)&#10;&#10;    def get_balance(self, ticker=&quot;KRW&quot;):&#10;        &quot;&quot;&quot;&#10;        특정 화폐/코인의 잔고 조회&#10;        &quot;&quot;&quot;&#10;        balances = self.get_balances()&#10;        if balances:&#10;            for b in balances:&#10;                if b.get('currency') == ticker:&#10;                    try:&#10;                        return float(b.get('balance', 0))&#10;                    except Exception:&#10;                        return 0.0&#10;        return 0.0&#10;&#10;    def get_klines(self, market, timeframe=&quot;minute1&quot;, count=200):&#10;        &quot;&quot;&quot;&#10;        캔들(시세) 조회: timeframe 문자열을 Upbit 엔드포인트로 매핑하여 호출합니다.&#10;        지원 예: 'minute1', 'minute3', 'minute5', 'minute15', 'minute60', 'day'&#10;        &quot;&quot;&quot;&#10;        # 매핑&#10;        tf = timeframe.lower()&#10;        if tf.startswith('minute'):&#10;            # minuteN -&gt; /v1/candles/minutes/N&#10;            try:&#10;                n = int(tf.replace('minute', ''))&#10;                endpoint = f&quot;/v1/candles/minutes/{n}&quot;&#10;            except Exception:&#10;                endpoint = &quot;/v1/candles/minutes/1&quot;&#10;        elif tf in ('day', 'days'):&#10;            endpoint = &quot;/v1/candles/days&quot;&#10;        elif tf in ('week', 'weeks'):&#10;            endpoint = &quot;/v1/candles/weeks&quot;&#10;        elif tf in ('month', 'months'):&#10;            endpoint = &quot;/v1/candles/months&quot;&#10;        else:&#10;            # fallback&#10;            endpoint = f&quot;/v1/candles/{tf}&quot;&#10;&#10;        # Try pyupbit if available for convenience and reliability&#10;        tf = timeframe.lower()&#10;        if _HAS_PYUPBIT:&#10;            try:&#10;                # pyupbit uses periods like &quot;minute&quot; string: use the numeric mapping&#10;                if tf.startswith('minute'):&#10;                    n = int(tf.replace('minute',''))&#10;                    interval_str = f&quot;minute{n}&quot;&#10;                    df = pyupbit.get_ohlcv(market, interval=interval_str, count=count)&#10;                elif tf in ('day','days'):&#10;                    df = pyupbit.get_ohlcv(market, interval='day', count=count)&#10;                elif tf in ('week','weeks'):&#10;                    df = pyupbit.get_ohlcv(market, interval='week', count=count)&#10;                elif tf in ('month','months'):&#10;                    df = pyupbit.get_ohlcv(market, interval='month', count=count)&#10;                else:&#10;                    # fallback to requests-based endpoint&#10;                    df = None&#10;                if df is not None:&#10;                    records = []&#10;                    # convert index to KST-aware ISO strings when possible&#10;                    for idx, row in df.iterrows():&#10;                        ts_str = None&#10;                        try:&#10;                            if _HAS_PANDAS and isinstance(idx, pd.Timestamp):&#10;                                # if naive, assume UTC and localize; then convert to Asia/Seoul&#10;                                if idx.tzinfo is None:&#10;                                    idx_utc = idx.tz_localize('UTC')&#10;                                else:&#10;                                    idx_utc = idx.tz_convert('UTC') if idx.tzinfo else idx.tz_localize('UTC')&#10;                                if pytz:&#10;                                    kst = pytz.timezone('Asia/Seoul')&#10;                                    idx_kst = idx_utc.tz_convert(kst)&#10;                                    ts_str = idx_kst.isoformat()&#10;                                else:&#10;                                    ts_str = idx_utc.isoformat()&#10;                            else:&#10;                                # fallback: str(idx)&#10;                                ts_str = str(idx)&#10;                        except Exception:&#10;                            ts_str = str(idx)&#10;                        records.append({'candle_date_time_kst': ts_str, 'opening_price': row['open'], 'high_price': row['high'], 'low_price': row['low'], 'trade_price': row['close'], 'candle_acc_trade_volume': row['volume']})&#10;                    return records&#10;            except Exception as e:&#10;                log.warning(f'pyupbit get_klines failed, falling back to HTTP: {e}')&#10;&#10;        params = {'market': market, 'count': count}&#10;        return self._send_request('GET', endpoint, params=params)&#10;&#10;    def get_orderbook(self, markets):&#10;        if isinstance(markets, (list, tuple)):&#10;            market_param = ','.join(markets)&#10;        else:&#10;            market_param = markets&#10;        data = self._send_request('GET', '/v1/orderbook', params={'markets': market_param})&#10;        if data and isinstance(data, list):&#10;            return data&#10;        return None&#10;&#10;    def place_order(self, market: str, side: str, ord_type: str = 'price', price: Optional[float] = None, volume: Optional[float] = None):&#10;        payload = {&#10;            'market': market,&#10;            'side': side,&#10;            'ord_type': ord_type,&#10;        }&#10;        if ord_type == 'price':&#10;            if price is None:&#10;                raise ValueError('price is required for ord_type=&quot;price&quot;')&#10;            payload['price'] = price&#10;        elif ord_type == 'market':&#10;            if volume is None:&#10;                raise ValueError(&quot;volume is required for market sell (ord_type='market')&quot;)&#10;            payload[&quot;volume&quot;] = str(volume)&#10;        elif ord_type == 'limit':&#10;            if price is None or volume is None:&#10;                raise ValueError('price and volume are required for ord_type=&quot;limit&quot;')&#10;            payload['price'] = price&#10;            payload['volume'] = volume&#10;        else:&#10;            raise ValueError(f&quot;Unsupported ord_type: {ord_type}&quot;)&#10;&#10;        return self._send_request('POST', '/v1/orders', data=payload)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/ws_listener.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/ws_listener.py" />
              <option name="originalContent" value="import json&#10;import os&#10;import threading&#10;import time&#10;import logging&#10;import uuid&#10;from collections import deque&#10;from datetime import datetime, timezone, timedelta&#10;from pathlib import Path&#10;from typing import Any, Dict, List, Optional&#10;&#10;import jwt&#10;import websocket  # websocket-client&#10;&#10;from server import config&#10;from server.logger import log, get_logger&#10;from server.config import get_setting&#10;&#10;UPBIT_WS_URL = &quot;wss://api.upbit.com/websocket/v1&quot;&#10;EXEC_HISTORY_DIR = Path(__file__).resolve().parents[1] / &quot;runtime&quot; / &quot;history&quot;&#10;EXEC_HISTORY_FILE = EXEC_HISTORY_DIR / &quot;exec_history.json&quot;&#10;EXEC_HISTORY_MAX = int(os.getenv(&quot;EXEC_HISTORY_MAX_ENTRIES&quot;, &quot;1024&quot;))&#10;EXEC_HISTORY_LOCK = threading.Lock()&#10;WS_STATS_FILE = EXEC_HISTORY_DIR / &quot;ws_stats.json&quot;&#10;KST = timezone(timedelta(hours=9))&#10;logger = get_logger(name='UpbitWSListener', log_file='ws_listener.log', level=logging.INFO)&#10;&#10;&#10;def _timeframe_to_seconds(timeframe: str) -&gt; int:&#10;    if not isinstance(timeframe, str):&#10;        return 60&#10;    tf = timeframe.lower()&#10;    if tf.startswith(&quot;minute&quot;):&#10;        try:&#10;            return max(int(tf.replace(&quot;minute&quot;, &quot;&quot;)) * 60, 60)&#10;        except ValueError:&#10;            return 60&#10;    if tf.startswith(&quot;hour&quot;):&#10;        try:&#10;            return max(int(tf.replace(&quot;hour&quot;, &quot;&quot;)) * 3600, 3600)&#10;        except ValueError:&#10;            return 3600&#10;    if tf.startswith(&quot;day&quot;):&#10;        return 86400&#10;    return 60&#10;&#10;&#10;def _ensure_exec_history_dir() -&gt; None:&#10;    EXEC_HISTORY_DIR.mkdir(parents=True, exist_ok=True)&#10;&#10;&#10;def _load_ws_stats_file() -&gt; Dict[str, Any]:&#10;    _ensure_exec_history_dir()&#10;    if not WS_STATS_FILE.exists():&#10;        return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;    try:&#10;        with WS_STATS_FILE.open('r', encoding='utf-8') as fp:&#10;            return json.load(fp)&#10;    except Exception:&#10;        return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;&#10;&#10;def summarize_ws_stats(raw_stats: Dict[str, Any], last_hour_secs: int = 3600, recent_limit: int = 10) -&gt; Dict[str, Any]:&#10;    totals = {&#10;        'total_success': int(raw_stats.get('total_success', 0)),&#10;        'total_failure': int(raw_stats.get('total_failure', 0)),&#10;    }&#10;    history = raw_stats.get('history') or []&#10;    now_ms = int(time.time() * 1000)&#10;    since_ms = now_ms - int(last_hour_secs * 1000) if last_hour_secs &gt; 0 else 0&#10;&#10;    def _filter_since(entries: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:&#10;        if since_ms &lt;= 0:&#10;            return entries[:]&#10;        return [item for item in entries if item.get('ts', 0) &gt;= since_ms]&#10;&#10;    ticker_events = [item for item in history if (item.get('type') or '').lower() == 'ticker']&#10;    order_events = [item for item in history if (item.get('type') or '').lower() == 'order']&#10;&#10;    ticker_success = sum(1 for item in ticker_events if item.get('success'))&#10;    ticker_failure = len(ticker_events) - ticker_success&#10;    order_success = sum(1 for item in order_events if item.get('success'))&#10;    order_failure = len(order_events) - order_success&#10;&#10;    ticker_last_hour = _filter_since(ticker_events)&#10;    order_last_hour = _filter_since(order_events)&#10;&#10;    ticker_last_hour_success = sum(1 for item in ticker_last_hour if item.get('success'))&#10;    ticker_last_hour_failure = len(ticker_last_hour) - ticker_last_hour_success&#10;    order_last_hour_success = sum(1 for item in order_last_hour if item.get('success'))&#10;    order_last_hour_failure = len(order_last_hour) - order_last_hour_success&#10;&#10;    if recent_limit &gt; 0:&#10;        recent_ticker_events = ticker_events[-recent_limit:]&#10;    else:&#10;        recent_ticker_events = ticker_events[:]&#10;&#10;    return {&#10;        'total_success': totals['total_success'],&#10;        'total_failure': totals['total_failure'],&#10;        'ticker_success': ticker_success,&#10;        'ticker_failure': ticker_failure,&#10;        'order_success': order_success,&#10;        'order_failure': order_failure,&#10;        'last_hour_ticker_success': ticker_last_hour_success,&#10;        'last_hour_ticker_failure': ticker_last_hour_failure,&#10;        'last_hour_order_success': order_last_hour_success,&#10;        'last_hour_order_failure': order_last_hour_failure,&#10;        'recent_ticker_events': recent_ticker_events,&#10;    }&#10;&#10;&#10;def read_exec_history(limit: int = 200) -&gt; List[Dict[str, Any]]:&#10;    store = ExecHistoryStore()&#10;    return store.read_recent(limit)&#10;&#10;&#10;class ExecHistoryStore:&#10;    def __init__(self, path: Path = EXEC_HISTORY_FILE, max_entries: int = EXEC_HISTORY_MAX):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        _ensure_exec_history_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Failed to load exec history: {exc}&quot;)&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Failed to write exec history: {exc}&quot;)&#10;&#10;    def record(self, entry: Dict[str, Any]) -&gt; None:&#10;        with EXEC_HISTORY_LOCK:&#10;            data = self._load()&#10;            data.append(entry)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;&#10;    def read_recent(self, limit: int = 200) -&gt; List[Dict[str, Any]]:&#10;        data = self._load()&#10;        if limit &lt;= 0:&#10;            return data[:]&#10;        return data[-limit:]&#10;&#10;&#10;class WebsocketListener:&#10;    def __init__(self, redis_client: Optional[Any] = None):&#10;        self.redis_client = redis_client&#10;        self._jwt_token = _generate_ws_token()&#10;        universe = get_setting(&quot;universe&quot;)&#10;        if isinstance(universe, list) and universe:&#10;            self.targets = universe&#10;        else:&#10;            # fallback sample list&#10;            self.targets = [&quot;KRW-BTC&quot;, &quot;KRW-ETH&quot;, &quot;KRW-ADA&quot;, &quot;KRW-XRP&quot;, &quot;KRW-SOL&quot;]&#10;        self.history_store = ExecHistoryStore()&#10;        self._stop_event = threading.Event()&#10;        self._thread: Optional[threading.Thread] = None&#10;        self._ws: Optional[websocket.WebSocketApp] = None&#10;        self._candle_state: Dict[str, Dict[str, Any]] = {}&#10;        self._candle_history_limit = int(os.getenv('WS_CANDLE_HISTORY_LIMIT', '240'))&#10;        self._last_acc_volume: Dict[str, float] = {}&#10;        self._entry_prices: Dict[str, float] = {}&#10;        self._timeframes = self._resolve_timeframes()&#10;        self._tf_state: Dict[str, Dict[str, Dict[str, Any]]] = {}&#10;        self._stats_history_limit = int(os.getenv('WS_STATS_HISTORY_LIMIT', '4000'))&#10;        self._stats_lock = threading.Lock()&#10;        stats = self._load_stats()&#10;        self._stats_totals = {&#10;            'success': stats.get('total_success', 0),&#10;            'failure': stats.get('total_failure', 0),&#10;        }&#10;        history_entries = stats.get('history', [])&#10;        self._stats_history: deque[Dict[str, Any]] = deque(history_entries[-self._stats_history_limit :], maxlen=self._stats_history_limit)&#10;&#10;    def _load_stats(self) -&gt; Dict[str, Any]:&#10;        if not WS_STATS_FILE.exists():&#10;            return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;        try:&#10;            with WS_STATS_FILE.open('r', encoding='utf-8') as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;&#10;    def _save_stats(self) -&gt; None:&#10;        try:&#10;            temp = WS_STATS_FILE.with_suffix('.tmp')&#10;            with temp.open('w', encoding='utf-8') as fp:&#10;                json.dump({&#10;                    'total_success': self._stats_totals['success'],&#10;                    'total_failure': self._stats_totals['failure'],&#10;                    'history': list(self._stats_history),&#10;                }, fp)&#10;            temp.replace(WS_STATS_FILE)&#10;        except Exception as exc:&#10;            log.warning(f'Failed to save websocket stats: {exc}')&#10;&#10;    def _register_reception(self, success: bool, payload: Dict[str, Any]) -&gt; None:&#10;        with self._stats_lock:&#10;            key = 'ticker' if payload.get('type') == 'ticker' else 'order'&#10;            ts = payload.get('trade_timestamp') or payload.get('timestamp') or int(time.time() * 1000)&#10;            entry = {&#10;                'ts': ts,&#10;                'type': payload.get('type'),&#10;                'symbol': payload.get('code') or payload.get('symbol'),&#10;                'success': success,&#10;            }&#10;            if success:&#10;                self._stats_totals['success'] += 1&#10;            else:&#10;                self._stats_totals['failure'] += 1&#10;            self._stats_history.append(entry)&#10;            self._save_stats()&#10;&#10;    def _payload_for_subscription(self) -&gt; str:&#10;        message = [&#10;            {&quot;ticket&quot;: self._jwt_token},&#10;            {&quot;type&quot;: &quot;MyOrder&quot;, &quot;codes&quot;: [&quot;KRW-&quot; + t.split('-')[-1] if not t.startswith('KRW-') else t for t in self.targets]},&#10;        ]&#10;        return json.dumps(message)&#10;&#10;    def _push_candle(self, ticker: str, timeframe: str, candle: Dict[str, Any]) -&gt; None:&#10;        if self.redis_client is None:&#10;            return&#10;        try:&#10;            key = f&quot;ws:candles:{timeframe}:{ticker}&quot;&#10;            candle = candle.copy()&#10;            ts = candle.get(&quot;timestamp&quot;)&#10;            if ts:&#10;                try:&#10;                    qualifier = datetime.fromtimestamp(ts / 1000.0, KST)&#10;                    candle[&quot;candle_date_time_kst&quot;] = qualifier.strftime(&quot;%Y-%m-%dT%H:%M:%S%z&quot;)&#10;                except Exception:&#10;                    pass&#10;            candle.setdefault(&quot;candle_acc_trade_volume&quot;, candle.get(&quot;volume&quot;, 0.0))&#10;            self.redis_client.lpush(key, json.dumps(candle))&#10;            self.redis_client.ltrim(key, 0, self._candle_history_limit - 1)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Redis candle push failed: {exc}&quot;)&#10;&#10;    def _read_cached_candles(self, ticker: str, timeframe: str = 'minute1', limit: int = 200) -&gt; List[Dict[str, Any]]:&#10;        if self.redis_client is None:&#10;            return []&#10;        key = f&quot;ws:candles:{timeframe}:{ticker}&quot;&#10;        try:&#10;            raw = self.redis_client.lrange(key, 0, limit - 1)&#10;        except Exception:&#10;            return []&#10;        result = []&#10;        for raw_item in reversed(raw):&#10;            try:&#10;                payload = json.loads(raw_item)&#10;                result.append(payload)&#10;            except Exception:&#10;                continue&#10;        return result&#10;&#10;    def _aggregate_candle(self, payload: Dict[str, Any]) -&gt; None:&#10;        ticker = payload.get(&quot;code&quot;) or payload.get(&quot;symbol&quot;)&#10;        if not ticker:&#10;            return&#10;        ts = payload.get(&quot;trade_timestamp&quot;) or payload.get(&quot;timestamp&quot;) or int(time.time() * 1000)&#10;        try:&#10;            ts_val = float(ts)&#10;        except Exception:&#10;            ts_val = float(time.time() * 1000)&#10;        minute_ts = int(ts_val // 60000 * 60000)&#10;        price = float(payload.get(&quot;trade_price&quot;) or payload.get(&quot;price&quot;) or 0.0)&#10;        if price &lt;= 0:&#10;            return&#10;        state = self._candle_state.get(ticker)&#10;        if not state or state.get(&quot;minute&quot;) != minute_ts:&#10;            if state:&#10;                self._push_candle(ticker, 'minute1', {&#10;                    &quot;ticker&quot;: ticker,&#10;                    &quot;timestamp&quot;: state[&quot;minute&quot;],&#10;                    &quot;open&quot;: state[&quot;open&quot;],&#10;                    &quot;high&quot;: state[&quot;high&quot;],&#10;                    &quot;low&quot;: state[&quot;low&quot;],&#10;                    &quot;close&quot;: state[&quot;close&quot;],&#10;                    &quot;volume&quot;: state[&quot;volume&quot;],&#10;                })&#10;                self._emit_to_timeframes(ticker, state[&quot;minute&quot;], state)&#10;            self._candle_state[ticker] = {&#10;                &quot;minute&quot;: minute_ts,&#10;                &quot;open&quot;: price,&#10;                &quot;high&quot;: price,&#10;                &quot;low&quot;: price,&#10;                &quot;close&quot;: price,&#10;                &quot;volume&quot;: 0.0,&#10;            }&#10;            self._last_acc_volume[ticker] = float(payload.get(&quot;acc_trade_volume&quot;, 0) or 0)&#10;            return&#10;        if price &gt; state[&quot;high&quot;]:&#10;            state[&quot;high&quot;] = price&#10;        if price &lt; state[&quot;low&quot;]:&#10;            state[&quot;low&quot;] = price&#10;        state[&quot;close&quot;] = price&#10;        acc_vol = float(payload.get(&quot;acc_trade_volume&quot;, 0) or 0)&#10;        prev_acc = self._last_acc_volume.get(ticker, 0.0)&#10;        if acc_vol &gt;= prev_acc:&#10;            state[&quot;volume&quot;] += acc_vol - prev_acc&#10;        else:&#10;            state[&quot;volume&quot;] += acc_vol&#10;        self._last_acc_volume[ticker] = acc_vol&#10;&#10;    def _store_to_redis(self, payload: Dict[str, Any]) -&gt; None:&#10;        if self.redis_client is None:&#10;            return&#10;        try:&#10;            code = payload.get(&quot;code&quot;) or payload.get(&quot;symbol&quot;)&#10;            if not code:&#10;                return&#10;            key_base = f&quot;ws:{payload.get('type', 'unknown')}:{code}&quot;&#10;            self.redis_client.set(key_base, json.dumps(payload))&#10;            if payload.get(&quot;type&quot;) == &quot;trade&quot;:&#10;                list_key = f&quot;ws:trades:{code}&quot;&#10;                self.redis_client.lpush(list_key, json.dumps(payload))&#10;                self.redis_client.ltrim(list_key, 0, 200)&#10;            if payload.get(&quot;type&quot;) == &quot;ticker&quot;:&#10;                self._aggregate_candle(payload)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Redis write failed for websocket payload: {exc}&quot;)&#10;&#10;    def _record_exec_history(self, payload: Dict[str, Any]) -&gt; None:&#10;        if payload.get(&quot;type&quot;) != &quot;order&quot;:&#10;            return&#10;        entry = {&#10;            &quot;ts&quot;: float(payload.get(&quot;timestamp&quot;, payload.get(&quot;trade_timestamp&quot;, time.time())) / 1000.0)&#10;            if payload.get(&quot;timestamp&quot;)&#10;            else time.time(),&#10;            &quot;symbol&quot;: payload.get(&quot;code&quot;) or payload.get(&quot;symbol&quot;),&#10;            &quot;price&quot;: payload.get(&quot;price&quot;) or payload.get(&quot;order_price&quot;) or 0,&#10;            &quot;size&quot;: payload.get(&quot;trade_volume&quot;, payload.get(&quot;volume&quot;) or 0),&#10;            &quot;side&quot;: payload.get(&quot;side&quot;) or payload.get(&quot;order_side&quot;) or payload.get(&quot;ask_bid&quot;),&#10;            &quot;order_id&quot;: payload.get(&quot;uuid&quot;) or payload.get(&quot;order_id&quot;),&#10;        }&#10;        side = (entry.get(&quot;side&quot;) or &quot;&quot;).lower()&#10;        symbol = entry.get(&quot;symbol&quot;)&#10;        avg_price = payload.get(&quot;avg_price&quot;) or payload.get(&quot;avg_buy_price&quot;) or payload.get(&quot;order_price&quot;) or payload.get(&quot;price&quot;)&#10;        try:&#10;            avg_price_val = float(avg_price) if avg_price is not None else 0.0&#10;        except Exception:&#10;            avg_price_val = 0.0&#10;&#10;        entry_price_value = 0.0&#10;        if side in (&quot;bid&quot;, &quot;buy&quot;, &quot;매수&quot;):&#10;            self._entry_prices[symbol] = avg_price_val or self._entry_prices.get(symbol, 0.0)&#10;        else:&#10;            entry_price_value = self._entry_prices.get(symbol, avg_price_val)&#10;        entry[&quot;entry_price&quot;] = entry_price_value or 0.0&#10;        if entry[&quot;symbol&quot;]:&#10;            self.history_store.record(entry)&#10;&#10;    def _on_message(self, _, message: str) -&gt; None:&#10;        try:&#10;            payloads = json.loads(message)&#10;            if isinstance(payloads, list):&#10;                for payload in payloads:&#10;                    self._handle_payload(payload)&#10;            elif isinstance(payloads, dict):&#10;                self._handle_payload(payloads)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Failed to parse websocket message: {exc}&quot;)&#10;&#10;    def _handle_payload(self, payload: Dict[str, Any]) -&gt; None:&#10;        success = True&#10;        try:&#10;            self._store_to_redis(payload)&#10;            self._record_exec_history(payload)&#10;        except Exception as exc:&#10;            success = False&#10;            log.warning(f&quot;Websocket payload handling failed: {exc}&quot;)&#10;        finally:&#10;            self._register_reception(success, payload)&#10;&#10;    def _resolve_timeframes(self) -&gt; List[str]:&#10;        cfg_frames = get_setting('ws_timeframes')&#10;        frames: List[str] = []&#10;        if isinstance(cfg_frames, list):&#10;            for tf in cfg_frames:&#10;                if isinstance(tf, str) and tf.strip():&#10;                    frames.append(tf.strip())&#10;        primary = get_setting('timeframe') or 'minute5'&#10;        if primary not in frames:&#10;            frames.append(primary)&#10;        if 'minute1' not in frames:&#10;            frames.insert(0, 'minute1')&#10;        seen: List[str] = []&#10;        for tf in frames:&#10;            if tf not in seen:&#10;                seen.append(tf)&#10;        return seen&#10;&#10;    def _emit_to_timeframes(self, ticker: str, base_ts: float, candle: Dict[str, Any]) -&gt; None:&#10;        bucket_map = self._tf_state.setdefault(ticker, {})&#10;        for timeframe in self._timeframes:&#10;            if timeframe == 'minute1':&#10;                continue&#10;            duration = _timeframe_to_seconds(timeframe) * 1000&#10;            bucket_start = int(base_ts // duration) * duration&#10;            state = bucket_map.get(timeframe)&#10;            if not state or state.get('start') != bucket_start:&#10;                if state:&#10;                    self._push_candle(ticker, timeframe, state)&#10;                bucket_map[timeframe] = {&#10;                    'ticker': ticker,&#10;                    'timeframe': timeframe,&#10;                    'timestamp': bucket_start,&#10;                    'start': bucket_start,&#10;                    'open': candle.get('open'),&#10;                    'high': candle.get('high'),&#10;                    'low': candle.get('low'),&#10;                    'close': candle.get('close'),&#10;                    'volume': candle.get('volume', 0.0),&#10;                }&#10;            else:&#10;                state['high'] = max(state.get('high', 0.0), candle.get('high', 0.0))&#10;                state['low'] = min(state.get('low', state.get('high', 0.0)), candle.get('low', 0.0))&#10;                state['close'] = candle.get('close')&#10;                state['volume'] = state.get('volume', 0.0) + candle.get('volume', 0.0)&#10;&#10;    def _extract_message_payload(self, value: Any) -&gt; Optional[str]:&#10;        if value is None:&#10;            return None&#10;        if isinstance(value, dict):&#10;            return value.get('message') or value.get('errorMessage') or value.get('errorMsg')&#10;        if isinstance(value, str):&#10;            try:&#10;                parsed = json.loads(value)&#10;                if isinstance(parsed, dict):&#10;                    return parsed.get('message') or parsed.get('errorMessage') or parsed.get('errorMsg')&#10;            except json.JSONDecodeError:&#10;                return value&#10;        try:&#10;            return str(value)&#10;        except Exception:&#10;            return None&#10;&#10;    def _format_close_info(self, code: Any, msg: Any) -&gt; str:&#10;        parts: list[str] = []&#10;        if code is not None:&#10;            parts.append(f&quot;code={code}&quot;)&#10;        message = self._extract_message_payload(msg)&#10;        if message:&#10;            parts.append(f&quot;msg={message}&quot;)&#10;        elif msg is not None:&#10;            try:&#10;                decoded = msg.decode() if isinstance(msg, bytes) else str(msg)&#10;            except Exception:&#10;                decoded = str(msg)&#10;            parts.append(f&quot;msg={decoded}&quot;)&#10;        return &quot;, &quot;.join(parts) if parts else &quot;no details&quot;&#10;&#10;    def _on_error(self, _, error: Any) -&gt; None:&#10;        detail = self._extract_message_payload(error)&#10;        if detail:&#10;            logger.warning(f&quot;Websocket listener error: {detail}&quot;)&#10;        else:&#10;            logger.warning(f&quot;Websocket listener error: {error}&quot;)&#10;&#10;    def _on_close(self, _, close_status_code, close_msg) -&gt; None:&#10;        close_info = self._format_close_info(close_status_code, close_msg)&#10;        logger.info(f&quot;Websocket connection closed ({close_info})&quot;)&#10;&#10;    def _on_open(self, ws: websocket.WebSocketApp) -&gt; None:&#10;        self._ws = ws&#10;        try:&#10;            logger.info(f&quot;Sending subscription payload: {self._payload_for_subscription()}&quot;)&#10;            ws.send(self._payload_for_subscription())&#10;        except Exception as exc:&#10;            logger.warning(f&quot;Failed to send websocket subscription: {exc}&quot;)&#10;&#10;    def _run(self) -&gt; None:&#10;        while not self._stop_event.is_set():&#10;            if not self._jwt_token:&#10;                time.sleep(5)&#10;                continue&#10;            try:&#10;                headers = []&#10;                if self._jwt_token:&#10;                    headers.append(f&quot;Authorization: Bearer {self._jwt_token}&quot;)&#10;                ws_app = websocket.WebSocketApp(&#10;                    UPBIT_WS_URL,&#10;                    on_open=self._on_open,&#10;                    on_message=self._on_message,&#10;                    on_error=self._on_error,&#10;                    on_close=self._on_close,&#10;                    header=headers if headers else None,&#10;                 )&#10;                ws_app.run_forever(ping_interval=20, ping_timeout=10)&#10;            except Exception as exc:&#10;                logger.warning(f&quot;Websocket listener restart: {exc}&quot;)&#10;            time.sleep(2)&#10;&#10;    def start(self) -&gt; None:&#10;        if self._thread and self._thread.is_alive():&#10;            return&#10;        self._stop_event.clear()&#10;        self._thread = threading.Thread(target=self._run, daemon=True)&#10;        self._thread.start()&#10;        logger.info(&quot;Websocket listener started.&quot;)&#10;&#10;    def stop(self) -&gt; None:&#10;        self._stop_event.set()&#10;        if self._ws:&#10;            try:&#10;                self._ws.close()&#10;            except Exception:&#10;                pass&#10;        if self._thread:&#10;            self._thread.join(timeout=2)&#10;        logger.info(&quot;Websocket listener stopped.&quot;)&#10;&#10;&#10;def _get_universe_targets() -&gt; List[str]:&#10;    universe = get_setting('universe')&#10;    if isinstance(universe, list) and universe:&#10;        return universe&#10;    return [&quot;KRW-BTC&quot;, &quot;KRW-ETH&quot;, &quot;KRW-ADA&quot;, &quot;KRW-XRP&quot;, &quot;KRW-SOL&quot;]&#10;&#10;&#10;def _generate_ws_token() -&gt; Optional[str]:&#10;    access_key = config.UPBIT_ACCESS_KEY&#10;    secret_key = config.UPBIT_SECRET_KEY&#10;    if not access_key or not secret_key:&#10;        logger.warning('UPBIT_ACCESS_KEY/UPBIT_SECRET_KEY missing; MyOrder websocket authentication skipped.')&#10;        return None&#10;    payload = {'access_key': access_key, 'nonce': str(uuid.uuid4())}&#10;    try:&#10;        token = jwt.encode(payload, secret_key, algorithm='HS256')&#10;        return token.decode() if isinstance(token, bytes) else token&#10;    except Exception as exc:&#10;        logger.warning(f'Failed to create websocket JWT: {exc}')&#10;        return None&#10;" />
              <option name="updatedContent" value="import json&#10;import os&#10;import threading&#10;import time&#10;import logging&#10;import uuid&#10;from collections import deque&#10;from datetime import datetime, timezone, timedelta&#10;from pathlib import Path&#10;from typing import Any, Dict, List, Optional&#10;&#10;import jwt&#10;import websocket  # websocket-client&#10;&#10;from server import config&#10;from server.logger import log, get_logger&#10;from server.config import get_setting&#10;&#10;UPBIT_WS_URL = &quot;wss://api.upbit.com/websocket/v1&quot;&#10;EXEC_HISTORY_DIR = Path(__file__).resolve().parents[1] / &quot;runtime&quot; / &quot;history&quot;&#10;EXEC_HISTORY_FILE = EXEC_HISTORY_DIR / &quot;exec_history.json&quot;&#10;EXEC_HISTORY_MAX = int(os.getenv(&quot;EXEC_HISTORY_MAX_ENTRIES&quot;, &quot;1024&quot;))&#10;EXEC_HISTORY_LOCK = threading.Lock()&#10;WS_STATS_FILE = EXEC_HISTORY_DIR / &quot;ws_stats.json&quot;&#10;KST = timezone(timedelta(hours=9))&#10;logger = get_logger(name='UpbitWSListener', log_file='ws_listener.log', level=logging.INFO)&#10;&#10;&#10;def _timeframe_to_seconds(timeframe: str) -&gt; int:&#10;    if not isinstance(timeframe, str):&#10;        return 60&#10;    tf = timeframe.lower()&#10;    if tf.startswith(&quot;minute&quot;):&#10;        try:&#10;            return max(int(tf.replace(&quot;minute&quot;, &quot;&quot;)) * 60, 60)&#10;        except ValueError:&#10;            return 60&#10;    if tf.startswith(&quot;hour&quot;):&#10;        try:&#10;            return max(int(tf.replace(&quot;hour&quot;, &quot;&quot;)) * 3600, 3600)&#10;        except ValueError:&#10;            return 3600&#10;    if tf.startswith(&quot;day&quot;):&#10;        return 86400&#10;    return 60&#10;&#10;&#10;def _ensure_exec_history_dir() -&gt; None:&#10;    EXEC_HISTORY_DIR.mkdir(parents=True, exist_ok=True)&#10;&#10;&#10;def _load_ws_stats_file() -&gt; Dict[str, Any]:&#10;    _ensure_exec_history_dir()&#10;    if not WS_STATS_FILE.exists():&#10;        return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;    try:&#10;        with WS_STATS_FILE.open('r', encoding='utf-8') as fp:&#10;            return json.load(fp)&#10;    except Exception:&#10;        return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;&#10;&#10;def summarize_ws_stats(raw_stats: Dict[str, Any], last_hour_secs: int = 3600, recent_limit: int = 10) -&gt; Dict[str, Any]:&#10;    totals = {&#10;        'total_success': int(raw_stats.get('total_success', 0)),&#10;        'total_failure': int(raw_stats.get('total_failure', 0)),&#10;    }&#10;    history = raw_stats.get('history') or []&#10;    now_ms = int(time.time() * 1000)&#10;    since_ms = now_ms - int(last_hour_secs * 1000) if last_hour_secs &gt; 0 else 0&#10;&#10;    def _filter_since(entries: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:&#10;        if since_ms &lt;= 0:&#10;            return entries[:]&#10;        return [item for item in entries if item.get('ts', 0) &gt;= since_ms]&#10;&#10;    ticker_events = [item for item in history if (item.get('type') or '').lower() == 'ticker']&#10;    order_events = [item for item in history if (item.get('type') or '').lower() == 'order']&#10;&#10;    ticker_success = sum(1 for item in ticker_events if item.get('success'))&#10;    ticker_failure = len(ticker_events) - ticker_success&#10;    order_success = sum(1 for item in order_events if item.get('success'))&#10;    order_failure = len(order_events) - order_success&#10;&#10;    ticker_last_hour = _filter_since(ticker_events)&#10;    order_last_hour = _filter_since(order_events)&#10;&#10;    ticker_last_hour_success = sum(1 for item in ticker_last_hour if item.get('success'))&#10;    ticker_last_hour_failure = len(ticker_last_hour) - ticker_last_hour_success&#10;    order_last_hour_success = sum(1 for item in order_last_hour if item.get('success'))&#10;    order_last_hour_failure = len(order_last_hour) - order_last_hour_success&#10;&#10;    if recent_limit &gt; 0:&#10;        recent_ticker_events = ticker_events[-recent_limit:]&#10;    else:&#10;        recent_ticker_events = ticker_events[:]&#10;&#10;    return {&#10;        'total_success': totals['total_success'],&#10;        'total_failure': totals['total_failure'],&#10;        'ticker_success': ticker_success,&#10;        'ticker_failure': ticker_failure,&#10;        'order_success': order_success,&#10;        'order_failure': order_failure,&#10;        'last_hour_ticker_success': ticker_last_hour_success,&#10;        'last_hour_ticker_failure': ticker_last_hour_failure,&#10;        'last_hour_order_success': order_last_hour_success,&#10;        'last_hour_order_failure': order_last_hour_failure,&#10;        'recent_ticker_events': recent_ticker_events,&#10;    }&#10;&#10;&#10;def read_exec_history(limit: int = 200) -&gt; List[Dict[str, Any]]:&#10;    store = ExecHistoryStore()&#10;    return store.read_recent(limit)&#10;&#10;&#10;class ExecHistoryStore:&#10;    def __init__(self, path: Path = EXEC_HISTORY_FILE, max_entries: int = EXEC_HISTORY_MAX):&#10;        self.path = path&#10;        self.max_entries = max_entries&#10;        _ensure_exec_history_dir()&#10;&#10;    def _load(self) -&gt; List[Dict[str, Any]]:&#10;        if not self.path.exists():&#10;            return []&#10;        try:&#10;            with self.path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                return json.load(fp)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Failed to load exec history: {exc}&quot;)&#10;            return []&#10;&#10;    def _save(self, data: List[Dict[str, Any]]) -&gt; None:&#10;        try:&#10;            with self.path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as fp:&#10;                json.dump(data, fp, ensure_ascii=False)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Failed to write exec history: {exc}&quot;)&#10;&#10;    def record(self, entry: Dict[str, Any]) -&gt; None:&#10;        with EXEC_HISTORY_LOCK:&#10;            data = self._load()&#10;            data.append(entry)&#10;            if len(data) &gt; self.max_entries:&#10;                data = data[-self.max_entries :]&#10;            self._save(data)&#10;&#10;    def read_recent(self, limit: int = 200) -&gt; List[Dict[str, Any]]:&#10;        data = self._load()&#10;        if limit &lt;= 0:&#10;            return data[:]&#10;        return data[-limit:]&#10;&#10;&#10;class WebsocketListener:&#10;    def __init__(self, redis_client: Optional[Any] = None):&#10;        self.redis_client = redis_client&#10;        self._jwt_token = _generate_ws_token()&#10;        universe = get_setting(&quot;universe&quot;)&#10;        if isinstance(universe, list) and universe:&#10;            self.targets = universe&#10;        else:&#10;            # fallback sample list&#10;            self.targets = [&quot;KRW-BTC&quot;, &quot;KRW-ETH&quot;, &quot;KRW-ADA&quot;, &quot;KRW-XRP&quot;, &quot;KRW-SOL&quot;]&#10;        self.history_store = ExecHistoryStore()&#10;        self._stop_event = threading.Event()&#10;        self._thread: Optional[threading.Thread] = None&#10;        self._ws: Optional[websocket.WebSocketApp] = None&#10;        self._candle_state: Dict[str, Dict[str, Any]] = {}&#10;        self._candle_history_limit = int(os.getenv('WS_CANDLE_HISTORY_LIMIT', '240'))&#10;        self._last_acc_volume: Dict[str, float] = {}&#10;        self._entry_prices: Dict[str, float] = {}&#10;        self._timeframes = self._resolve_timeframes()&#10;        self._tf_state: Dict[str, Dict[str, Dict[str, Any]]] = {}&#10;        self._stats_history_limit = int(os.getenv('WS_STATS_HISTORY_LIMIT', '4000'))&#10;        self._stats_lock = threading.Lock()&#10;        stats = self._load_stats()&#10;        self._stats_totals = {&#10;            'success': stats.get('total_success', 0),&#10;            'failure': stats.get('total_failure', 0),&#10;        }&#10;        history_entries = stats.get('history', [])&#10;        self._stats_history: deque[Dict[str, Any]] = deque(history_entries[-self._stats_history_limit :], maxlen=self._stats_history_limit)&#10;&#10;    def _load_stats(self) -&gt; Dict[str, Any]:&#10;        if not WS_STATS_FILE.exists():&#10;            return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;        try:&#10;            with WS_STATS_FILE.open('r', encoding='utf-8') as fp:&#10;                return json.load(fp)&#10;        except Exception:&#10;            return {'total_success': 0, 'total_failure': 0, 'history': []}&#10;&#10;    def _save_stats(self) -&gt; None:&#10;        try:&#10;            temp = WS_STATS_FILE.with_suffix('.tmp')&#10;            with temp.open('w', encoding='utf-8') as fp:&#10;                json.dump({&#10;                    'total_success': self._stats_totals['success'],&#10;                    'total_failure': self._stats_totals['failure'],&#10;                    'history': list(self._stats_history),&#10;                }, fp)&#10;            temp.replace(WS_STATS_FILE)&#10;        except Exception as exc:&#10;            log.warning(f'Failed to save websocket stats: {exc}')&#10;&#10;    def _register_reception(self, success: bool, payload: Dict[str, Any]) -&gt; None:&#10;        with self._stats_lock:&#10;            key = 'ticker' if payload.get('type') == 'ticker' else 'order'&#10;            ts = payload.get('trade_timestamp') or payload.get('timestamp') or int(time.time() * 1000)&#10;            entry = {&#10;                'ts': ts,&#10;                'type': payload.get('type'),&#10;                'symbol': payload.get('code') or payload.get('symbol'),&#10;                'success': success,&#10;            }&#10;            if success:&#10;                self._stats_totals['success'] += 1&#10;            else:&#10;                self._stats_totals['failure'] += 1&#10;            self._stats_history.append(entry)&#10;            self._save_stats()&#10;&#10;    def _payload_for_subscription(self) -&gt; str:&#10;        message = [&#10;            {&quot;ticket&quot;: self._jwt_token},&#10;            {&quot;type&quot;: &quot;MyOrder&quot;, &quot;codes&quot;: [&quot;KRW-&quot; + t.split('-')[-1] if not t.startswith('KRW-') else t for t in self.targets]},&#10;        ]&#10;        return json.dumps(message)&#10;&#10;    def _push_candle(self, ticker: str, timeframe: str, candle: Dict[str, Any]) -&gt; None:&#10;        if self.redis_client is None:&#10;            return&#10;        try:&#10;            key = f&quot;ws:candles:{timeframe}:{ticker}&quot;&#10;            candle = candle.copy()&#10;            ts = candle.get(&quot;timestamp&quot;)&#10;            if ts:&#10;                try:&#10;                    qualifier = datetime.fromtimestamp(ts / 1000.0, KST)&#10;                    candle[&quot;candle_date_time_kst&quot;] = qualifier.strftime(&quot;%Y-%m-%dT%H:%M:%S%z&quot;)&#10;                except Exception:&#10;                    pass&#10;            candle.setdefault(&quot;candle_acc_trade_volume&quot;, candle.get(&quot;volume&quot;, 0.0))&#10;            self.redis_client.lpush(key, json.dumps(candle))&#10;            self.redis_client.ltrim(key, 0, self._candle_history_limit - 1)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Redis candle push failed: {exc}&quot;)&#10;&#10;    def _read_cached_candles(self, ticker: str, timeframe: str = 'minute1', limit: int = 200) -&gt; List[Dict[str, Any]]:&#10;        if self.redis_client is None:&#10;            return []&#10;        key = f&quot;ws:candles:{timeframe}:{ticker}&quot;&#10;        try:&#10;            raw = self.redis_client.lrange(key, 0, limit - 1)&#10;        except Exception:&#10;            return []&#10;        result = []&#10;        for raw_item in reversed(raw):&#10;            try:&#10;                payload = json.loads(raw_item)&#10;                result.append(payload)&#10;            except Exception:&#10;                continue&#10;        return result&#10;&#10;    def _aggregate_candle(self, payload: Dict[str, Any]) -&gt; None:&#10;        ticker = payload.get(&quot;code&quot;) or payload.get(&quot;symbol&quot;)&#10;        if not ticker:&#10;            return&#10;        ts = payload.get(&quot;trade_timestamp&quot;) or payload.get(&quot;timestamp&quot;) or int(time.time() * 1000)&#10;        try:&#10;            ts_val = float(ts)&#10;        except Exception:&#10;            ts_val = float(time.time() * 1000)&#10;        minute_ts = int(ts_val // 60000 * 60000)&#10;        price = float(payload.get(&quot;trade_price&quot;) or payload.get(&quot;price&quot;) or 0.0)&#10;        if price &lt;= 0:&#10;            return&#10;        state = self._candle_state.get(ticker)&#10;        if not state or state.get(&quot;minute&quot;) != minute_ts:&#10;            if state:&#10;                self._push_candle(ticker, 'minute1', {&#10;                    &quot;ticker&quot;: ticker,&#10;                    &quot;timestamp&quot;: state[&quot;minute&quot;],&#10;                    &quot;open&quot;: state[&quot;open&quot;],&#10;                    &quot;high&quot;: state[&quot;high&quot;],&#10;                    &quot;low&quot;: state[&quot;low&quot;],&#10;                    &quot;close&quot;: state[&quot;close&quot;],&#10;                    &quot;volume&quot;: state[&quot;volume&quot;],&#10;                })&#10;                self._emit_to_timeframes(ticker, state[&quot;minute&quot;], state)&#10;            self._candle_state[ticker] = {&#10;                &quot;minute&quot;: minute_ts,&#10;                &quot;open&quot;: price,&#10;                &quot;high&quot;: price,&#10;                &quot;low&quot;: price,&#10;                &quot;close&quot;: price,&#10;                &quot;volume&quot;: 0.0,&#10;            }&#10;            self._last_acc_volume[ticker] = float(payload.get(&quot;acc_trade_volume&quot;, 0) or 0)&#10;            return&#10;        if price &gt; state[&quot;high&quot;]:&#10;            state[&quot;high&quot;] = price&#10;        if price &lt; state[&quot;low&quot;]:&#10;            state[&quot;low&quot;] = price&#10;        state[&quot;close&quot;] = price&#10;        acc_vol = float(payload.get(&quot;acc_trade_volume&quot;, 0) or 0)&#10;        prev_acc = self._last_acc_volume.get(ticker, 0.0)&#10;        if acc_vol &gt;= prev_acc:&#10;            state[&quot;volume&quot;] += acc_vol - prev_acc&#10;        else:&#10;            state[&quot;volume&quot;] += acc_vol&#10;        self._last_acc_volume[ticker] = acc_vol&#10;&#10;    def _store_to_redis(self, payload: Dict[str, Any]) -&gt; None:&#10;        if self.redis_client is None:&#10;            return&#10;        try:&#10;            code = payload.get(&quot;code&quot;) or payload.get(&quot;symbol&quot;)&#10;            if not code:&#10;                return&#10;            key_base = f&quot;ws:{payload.get('type', 'unknown')}:{code}&quot;&#10;            self.redis_client.set(key_base, json.dumps(payload))&#10;            if payload.get(&quot;type&quot;) == &quot;trade&quot;:&#10;                list_key = f&quot;ws:trades:{code}&quot;&#10;                self.redis_client.lpush(list_key, json.dumps(payload))&#10;                self.redis_client.ltrim(list_key, 0, 200)&#10;            if payload.get(&quot;type&quot;) == &quot;ticker&quot;:&#10;                self._aggregate_candle(payload)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Redis write failed for websocket payload: {exc}&quot;)&#10;&#10;    def _record_exec_history(self, payload: Dict[str, Any]) -&gt; None:&#10;        if payload.get(&quot;type&quot;) != &quot;order&quot;:&#10;            return&#10;        entry = {&#10;            &quot;ts&quot;: float(payload.get(&quot;timestamp&quot;, payload.get(&quot;trade_timestamp&quot;, time.time())) / 1000.0)&#10;            if payload.get(&quot;timestamp&quot;)&#10;            else time.time(),&#10;            &quot;symbol&quot;: payload.get(&quot;code&quot;) or payload.get(&quot;symbol&quot;),&#10;            &quot;price&quot;: payload.get(&quot;price&quot;) or payload.get(&quot;order_price&quot;) or 0,&#10;            &quot;size&quot;: payload.get(&quot;trade_volume&quot;, payload.get(&quot;volume&quot;) or 0),&#10;            &quot;side&quot;: payload.get(&quot;side&quot;) or payload.get(&quot;order_side&quot;) or payload.get(&quot;ask_bid&quot;),&#10;            &quot;order_id&quot;: payload.get(&quot;uuid&quot;) or payload.get(&quot;order_id&quot;),&#10;        }&#10;        side = (entry.get(&quot;side&quot;) or &quot;&quot;).lower()&#10;        symbol = entry.get(&quot;symbol&quot;)&#10;        avg_price = payload.get(&quot;avg_price&quot;) or payload.get(&quot;avg_buy_price&quot;) or payload.get(&quot;order_price&quot;) or payload.get(&quot;price&quot;)&#10;        try:&#10;            avg_price_val = float(avg_price) if avg_price is not None else 0.0&#10;        except Exception:&#10;            avg_price_val = 0.0&#10;&#10;        entry_price_value = 0.0&#10;        if side in (&quot;bid&quot;, &quot;buy&quot;, &quot;매수&quot;):&#10;            self._entry_prices[symbol] = avg_price_val or self._entry_prices.get(symbol, 0.0)&#10;        else:&#10;            entry_price_value = self._entry_prices.get(symbol, avg_price_val)&#10;        entry[&quot;entry_price&quot;] = entry_price_value or 0.0&#10;        if entry[&quot;symbol&quot;]:&#10;            self.history_store.record(entry)&#10;&#10;    def _on_message(self, _, message: str) -&gt; None:&#10;        try:&#10;            payloads = json.loads(message)&#10;            if isinstance(payloads, list):&#10;                for payload in payloads:&#10;                    self._handle_payload(payload)&#10;            elif isinstance(payloads, dict):&#10;                self._handle_payload(payloads)&#10;        except Exception as exc:&#10;            log.warning(f&quot;Failed to parse websocket message: {exc}&quot;)&#10;&#10;    def _handle_payload(self, payload: Dict[str, Any]) -&gt; None:&#10;        success = True&#10;        try:&#10;            self._store_to_redis(payload)&#10;            self._record_exec_history(payload)&#10;        except Exception as exc:&#10;            success = False&#10;            log.warning(f&quot;Websocket payload handling failed: {exc}&quot;)&#10;        finally:&#10;            self._register_reception(success, payload)&#10;&#10;    def _resolve_timeframes(self) -&gt; List[str]:&#10;        cfg_frames = get_setting('ws_timeframes')&#10;        frames: List[str] = []&#10;        if isinstance(cfg_frames, list):&#10;            for tf in cfg_frames:&#10;                if isinstance(tf, str) and tf.strip():&#10;                    frames.append(tf.strip())&#10;        primary = get_setting('timeframe') or 'minute5'&#10;        if primary not in frames:&#10;            frames.append(primary)&#10;        if 'minute1' not in frames:&#10;            frames.insert(0, 'minute1')&#10;        seen: List[str] = []&#10;        for tf in frames:&#10;            if tf not in seen:&#10;                seen.append(tf)&#10;        return seen&#10;&#10;    def _emit_to_timeframes(self, ticker: str, base_ts: float, candle: Dict[str, Any]) -&gt; None:&#10;        bucket_map = self._tf_state.setdefault(ticker, {})&#10;        for timeframe in self._timeframes:&#10;            if timeframe == 'minute1':&#10;                continue&#10;            duration = _timeframe_to_seconds(timeframe) * 1000&#10;            bucket_start = int(base_ts // duration) * duration&#10;            state = bucket_map.get(timeframe)&#10;            if not state or state.get('start') != bucket_start:&#10;                if state:&#10;                    self._push_candle(ticker, timeframe, state)&#10;                bucket_map[timeframe] = {&#10;                    'ticker': ticker,&#10;                    'timeframe': timeframe,&#10;                    'timestamp': bucket_start,&#10;                    'start': bucket_start,&#10;                    'open': candle.get('open'),&#10;                    'high': candle.get('high'),&#10;                    'low': candle.get('low'),&#10;                    'close': candle.get('close'),&#10;                    'volume': candle.get('volume', 0.0),&#10;                }&#10;            else:&#10;                state['high'] = max(state.get('high', 0.0), candle.get('high', 0.0))&#10;                state['low'] = min(state.get('low', state.get('high', 0.0)), candle.get('low', 0.0))&#10;                state['close'] = candle.get('close')&#10;                state['volume'] = state.get('volume', 0.0) + candle.get('volume', 0.0)&#10;&#10;    def _extract_message_payload(self, value: Any) -&gt; Optional[str]:&#10;        if value is None:&#10;            return None&#10;        if isinstance(value, dict):&#10;            return value.get('message') or value.get('errorMessage') or value.get('errorMsg')&#10;        if isinstance(value, str):&#10;            try:&#10;                parsed = json.loads(value)&#10;                if isinstance(parsed, dict):&#10;                    return parsed.get('message') or parsed.get('errorMessage') or parsed.get('errorMsg')&#10;            except json.JSONDecodeError:&#10;                return value&#10;        try:&#10;            return str(value)&#10;        except Exception:&#10;            return None&#10;&#10;    def _format_close_info(self, code: Any, msg: Any) -&gt; str:&#10;        parts: list[str] = []&#10;        if code is not None:&#10;            parts.append(f&quot;code={code}&quot;)&#10;        message = self._extract_message_payload(msg)&#10;        if message:&#10;            parts.append(f&quot;msg={message}&quot;)&#10;        elif msg is not None:&#10;            try:&#10;                decoded = msg.decode() if isinstance(msg, bytes) else str(msg)&#10;            except Exception:&#10;                decoded = str(msg)&#10;            parts.append(f&quot;msg={decoded}&quot;)&#10;        return &quot;, &quot;.join(parts) if parts else &quot;no details&quot;&#10;&#10;    def _on_error(self, _, error: Any) -&gt; None:&#10;        detail = self._extract_message_payload(error)&#10;        if detail:&#10;            logger.warning(f&quot;Websocket listener error: {detail}&quot;)&#10;        else:&#10;            logger.warning(f&quot;Websocket listener error: {error}&quot;)&#10;&#10;    def _on_close(self, _, close_status_code, close_msg) -&gt; None:&#10;        close_info = self._format_close_info(close_status_code, close_msg)&#10;        logger.info(f&quot;Websocket connection closed ({close_info})&quot;)&#10;&#10;    def _on_open(self, ws: websocket.WebSocketApp) -&gt; None:&#10;        self._ws = ws&#10;        try:&#10;            logger.info(f&quot;Sending subscription payload: {self._payload_for_subscription()}&quot;)&#10;            ws.send(self._payload_for_subscription())&#10;        except Exception as exc:&#10;            logger.warning(f&quot;Failed to send websocket subscription: {exc}&quot;)&#10;&#10;    def _run(self) -&gt; None:&#10;        while not self._stop_event.is_set():&#10;            if not self._jwt_token:&#10;                time.sleep(5)&#10;                continue&#10;            try:&#10;                headers = []&#10;                if self._jwt_token:&#10;                    headers.append(f&quot;Authorization: Bearer {self._jwt_token}&quot;)&#10;                ws_app = websocket.WebSocketApp(&#10;                    UPBIT_WS_URL,&#10;                    on_open=self._on_open,&#10;                    on_message=self._on_message,&#10;                    on_error=self._on_error,&#10;                    on_close=self._on_close,&#10;                    header=headers if headers else None,&#10;                 )&#10;                ws_app.run_forever(ping_interval=20, ping_timeout=10)&#10;            except Exception as exc:&#10;                logger.warning(f&quot;Websocket listener restart: {exc}&quot;)&#10;            time.sleep(2)&#10;&#10;    def start(self) -&gt; None:&#10;        if self._thread and self._thread.is_alive():&#10;            return&#10;        self._stop_event.clear()&#10;        self._thread = threading.Thread(target=self._run, daemon=True)&#10;        self._thread.start()&#10;        logger.info(&quot;Websocket listener started.&quot;)&#10;&#10;    def stop(self) -&gt; None:&#10;        self._stop_event.set()&#10;        if self._ws:&#10;            try:&#10;                self._ws.close()&#10;            except Exception:&#10;                pass&#10;        if self._thread:&#10;            self._thread.join(timeout=2)&#10;        logger.info(&quot;Websocket listener stopped.&quot;)&#10;&#10;&#10;def _get_universe_targets() -&gt; List[str]:&#10;    universe = get_setting('universe')&#10;    if isinstance(universe, list) and universe:&#10;        return universe&#10;    return [&quot;KRW-BTC&quot;, &quot;KRW-ETH&quot;, &quot;KRW-ADA&quot;, &quot;KRW-XRP&quot;, &quot;KRW-SOL&quot;]&#10;&#10;&#10;def _generate_ws_token() -&gt; Optional[str]:&#10;    access_key = config.UPBIT_ACCESS_KEY&#10;    secret_key = config.UPBIT_SECRET_KEY&#10;    if not access_key or not secret_key:&#10;        logger.warning('UPBIT_ACCESS_KEY/UPBIT_SECRET_KEY missing; MyOrder websocket authentication skipped.')&#10;        return None&#10;    payload = {'access_key': access_key, 'nonce': str(uuid.uuid4())}&#10;    try:&#10;        token = jwt.encode(payload, secret_key, algorithm='HS256')&#10;        return token.decode() if isinstance(token, bytes) else token&#10;    except Exception as exc:&#10;        logger.warning(f'Failed to create websocket JWT: {exc}')&#10;        return None&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/ui_dashboard.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/ui_dashboard.py" />
              <option name="originalContent" value="import streamlit as st&#10;try:&#10;    from streamlit_autorefresh import st_autorefresh as _autorefresh_component&#10;except ImportError:&#10;    _autorefresh_component = None&#10;import sys&#10;# reload-test: touch ui file to verify backend reload behavior (do not remove)&#10;import requests&#10;from requests.adapters import HTTPAdapter&#10;from urllib3.util.retry import Retry&#10;from pathlib import Path&#10;from typing import Any, Dict, Tuple, Optional&#10;import pandas as pd&#10;import plotly.graph_objects as go&#10;from plotly.subplots import make_subplots&#10;import time&#10;import os&#10;import json&#10;&#10;project_root = Path(__file__).resolve().parents[1]&#10;if str(project_root) not in sys.path:&#10;    sys.path.insert(0, str(project_root))&#10;try:&#10;    from server.config import load_config, save_config as save_local&#10;except Exception as err:&#10;    raise RuntimeError(f'server.config.load_config import failed: {err}')&#10;&#10;&#10;def validate_config(cfg: Dict[str, Any]) -&gt; Tuple[bool, str]:&#10;    &quot;&quot;&quot;Basic validation for runtime config used by the UI form.&#10;    Returns (True, '') if valid, otherwise (False, 'reason').&#10;    &quot;&quot;&quot;&#10;    if not isinstance(cfg, dict):&#10;        return False, '설정 데이터가 딕셔너리가 아닙니다.'&#10;    if not cfg.get('market'):&#10;        return False, 'Market 값이 필요합니다.'&#10;    if not isinstance(cfg.get('candle_count', 0), int) or cfg.get('candle_count', 0) &lt;= 0:&#10;        return False, 'Candle count 는 1 이상의 정수여야 합니다.'&#10;    order = cfg.get('order_settings', {})&#10;    if not isinstance(order.get('trade_amount_krw', 0), (int, float)) or order.get('trade_amount_krw', 0) &lt;= 0:&#10;        return False, 'Trade amount_krw 는 0보다 큰 숫자여야 합니다.'&#10;    kelly = cfg.get('kelly_criterion', {})&#10;    if cfg.get('use_kelly_criterion'):&#10;        wr = float(kelly.get('win_rate', 0))&#10;        pr = float(kelly.get('payoff_ratio', 0))&#10;        frac = float(kelly.get('fraction', 0))&#10;        if not (0 &lt;= wr &lt;= 1):&#10;            return False, 'Kelly win_rate 는 0~1 범위여야 합니다.'&#10;        if pr &lt;= 0:&#10;            return False, 'Kelly payoff_ratio 는 양수여야 합니다.'&#10;        if not (0 &lt;= frac &lt;= 1):&#10;            return False, 'Kelly fraction 은 0~1 범위여야 합니다.'&#10;    return True, ''&#10;&#10;&#10;RUNTIME_CONFIG = Path(__file__).resolve().parents[1] / 'runtime' / 'config.json'&#10;&#10;st.set_page_config(page_title='Upbit Trader', layout='wide')&#10;&#10;# Helper to render DataFrame safely across Streamlit versions and hide index when requested&#10;def _safe_dataframe(df: 'pd.DataFrame', hide_index: bool = False, **kwargs):&#10;    &quot;&quot;&quot;Render a pandas DataFrame while attempting to hide the index and use full width.&#10;    Tries the newer `width='stretch'` API first, then falls back to `use_container_width=True`,&#10;    and finally to the basic st.dataframe if needed.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return st.dataframe(df, hide_index=hide_index, width='stretch', **kwargs)&#10;    except TypeError:&#10;        try:&#10;            return st.dataframe(df, hide_index=hide_index, use_container_width=True, **kwargs)&#10;        except TypeError:&#10;            # Older Streamlit may not support hide_index; fallback to st.table (no hide)&#10;            try:&#10;                return st.table(df)&#10;            except Exception:&#10;                return st.write(df)&#10;&#10;&#10;def _safe_plotly_chart(fig, **kwargs):&#10;    &quot;&quot;&quot;Render a plotly figure using newer width='stretch' API if available, otherwise fall back to use_container_width.&quot;&quot;&quot;&#10;    try:&#10;        return st.plotly_chart(fig, width='stretch', **kwargs)&#10;    except TypeError:&#10;        try:&#10;            return st.plotly_chart(fig, use_container_width=True, **kwargs)&#10;        except Exception:&#10;            return st.write('차트를 표시할 수 없습니다.')&#10;&#10;&#10;# Callback for strategy selectbox to trigger immediate rerun so fields update&#10;def _on_strategy_change():&#10;    # mark change and request a rerun so Streamlit re-renders dynamic fields immediately&#10;    st.session_state['_strategy_changed'] = True&#10;    _trigger_rerun()&#10;&#10;&#10;def _trigger_rerun() -&gt; None:&#10;    rerun = getattr(st, 'rerun', None) or getattr(st, 'experimental_rerun', None)&#10;    if rerun:&#10;        try:&#10;            rerun()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;# API base URL for backend calls: read from env var STREAMLIT_API_BASE (set by docker-compose)&#10;# If not set, fall back to localhost for local development.&#10;API_BASE = os.getenv('STREAMLIT_API_BASE', 'http://127.0.0.1:8000')&#10;AUTO_REFRESH_KEY = 'ws_auto_refresh_enabled'&#10;&#10;&#10;# Create a requests session with retry/backoff to make UI-server comms more resilient&#10;def _build_session():&#10;    session = requests.Session()&#10;    retries = Retry(&#10;        total=3,&#10;        backoff_factor=0.6,&#10;        status_forcelist=(429, 500, 502, 503, 504),&#10;        allowed_methods=(&quot;GET&quot;, &quot;POST&quot;),&#10;        raise_on_status=False,&#10;    )&#10;    adapter = HTTPAdapter(max_retries=retries)&#10;    session.mount(&quot;http://&quot;, adapter)&#10;    session.mount(&quot;https://&quot;, adapter)&#10;    return session&#10;&#10;_API_SESSION = _build_session()&#10;&#10;def api_request(method: str, path: str, params=None, json=None, timeout=10):&#10;    &quot;&quot;&quot;Call server API with retries and return requests.Response or raise Exception with friendly message.&quot;&quot;&quot;&#10;    if not API_BASE:&#10;        raise RuntimeError(&quot;API Base URL is not set in the sidebar&quot;)&#10;    url = API_BASE.rstrip(&quot;/&quot;) + &quot;/&quot; + path.lstrip(&quot;/&quot;)&#10;    try:&#10;        if method.lower() == &quot;get&quot;:&#10;            resp = _API_SESSION.get(url, params=params, timeout=timeout)&#10;        else:&#10;            resp = _API_SESSION.post(url, json=json, timeout=timeout)&#10;        resp.raise_for_status()&#10;        return resp&#10;    except requests.exceptions.RequestException as e:&#10;        # Wrap low-level error to present user-friendly message in UI&#10;        raise RuntimeError(f&quot;서버 호출 실패: {e}&quot;) from e&#10;&#10;&#10;def fetch_ws_status():&#10;    try:&#10;        resp = api_request('get', '/ws/status', timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def fetch_ws_trades(symbol: str, limit: int = 20):&#10;    try:&#10;        resp = api_request('get', '/ws/trades', params={'symbol': symbol, 'limit': limit}, timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def _format_ws_ts(ts: Any) -&gt; str:&#10;    if ts is None:&#10;        return '-'&#10;    try:&#10;        value = float(ts)&#10;    except Exception:&#10;        return '-'&#10;    if value &gt; 1e12:&#10;        value /= 1000.0&#10;    dt = pd.to_datetime(value, unit='s', utc=True)&#10;    try:&#10;        dt = dt.tz_convert('Asia/Seoul')&#10;    except Exception:&#10;        dt = dt.tz_localize('Asia/Seoul', ambiguous='NaT', nonexistent='shift_forward')&#10;    return dt.strftime('%Y-%m-%d %H:%M:%S')&#10;&#10;&#10;def fetch_ws_stats(last_hour_sec: int = 3600, recent_limit: int = 10):&#10;    try:&#10;        resp = api_request('get', '/ws/stats', params={'last_hour_sec': last_hour_sec, 'recent_limit': recent_limit}, timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def fetch_ws_executions(limit: int = 0):&#10;    try:&#10;        params = {'limit': limit} if limit else {}&#10;        resp = api_request('get', '/ws/executions', params=params, timeout=10)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def _format_ws_trade_timestamp(payload: Dict[str, Any]) -&gt; str:&#10;    ts = payload.get('trade_timestamp') or payload.get('timestamp')&#10;    try:&#10;        if ts is None:&#10;            return '-'&#10;        tsf = float(ts) / 1000.0 if ts &gt; 1e12 else float(ts)&#10;        return pd.to_datetime(tsf, unit='s').strftime('%H:%M:%S')&#10;    except Exception:&#10;        return '-'&#10;&#10;&#10;def fetch_ws_ticker_data():&#10;    try:&#10;        resp = api_request('get', '/ws/ticker_data', timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def _render_autorefresh_button() -&gt; bool:&#10;    enabled = st.session_state.get(AUTO_REFRESH_KEY, False)&#10;    status_label = 'ON' if enabled else 'OFF'&#10;    icon = '' if enabled else '⚪'&#10;    label = f&quot;{icon} 5초 자동 새로고침 ({status_label})&quot;&#10;    clicked = st.button(label, key='ws_autorefresh_toggle', help='클릭하면 자동 새로고침을 켜거나 끕니다.')&#10;    if clicked:&#10;        enabled = not enabled&#10;        st.session_state[AUTO_REFRESH_KEY] = enabled&#10;        _trigger_rerun()&#10;    return enabled&#10;&#10;&#10;def _apply_autorefresh_if_enabled():&#10;    enabled = st.session_state.get(AUTO_REFRESH_KEY, False)&#10;    if not enabled:&#10;        return&#10;    if _autorefresh_component is None:&#10;        st.caption('streamlit-autorefresh 모듈이 없어 자동 갱신을 사용할 수 없습니다.')&#10;        return&#10;    _autorefresh_component(interval=5000, key='ws_ticker_autorefresh')&#10;&#10;&#10;# --- Upbit public klines helper (cached) ---&#10;@st.cache_data(ttl=10)&#10;def fetch_klines_cached(market: str, timeframe: str = 'minute1', count: int = 200) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;&#10;    UI-side fetch function disabled.&#10;    The UI must not call Upbit public API directly — always go through the backend `/klines_batch` endpoint.&#10;    This function returns None to force the UI to rely on backend data and avoid causing 429 Too Many Requests.&#10;    &quot;&quot;&quot;&#10;    # Return None immediately to prevent direct Upbit calls from the UI.&#10;    st.warning('UI는 직접 Upbit 호출을 하지 않습니다. 백엔드의 prefetch가 완료될 때까지 대기하세요.')&#10;    return None&#10;&#10;&#10;def fetch_klines_batch_from_backend(tickers: list[str], timeframe: str = 'minute15', count: int = 100) -&gt; Dict[str, pd.DataFrame | None]:&#10;    &quot;&quot;&quot;Call server /klines_batch to get klines for multiple tickers. Returns mapping ticker-&gt;DataFrame or None.&#10;    Falls back to empty dict on error.&#10;    &quot;&quot;&quot;&#10;    url = f&quot;{API_BASE.rstrip('/')}/klines_batch&quot;&#10;    try:&#10;        resp = requests.post(url, json={'tickers': tickers, 'timeframe': timeframe, 'count': count}, timeout=15)&#10;        resp.raise_for_status()&#10;        data = resp.json().get('klines', {})&#10;        result = {}&#10;        for t, v in data.items():&#10;            if not v:&#10;                result[t] = None&#10;                continue&#10;            df = pd.DataFrame(v)&#10;            df = df.rename(columns={&#10;                'candle_date_time_kst': 'time',&#10;                'opening_price': 'open',&#10;                'high_price': 'high',&#10;                'low_price': 'low',&#10;                'trade_price': 'close',&#10;                'candle_acc_trade_volume': 'volume'&#10;            })&#10;            cols = [c for c in ['time','open','high','low','close','volume'] if c in df.columns]&#10;            df = df[cols]&#10;            if 'time' in df.columns:&#10;                df['time'] = pd.to_datetime(df['time'])&#10;            for col in ['open','high','low','close','volume']:&#10;                if col in df.columns:&#10;                    df[col] = pd.to_numeric(df[col], errors='coerce')&#10;            df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;            result[t] = df&#10;        return result&#10;    except Exception as e:&#10;        st.warning(f'백엔드 batch klines 호출 실패: {e}')&#10;        return {}&#10;&#10;&#10;def compute_volatility_from_df(df: pd.DataFrame | None) -&gt; float | None:&#10;    &quot;&quot;&quot;Compute volatility as (max_high - min_low) / mean_close * 100.&#10;    Returns percent float or None if cannot compute.&#10;    &quot;&quot;&quot;&#10;    if df is None:&#10;        return None&#10;    try:&#10;        if not hasattr(df, 'empty') or df.empty:&#10;            return None&#10;        if 'high' not in df.columns or 'low' not in df.columns or 'close' not in df.columns:&#10;            return None&#10;        max_high = float(df['high'].max())&#10;        min_low = float(df['low'].min())&#10;        mean_close = float(df['close'].mean()) if float(df['close'].mean() or 0) != 0 else None&#10;        if mean_close is None or mean_close == 0:&#10;            return None&#10;        vol = (max_high - min_low) / mean_close * 100.0&#10;        return float(vol)&#10;    except Exception:&#10;        return None&#10;&#10;&#10;def _normalize_klines_df(df: pd.DataFrame | None, min_length: int = 30) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;Validate and normalize a kline DataFrame for plotting.&#10;    - Ensures time column exists and is datetime&#10;    - Renames common Upbit keys if needed&#10;    - Sorts ascending by time, drops duplicate timestamps&#10;    - Converts numeric columns and fills small gaps&#10;    - Returns None if data is invalid&#10;    &quot;&quot;&quot;&#10;    if df is None:&#10;        return None&#10;    # Accept list-of-dicts as well&#10;    if not isinstance(df, pd.DataFrame):&#10;        try:&#10;            df = pd.DataFrame(df)&#10;        except Exception:&#10;            return None&#10;&#10;    # Map common Upbit field names to expected ones&#10;    rename_map = {&#10;        'candle_date_time_kst': 'time',&#10;        'opening_price': 'open',&#10;        'high_price': 'high',&#10;        'low_price': 'low',&#10;        'trade_price': 'close',&#10;        'candle_acc_trade_volume': 'volume'&#10;    }&#10;    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})&#10;&#10;    # required columns&#10;    required = ['time', 'open', 'high', 'low', 'close', 'volume']&#10;    if 'time' not in df.columns:&#10;        return None&#10;&#10;    # time -&gt; datetime&#10;    try:&#10;        df['time'] = pd.to_datetime(df['time'])&#10;    except Exception:&#10;        try:&#10;            df['time'] = pd.to_datetime(df['time'].astype(str))&#10;        except Exception:&#10;            return None&#10;&#10;    # sort ascending and dedupe&#10;    df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;    if df['time'].duplicated().any():&#10;        df = df[~df['time'].duplicated(keep='last')].reset_index(drop=True)&#10;&#10;    # ensure numeric&#10;    for col in ['open', 'high', 'low', 'close', 'volume']:&#10;        if col in df.columns:&#10;            df[col] = pd.to_numeric(df[col], errors='coerce')&#10;        else:&#10;            df[col] = pd.NA&#10;&#10;    # fill small gaps for price columns&#10;    try:&#10;        df[['open', 'high', 'low', 'close']] = df[['open', 'high', 'low', 'close']].ffill().bfill()&#10;        df['volume'] = df['volume'].fillna(0)&#10;    except Exception:&#10;        pass&#10;&#10;    if len(df) &lt; min_length:&#10;        st.warning(f'차트에 필요한 데이터가 부족합니다: {len(df)}개 (최소 {min_length} 필요)')&#10;        return df&#10;    return df&#10;&#10;&#10;# --- Indicator helpers and plotting ---&#10;def compute_rsi(series: pd.Series, period: int = 14) -&gt; pd.Series:&#10;    # Standard Wilder's RSI calculation without forcing initial values to 0.&#10;    delta = series.diff()&#10;    up = delta.clip(lower=0)&#10;    down = -1 * delta.clip(upper=0)&#10;    ma_up = up.rolling(period, min_periods=period).mean()&#10;    ma_down = down.rolling(period, min_periods=period).mean()&#10;    rs = ma_up / ma_down&#10;    rsi = 100 - (100 / (1 + rs))&#10;    return rsi&#10;&#10;&#10;def plot_candles_with_indicators(df: pd.DataFrame, ticker: str, ma_windows: list[int], rsi_period: int):&#10;    # Create subplot: row1 = candlestick+MA, row2 = volume bars, row3 = RSI&#10;    fig = make_subplots(rows=3, cols=1, shared_xaxes=True, row_heights=[0.6, 0.2, 0.2], vertical_spacing=0.03)&#10;&#10;    # Row 1: Candlestick — set colors: rising(red), falling(blue)&#10;    fig.add_trace(go.Candlestick(x=df['time'], open=df['open'], high=df['high'], low=df['low'], close=df['close'], name='OHLC', increasing=dict(line=dict(color='red'), fillcolor='red'), decreasing=dict(line=dict(color='blue'), fillcolor='blue')), row=1, col=1)&#10;&#10;    # moving averages on top&#10;    for w in ma_windows:&#10;        ma = df['close'].rolling(w).mean()&#10;        fig.add_trace(go.Scatter(x=df['time'], y=ma, mode='lines', name=f'MA{w}', line=dict(width=1.2)), row=1, col=1)&#10;&#10;    # Row 2: Volume bars&#10;    # color volume bars green when close &gt;= open else red&#10;    try:&#10;        # rising -&gt; red, falling -&gt; blue&#10;        colors = ['red' if c &gt;= o else 'blue' for o, c in zip(df['open'], df['close'])]&#10;    except Exception:&#10;        colors = 'gray'&#10;    if 'volume' not in df.columns:&#10;        df['volume'] = 0&#10;    fig.add_trace(go.Bar(x=df['time'], y=df['volume'], name='Volume', marker=dict(color=colors), hovertemplate='Volume: %{y:,.0f}&lt;extra&gt;&lt;/extra&gt;'), row=2, col=1)&#10;    # Keep volume axis independent&#10;    fig.update_yaxes(title_text='Volume', row=2, col=1)&#10;&#10;    # Row 3: RSI&#10;    rsi = compute_rsi(df['close'], period=rsi_period)&#10;    fig.add_trace(go.Scatter(x=df['time'], y=rsi, mode='lines', name=f'RSI({rsi_period})', line=dict(color='purple', width=2.0), connectgaps=False, hovertemplate='RSI: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'), row=3, col=1)&#10;    # RSI bands (draw as shapes for visibility)&#10;    fig.add_hline(y=70, line=dict(color='red', dash='dash'), row=3, col=1)&#10;    fig.add_hline(y=30, line=dict(color='green', dash='dash'), row=3, col=1)&#10;    fig.update_yaxes(range=[0,100], row=3, col=1)&#10;&#10;    # layout tweaks&#10;    fig.update_layout(height=520, margin=dict(l=10, r=10, t=30, b=20), showlegend=True, hovermode='x unified')&#10;    fig.update_xaxes(rangebreaks=[dict(bounds=[&quot;sat&quot;,&quot;mon&quot;])], rangeslider_visible=False)&#10;    return fig&#10;&#10;&#10;# Load existing config&#10;cfg = load_config()&#10;&#10;# --- Page renderers ---&#10;&#10;def render_config_page(cfg: Dict[str, Any]):&#10;    st.title('설정 편집')&#10;&#10;    # Strategy selector placed outside the form so changes immediately re-render detail fields.&#10;    _strategy_opts = ['VolatilityBreakout', 'DualMomentum', 'RSI']&#10;    _default = cfg.get('strategy_name', 'VolatilityBreakout')&#10;    try:&#10;        _default_idx = _strategy_opts.index(_default) if _default in _strategy_opts else 0&#10;    except Exception:&#10;        _default_idx = 0&#10;    # initialize session state key if missing so we can read it inside the form&#10;    if 'cfg_strategy' not in st.session_state:&#10;        st.session_state['cfg_strategy'] = _strategy_opts[_default_idx]&#10;    strategy_name = st.selectbox('전략 (어떤 방식을 쓸까요?)', options=_strategy_opts, index=_default_idx, key='cfg_strategy', help='어떤 거래 전략을 쓸지 골라요. 예: 변동성 돌파, 모멘텀, RSI')&#10;&#10;    # Now the form (other widgets and save buttons). Inside the form read the currently selected strategy&#10;    with st.form('config_form', clear_on_submit=False):&#10;        # use the session_state value so fields update immediately when the selectbox changes&#10;        strategy_name = st.session_state.get('cfg_strategy', _strategy_opts[_default_idx])&#10;&#10;        # --- 전략별 상세 설정: 전략 선택 바로 아래에 위치하도록 함 ---&#10;        st.caption('선택한 전략에 따라 여기서 세부 옵션을 정해요.')&#10;        strategy_params = cfg.get('strategy_params', {})&#10;        if strategy_name == 'RSI':&#10;            rsi = strategy_params.get('RSI', {})&#10;            rsi_period = st.number_input('RSI 기간 (몇개 캔들로 계산할지)', min_value=1, value=int(rsi.get('period', 14)), help='RSI를 계산할 때 몇 개의 캔들을 볼지 정해요. 보통 14')&#10;            rsi_oversold = st.number_input('과매도 기준 (0~100)', min_value=0, max_value=100, value=int(rsi.get('oversold', 30)), help='이 값 아래면 너무 싸게 팔려서 사도 되는 상태예요.')&#10;            rsi_overbought = st.number_input('과매수 기준 (0~100)', min_value=0, max_value=100, value=int(rsi.get('overbought', 70)), help='이 값 위면 너무 비싸게 사져서 팔아야 할 수도 있어요.')&#10;        elif strategy_name == 'VolatilityBreakout':&#10;            vb = strategy_params.get('VolatilityBreakout', {})&#10;            k_value = st.number_input('변동성 비율 k (0~1)', min_value=0.0, max_value=1.0, value=float(vb.get('k_value', 0.5)), help='지난 기간의 변동성에서 몇 퍼센트만큼 돌파를 보면 진입할지 정하는 수치예요. 0.5가 보통 사용됩니다.')&#10;            target_vol_pct_default = vb.get('target_vol_pct', cfg.get('vb_target_vol_pct', 30.0))&#10;            target_vol_pct = st.number_input('목표 변동성 비율 (%)', min_value=1.0, max_value=100.0, value=float(target_vol_pct_default), help='시장 변동성이 이 값 이상인지 보고 매매 여부를 판단해요.')&#10;        elif strategy_name == 'DualMomentum':&#10;            dm = strategy_params.get('DualMomentum', {})&#10;            window = st.number_input('모멘텀 계산 창 길이', min_value=1, value=int(dm.get('window', 12)), help='모멘텀을 계산할 때 몇 기간을 볼지 정해요. 숫자가 크면 더 긴 흐름을 봐요.')&#10;&#10;        # 기본 정보(전략 상세 바로 아래에 위치)&#10;        market = st.text_input('거래할 마켓 (예: KRW-BTC)', value=cfg.get('market', 'KRW-BTC'), help='어떤 코인을 거래할지 적어요. 예: KRW-BTC는 비트코인입니다.')&#10;        timeframe = st.text_input('캔들 시간 단위 (예: minute5)', value=cfg.get('timeframe', 'minute5'), help='한 개의 캔들이 몇 분/시간인지 적어요. 예: minute5 = 5분')&#10;        candle_count = st.number_input('캔들 개수(그래프 표시 길이)', min_value=1, value=int(cfg.get('candle_count', 200)), help='차트에 보여줄 과거 데이터의 개수예요. 숫자가 크면 긴 기간을 보여줘요.')&#10;        loop_interval_sec = st.number_input('루프 실행 간격(초)', min_value=1, value=int(cfg.get('loop_interval_sec', 5)), help='자동으로 확인할 때 몇 초마다 할지 정해요.')&#10;&#10;        st.subheader('주문 관련 설정 (돈/수량)')&#10;        order_settings = cfg.get('order_settings', {})&#10;        min_order_amount = st.number_input('최소 주문 금액 (원)', min_value=1000, value=int(order_settings.get('min_order_amount', 5500)), help='거래소에서 허용하는 최소 주문 금액이에요. 이 값보다 작으면 주문 못해요.')&#10;        trade_amount_krw = st.number_input('한 번 거래할 금액 (원)', min_value=1000, value=int(order_settings.get('trade_amount_krw', 6000)), help='한 번 매수할 때 쓰는 돈이에요. 예: 6000원')&#10;&#10;        st.subheader('켈리공식 (돈을 얼마나 쓸지 계산하는 방법)')&#10;        use_kelly = st.checkbox('켈리공식 사용하기', value=bool(cfg.get('use_kelly_criterion', True)), help='켈리공식을 사용하면 이길 확률과 수익비율로 한 번에 투자할 돈을 계산해줘요.')&#10;        kelly = cfg.get('kelly_criterion', {})&#10;        win_rate = st.number_input('승률 (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('win_rate', 0.65)), help='거래했을 때 이길 확률을 0부터 1 사이로 적어요. 예: 0.65 = 65%')&#10;        payoff_ratio = st.number_input('평균 이익/손실 비율', min_value=0.0, value=float(kelly.get('payoff_ratio', 1.2)), help='이길 때 평균 이익이 손실보다 몇 배인지 적어요. 예: 1.2면 이익이 손실의 1.2배')&#10;        fraction = st.number_input('적용 비율 (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('fraction', 0.5)), help='켈리로 계산한 금액 중 얼마만 실제로 쓸지 0~1로 적어요. 예: 0.5는 반만 사용')&#10;&#10;        submit = st.form_submit_button('미리보기 업데이트')&#10;&#10;        # --- Prefetch &amp; Cache settings ---&#10;        st.subheader('미리받기(캐시) 설정 — 서버가 데이터를 미리 모아놓는 방법')&#10;        prefetch_cfg = cfg.get('prefetch', {}) if isinstance(cfg.get('prefetch', {}), dict) else {}&#10;        # Top-level prefetch keys (stored at root level, not inside 'prefetch' for backward compatibility)&#10;        prefetch_count = st.number_input('미리 받을 캔들 수 (종목당)', min_value=1, value=int(cfg.get('prefetch_count', cfg.get('candle_count', 200))), help='서버가 각 종목에서 미리 받아둘 캔들 수예요. 그래프 길이에 영향을 줍니다.')&#10;        prefetch_interval_sec = st.number_input('미리수집 반복 간격(초)', min_value=1, value=int(cfg.get('prefetch_interval_sec', 30)), help='서버가 미리 데이터를 모으는 간격이에요. 숫자가 작으면 더 자주 업데이트합니다.')&#10;        prefetch_batch_size = st.number_input('한번에 모을 종목 수', min_value=1, value=int(cfg.get('prefetch_batch_size', 5)), help='한 번에 몇 종목씩 모을지 정해요. 너무 크면 호출이 몰려서 실패할 수 있어요.')&#10;        prefetch_parallelism = st.number_input('동시 작업 수(스레드)', min_value=1, value=int(cfg.get('prefetch_parallelism', 3)), help='몇 개의 작업을 동시에 실행할지 정해요. 숫자가 크면 빨라지지만 컴퓨터에 부담이 들어요.')&#10;        prefetch_sleep_sec = st.number_input('종목 사이 쉬는 시간(초)', min_value=0.0, value=float(cfg.get('prefetch_sleep_sec', 0.2)), help='한 종목을 처리한 뒤 잠깐 쉬는 시간이에요. 서버 과부하를 줄여요.')&#10;        prefetch_min_interval_sec = st.number_input('Redis 없을 때 최소 간격(초)', min_value=1, value=int(cfg.get('prefetch_min_interval_sec', 60)), help='Redis가 없으면 미리받기 사이 간격을 더 길게 해요.')&#10;        prefetch_no_redis_max_count = st.number_input('Redis 없을 때 최대 캔들 수', min_value=1, value=int(cfg.get('prefetch_no_redis_max_count', 120)), help='Redis가 없을 때는 너무 많이 가져오지 않도록 제한해요.')&#10;        prefetch_rate_per_sec = st.number_input('초당 허용 호출(토큰)', min_value=0.0, value=float(cfg.get('prefetch_rate_per_sec', 5)), help='초당 몇 번의 호출을 허용할지 토큰으로 정해요.')&#10;        prefetch_rate_capacity = st.number_input('버스트 허용 토큰(추가 여유)', min_value=1, value=int(cfg.get('prefetch_rate_capacity', int(prefetch_rate_per_sec or 1))), help='잠깐 동안 더 많은 호출을 허용할 수 있는 여유량이에요.')&#10;        prefetch_max_concurrent = st.number_input('최대 동시 작업 수', min_value=1, value=int(cfg.get('prefetch_max_concurrent', 3)), help='한 번에 병렬로 수행할 최대 작업 수예요.')&#10;        prefetch_token_wait_timeout = st.number_input('토큰 대기 최대 시간(초)', min_value=0.0, value=float(cfg.get('prefetch_token_wait_timeout', 10.0)), help='토큰을 기다리는 최대 시간이에요. 너무 작으면 실패할 수 있어요.')&#10;        # Cache TTL&#10;        klines_cache_ttl = st.number_input('차트 데이터 캐시 유지시간(초)', min_value=1, value=int(cfg.get('KLINES_CACHE_TTL', os.getenv('KLINES_CACHE_TTL', '600'))), help='서버가 저장해두는 데이터가 얼마나 오래 유지될지 초 단위로 적어요.')&#10;&#10;        # AI ensemble settings&#10;        st.subheader('AI 조합 방법 (여러 AI를 어떻게 합칠까?)')&#10;        ai_ensemble = cfg.get('ai_ensemble', {}) if isinstance(cfg.get('ai_ensemble', {}), dict) else {}&#10;        ai_strategy = st.selectbox('AI 합치는 방식', options=['UNANIMOUS', 'MAJORITY', 'AVERAGE'], index=0 if ai_ensemble.get('strategy') is None else ['UNANIMOUS','MAJORITY','AVERAGE'].index(ai_ensemble.get('strategy', 'UNANIMOUS')), help='여러 AI가 모두 같은 의견일 때만 따를지(UNANIMOUS), 과반수 의견을 따를지(MAJORITY), 평균을 낼지(AVERAGE) 골라요.')&#10;        openai_model = st.text_input('OpenAI 모델 이름', value=ai_ensemble.get('openai_model', cfg.get('OPENAI_MODEL', 'gpt-5.1-nano')), help='OpenAI에서 사용할 모델 이름을 적어요. 특별히 모르면 기본값 그대로 두세요.')&#10;        gemini_model = st.text_input('Gemini 모델 이름', value=ai_ensemble.get('gemini_model', cfg.get('GEMINI_MODEL', 'gemini-2.5-flash')), help='Gemini에서 사용할 모델 이름을 적어요. 모르면 기본값 사용')&#10;&#10;        # Universe (comma separated tickers)&#10;        st.subheader('관심 종목 목록 (우리가 볼 종목들)')&#10;        universe_list = cfg.get('universe')&#10;        if isinstance(universe_list, list):&#10;            universe_str = ','.join(universe_list)&#10;        else:&#10;            universe_str = str(universe_list or '')&#10;        universe_input = st.text_area('관심 종목 (콤마로 구분, 예: KRW-BTC,KRW-ETH)', value=universe_str, height=80, help='여기에 보고 싶은 종목들을 쉼표로 구분해서 적어요. 예: KRW-BTC,KRW-ETH')&#10;&#10;    new_cfg = {&#10;        'strategy_name': strategy_name,&#10;        'market': market,&#10;        'timeframe': timeframe,&#10;        'candle_count': candle_count,&#10;        'loop_interval_sec': loop_interval_sec,&#10;        'order_settings': {&#10;            'min_order_amount': min_order_amount,&#10;            'trade_amount_krw': trade_amount_krw,&#10;        },&#10;        'use_kelly_criterion': use_kelly,&#10;        'kelly_criterion': {&#10;            'win_rate': win_rate,&#10;            'payoff_ratio': payoff_ratio,&#10;            'fraction': fraction,&#10;        },&#10;        'strategy_params': {}&#10;    }&#10;&#10;    if strategy_name == 'RSI':&#10;        new_cfg['strategy_params']['RSI'] = {&#10;            'period': rsi_period,&#10;            'oversold': rsi_oversold,&#10;            'overbought': rsi_overbought,&#10;        }&#10;    elif strategy_name == 'VolatilityBreakout':&#10;        new_cfg['strategy_params']['VolatilityBreakout'] = {&#10;            'k_value': k_value,&#10;            'target_vol_pct': target_vol_pct,&#10;        }&#10;    elif strategy_name == 'DualMomentum':&#10;        new_cfg['strategy_params']['DualMomentum'] = {'window': window}&#10;&#10;    # attach AI ensemble and universe&#10;    new_cfg['ai_ensemble'] = {&#10;        'strategy': ai_strategy,&#10;        'openai_model': openai_model,&#10;        'gemini_model': gemini_model,&#10;    }&#10;    # parse universe string into list&#10;    universe_parsed = [s.strip() for s in universe_input.split(',') if s.strip()]&#10;    if universe_parsed:&#10;        new_cfg['universe'] = universe_parsed&#10;    else:&#10;        # keep existing if empty&#10;        if isinstance(cfg.get('universe'), list):&#10;            new_cfg['universe'] = cfg.get('universe')&#10;&#10;    st.divider()&#10;    st.header('설정 액션')&#10;    valid, message = validate_config(new_cfg)&#10;    if not valid:&#10;        st.error('유효성 검사 실패: ' + message)&#10;&#10;    col_a, col_b, col_c = st.columns(3)&#10;    with col_a:&#10;        if st.button('로컬에 저장'):&#10;            if not valid:&#10;                st.error('저장 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    save_local(new_cfg)&#10;                    st.success('저장 완료: runtime/config.json')&#10;                except Exception as e:&#10;                    st.error('로컬 저장 실패: ' + str(e))&#10;    with col_b:&#10;        if st.button('서버에 전송'):&#10;            if not valid:&#10;                st.error('전송 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    resp = api_request('post', '/config', json={'config': new_cfg}, timeout=10)&#10;                    st.success('서버에 전송 완료')&#10;                except Exception as e:&#10;                    st.error(str(e))&#10;    with col_c:&#10;        if st.button('서버 재로딩 요청'):&#10;            try:&#10;                resp = api_request('post', '/reload', timeout=5)&#10;                st.success('서버 재로딩 요청 성공')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;&#10;&#10;def render_ws_monitoring_page():&#10;    st.title('WebSocket 모니터링')&#10;    st.write('실시간 WebSocket 스트리밍 현황과 체결 기록을 한눈에 확인합니다.')&#10;&#10;    stats, stats_err = fetch_ws_stats()&#10;    if stats_err:&#10;        st.warning(f'WebSocket 통계 수집 오류: {stats_err}')&#10;        stats = None&#10;&#10;    if stats:&#10;        cols = st.columns(4)&#10;        metrics = (&#10;            ('시세 수신 성공', stats.get('ticker_success', 0)),&#10;            ('시세 수신 실패', stats.get('ticker_failure', 0)),&#10;            ('체결 수신 성공', stats.get('order_success', 0)),&#10;            ('체결 수신 실패', stats.get('order_failure', 0)),&#10;        )&#10;        for col, (label, value) in zip(cols, metrics):&#10;            col.metric(label, f&quot;{int(value):,}&quot;)&#10;        status_text = '실행 중' if stats.get('running') else '대기 중'&#10;        st.caption(&#10;            f&quot;WebSocket 상태: {status_text} · 구독 종목: {len(stats.get('targets', []))} · &quot;&#10;            f&quot;최근 1시간 시세 성공:{stats.get('last_hour_ticker_success', 0)}, 실패:{stats.get('last_hour_ticker_failure', 0)} / &quot;&#10;            f&quot;체결 성공:{stats.get('last_hour_order_success', 0)}, 실패:{stats.get('last_hour_order_failure', 0)}&quot;&#10;        )&#10;    else:&#10;        st.info('WebSocket 통계를 불러올 수 없습니다. 리스너 실행 여부를 확인해 주세요.')&#10;&#10;    st.divider()&#10;    st.subheader('WebSocket 제어')&#10;    btn_col1, btn_col2, btn_col3 = st.columns(3)&#10;    with btn_col1:&#10;        if st.button('WebSocket 시작', key='ws_ctrl_start'):&#10;            try:&#10;                api_request('post', '/ws/start', timeout=5)&#10;                st.success('WebSocket 리스너 시작 요청이 전송되었습니다.')&#10;            except Exception as exc:&#10;                st.error(f'WebSocket 시작 실패: {exc}')&#10;    with btn_col2:&#10;        if st.button('WebSocket 중지', key='ws_ctrl_stop'):&#10;            try:&#10;                api_request('post', '/ws/stop', timeout=5)&#10;                st.success('WebSocket 리스너 중지 요청이 전송되었습니다.')&#10;            except Exception as exc:&#10;                st.error(f'WebSocket 중지 실패: {exc}')&#10;    with btn_col3:&#10;        if st.button('상태 새로 고침', key='ws_ctrl_refresh'):&#10;            _trigger_rerun()&#10;&#10;    st.divider()&#10;    enabled = st.session_state.get(AUTO_REFRESH_KEY, False)&#10;    enabled = _render_autorefresh_button()&#10;    st.session_state[AUTO_REFRESH_KEY] = enabled&#10;    _apply_autorefresh_if_enabled()&#10;&#10;    st.subheader('분봉 수신 현황 (최근 10개)')&#10;    rows = []&#10;    if stats:&#10;        for item in stats.get('recent_ticker_events', []):&#10;            rows.append({&#10;                '시간': _format_ws_ts(item.get('ts')),&#10;                '종목': item.get('symbol') or '-',&#10;                '타입': item.get('type') or '-',&#10;                '현재가' : item.get('trade_price') or '-',&#10;                '결과': '성공' if item.get('success') else '실패',&#10;            })&#10;    if rows:&#10;        _safe_dataframe(pd.DataFrame(rows), hide_index=True)&#10;    else:&#10;        st.info('최근 분봉 수신 기록이 없습니다.')&#10;&#10;    st.subheader('심볼별 최신 티커 정보 (5초 자동 갱신)')&#10;    ticker_data, ticker_err = fetch_ws_ticker_data()&#10;    if ticker_err:&#10;        st.warning(f'티커 데이터 조회 오류: {ticker_err}')&#10;    elif ticker_data and isinstance(ticker_data.get('tickers'), list):&#10;        df_tickers = pd.DataFrame(ticker_data['tickers'])&#10;        if not df_tickers.empty:&#10;            df_tickers = df_tickers.rename(columns={&#10;                'symbol': '심볼',&#10;                'opening_price': '시가',&#10;                'high_price': '고가',&#10;                'low_price': '저가',&#10;                'trade_price': '현재가',&#10;                'prev_closing_price': '전일종가',&#10;                'change': '전일대비변동',&#10;            })&#10;            if 'timestamp' in df_tickers.columns:&#10;                df_tickers['최근 수신'] = df_tickers['timestamp'].apply(_format_ws_ts)&#10;            display_cols = ['심볼', '시가', '고가', '저가', '현재가', '전일종가', '전일대비변동', '최근 수신']&#10;            available_cols = [c for c in display_cols if c in df_tickers.columns]&#10;            df_display = df_tickers[available_cols]&#10;            _safe_dataframe(df_display.fillna('-'), hide_index=True)&#10;        else:&#10;            st.info('티커 데이터가 아직 없습니다.')&#10;    else:&#10;        if ticker_err is None:&#10;            st.info('티커 데이터 로딩 대기 중입니다.')&#10;&#10;    st.subheader('체결 수신 현황 (exec_history)')&#10;    executions, exec_err = fetch_ws_executions()&#10;    exec_table = []&#10;    if exec_err:&#10;        st.warning(f'체결 기록 조회 오류: {exec_err}')&#10;    elif executions and isinstance(executions.get('executions'), list):&#10;        data = executions['executions']&#10;        for entry in sorted(data, key=lambda e: e.get('ts', 0), reverse=True):&#10;            exec_table.append({&#10;                '시간': _format_ws_ts(entry.get('ts')),&#10;                '심볼': entry.get('symbol') or '-',&#10;                '사이드': entry.get('side') or entry.get('ask_bid') or '-',&#10;                '체결가': entry.get('price') or entry.get('order_price') or '-',&#10;                '수량': entry.get('size') or entry.get('trade_volume') or '-',&#10;                '장부가': entry.get('entry_price') or '-',&#10;            })&#10;    if exec_table:&#10;        try:&#10;            df_exec = pd.DataFrame(exec_table)&#10;            def _format_side(label: str) -&gt; str:&#10;                try:&#10;                    key = str(label or '').strip().lower()&#10;                except Exception:&#10;                    return label&#10;                if key in ('ask', 'sell', '매도'):&#10;                    return '매도'&#10;                if key in ('bid', 'buy', '매수'):&#10;                    return '매수'&#10;                return label&#10;            if '사이드' in df_exec.columns:&#10;                df_exec['사이드'] = df_exec['사이드'].map(_format_side)&#10;            _safe_dataframe(df_exec, hide_index=True)&#10;        except Exception:&#10;            st.write(exec_table)&#10;    else:&#10;        if not exec_err:&#10;            st.info('체결 기록이 없습니다. WebSocket 리스너가 실행 중인지 확인하세요.')&#10;&#10;&#10;def render_screening_page():&#10;    st.title('종목 스크리닝')&#10;    st.caption('변동성 TOP 종목을 조회합니다. (최근 캔들 기준)')&#10;    st.code('변동성은 (max_high - min_low) / mean_close 로 계산됩니다.')&#10;&#10;    # Controls moved into the page (previously in sidebar)&#10;    ctrl_col1, ctrl_col2, ctrl_col3 = st.columns([1,1,1])&#10;    market_prefix = ctrl_col1.text_input('마켓 접두사 (예: KRW)', value='KRW', key='scr_market_prefix')&#10;    top_n = ctrl_col2.number_input('Top N', min_value=1, max_value=50, value=10, key='scr_top_n')&#10;    # timeframe placed in the third column for grouping&#10;    timeframe = ctrl_col3.selectbox('Timeframe', options=['minute5','minute15','minute60','day'], index=1, key='scr_timeframe')&#10;&#10;    # Place the search button in a dedicated full-width row so it spans the page&#10;    full_row = st.columns([1])[0]&#10;    try:&#10;        # Use width='stretch' when supported&#10;        search_clicked = full_row.button('조회', key='scr_search', width='stretch')&#10;    except TypeError:&#10;        # Fallback for older Streamlit versions&#10;        search_clicked = full_row.button('조회', key='scr_search')&#10;&#10;    # When search clicked, fetch data and then render charts below&#10;    if 'search_clicked' not in st.session_state:&#10;        st.session_state['search_clicked'] = False&#10;    if search_clicked:&#10;        st.session_state['search_clicked'] = True&#10;        st.session_state['screening_query'] = {&#10;            'market_prefix': market_prefix,&#10;            'top_n': top_n,&#10;            'timeframe': timeframe,&#10;        }&#10;&#10;    if not st.session_state.get('search_clicked'):&#10;        st.info('조회 버튼을 눌러 변동성 TOP 종목을 검색하세요.')&#10;        return&#10;&#10;    # read query&#10;    query = st.session_state.get('screening_query', {})&#10;    market_prefix = query.get('market_prefix', 'KRW')&#10;    requested_n = int(query.get('top_n', 10))&#10;    timeframe = query.get('timeframe', 'minute15')&#10;&#10;    with st.spinner('변동성 TOP 종목 조회 중...'):&#10;        # Try multiple backend endpoints for compatibility&#10;        candidate_paths = [&#10;            ('post', '/screening/top_volatility'),&#10;            ('get', '/screen/volatility_top'),&#10;            ('get', '/screen/volatility_top'),&#10;        ]&#10;        tickers = []&#10;        last_exception = None&#10;        for method, path in candidate_paths:&#10;            try:&#10;                if method == 'get':&#10;                    resp = api_request('get', path, params={'market_prefix': market_prefix, 'top_n': requested_n, 'timeframe': timeframe}, timeout=8)&#10;                else:&#10;                    resp = api_request('post', path, json={'market_prefix': market_prefix, 'top_n': requested_n, 'timeframe': timeframe}, timeout=10)&#10;                j = resp.json()&#10;                # support different key names&#10;                tickers = j.get('tickers') or j.get('top') or j.get('top_tickers') or j.get('top', [])&#10;                # if server returns objects, try to extract ticker strings&#10;                if tickers and isinstance(tickers, list) and isinstance(tickers[0], dict):&#10;                    # expect dict with 'ticker' or 'symbol'&#10;                    tickers = [it.get('ticker') or it.get('symbol') or it.get('market') for it in tickers]&#10;                # filter empties&#10;                tickers = [t for t in (tickers or []) if t]&#10;                if tickers:&#10;                    break&#10;            except Exception as e:&#10;                last_exception = e&#10;                continue&#10;&#10;        if not tickers:&#10;            if last_exception:&#10;                st.error(f'스케리닝 조회 실패: {last_exception}')&#10;            else:&#10;                st.warning('조건에 맞는 종목이 없습니다.')&#10;            return&#10;&#10;        # fetch klines in batch&#10;        backend_data = fetch_klines_batch_from_backend(tickers, timeframe=timeframe, count=200)&#10;&#10;        # Compute volatility (%) per ticker from backend_data and show a ranked table&#10;        vol_rows = []&#10;        for t in tickers:&#10;            dfk = backend_data.get(t)&#10;            dfk_norm = _normalize_klines_df(dfk, min_length=5)&#10;            vol = compute_volatility_from_df(dfk_norm)&#10;            vol_rows.append({'ticker': t, 'volatility_pct': None if vol is None else float(vol)})&#10;        try:&#10;            df_top = pd.DataFrame(vol_rows)&#10;            # sort by volatility (ascending), NaNs at the end&#10;            df_top = df_top.sort_values('volatility_pct', ascending=False, na_position='last').reset_index(drop=True)&#10;            df_top.insert(0, 'rank', range(1, len(df_top) + 1))&#10;            # pretty formatting column&#10;            def _fmt(v):&#10;                try:&#10;                    if v is None or (isinstance(v, float) and (pd.isna(v))):&#10;                        return '-'&#10;                    return f&quot;{float(v):.2f}%&quot;&#10;                except Exception:&#10;                    return '-'&#10;            df_top['변동성(%)'] = df_top['volatility_pct'].apply(_fmt)&#10;            df_display = df_top[['rank','ticker','변동성(%)']]&#10;            _safe_dataframe(df_display, hide_index=True)&#10;        except Exception as e:&#10;            st.warning(f'상단 변동성 표 생성 중 오류: {e}')&#10;&#10;        # Diagnostics: show which tickers have data and which not&#10;        missing = []&#10;        insufficient = []&#10;        for t in tickers:&#10;            df = backend_data.get(t)&#10;            if df is None:&#10;                missing.append(t)&#10;            else:&#10;                try:&#10;                    if hasattr(df, 'shape') and df.shape[0] &lt; 10:&#10;                        insufficient.append((t, int(df.shape[0])))&#10;                except Exception:&#10;                    pass&#10;        if missing:&#10;            st.warning(f&quot;데이터가 없는 종목: {', '.join(missing)} (백엔드가 캐시를 아직 채우지 않았거나 수집 실패)&quot;)&#10;        if insufficient:&#10;            st.info('샘플이 적은 종목: ' + ', '.join([f&quot;{t}({n})&quot; for t,n in insufficient]))&#10;&#10;        # Render a grid: 5 rows x 2 cols (max 10)&#10;        max_slots = requested_n&#10;        display_items = tickers[:max_slots]&#10;        display_n = len(display_items)&#10;        rows = (max_slots + 1) // 2&#10;        idx = 0&#10;        for r in range(rows):&#10;            cols = st.columns(2, gap='small')&#10;            for c in range(2):&#10;                if idx &gt;= display_n:&#10;                    with cols[c]:&#10;                        st.empty()&#10;                    idx += 1&#10;                    continue&#10;                ticker = display_items[idx]&#10;                with cols[c]:&#10;                    st.subheader(f&quot;{idx+1}. {ticker}&quot;)&#10;                    df = backend_data.get(ticker)&#10;                    df = _normalize_klines_df(df, min_length=30)&#10;                    if df is None or (hasattr(df, 'empty') and df.empty):&#10;                        st.info('차트 데이터를 불러올 수 없습니다. (백엔드 캐시 또는 수집 상태를 확인하세요)')&#10;                    else:&#10;                        # smaller chart per grid cell&#10;                        fig = plot_candles_with_indicators(df, ticker, ma_windows=[20, 60], rsi_period=14)&#10;                        fig.update_layout(height=320, margin=dict(l=8, r=8, t=24, b=12))&#10;                        _safe_plotly_chart(fig)&#10;                idx += 1&#10;        st.caption(f&quot;표시된 종목: {display_n} / 요청한 TopN: {requested_n}&quot;)&#10;&#10;&#10;def render_positions_page():&#10;    st.title('원화잔고 및 포지션 분석')&#10;    st.write('원화 잔고와 보유 포지션을 요약하고 간단한 시각화를 제공합니다.')&#10;&#10;    balances = None&#10;    positions = None&#10;    positions_payload: Dict[str, Any] = {}&#10;    api_errors: list[str] = []&#10;&#10;    # Try dedicated endpoints first&#10;    reported_krw_from_server = 0.0&#10;    balances_response_meta = {}&#10;    try:&#10;        resp = api_request('get', '/balances', timeout=6)&#10;        if resp and resp.status_code == 200:&#10;            j = resp.json()&#10;            # API returns {'balances': [...], 'reported_krw_balance':..., 'cached':..., 'cached_ts':...}&#10;            if isinstance(j, dict):&#10;                balances = j.get('balances') if 'balances' in j else j&#10;                reported_krw_from_server = float(j.get('reported_krw_balance') or 0.0)&#10;                balances_response_meta = {k: j.get(k) for k in ('cached','cached_ts') if k in j}&#10;            else:&#10;                balances = j&#10;    except Exception as e:&#10;        api_errors.append(f&quot;/balances 호출 실패: {e}&quot;)&#10;&#10;    try:&#10;        resp2 = api_request('get', '/positions', timeout=6)&#10;        if resp2 and resp2.status_code == 200:&#10;            j2 = resp2.json()&#10;            if isinstance(j2, dict):&#10;                positions_payload = j2&#10;                positions = j2.get('positions')&#10;            else:&#10;                positions = j2&#10;    except Exception as e:&#10;        api_errors.append(f&quot;/positions 호출 실패: {e}&quot;)&#10;&#10;    # If both endpoints failed, try returning /status for diagnostics&#10;    if balances is None and positions is None:&#10;        try:&#10;            resp3 = api_request('get', '/debug/status', timeout=4)&#10;            if resp3 and resp3.status_code == 200:&#10;                st.info('백엔드 상태:')&#10;                st.json(resp3.json())&#10;        except Exception:&#10;            pass&#10;&#10;    # Show API warnings (but avoid noisy raw exceptions)&#10;    for err in api_errors:&#10;        if 'keys not configured' in err or '503' in err:&#10;            st.warning('서버에 API 키가 설정되지 않아 잔고를 조회할 수 없습니다. (관리자 설정 필요)')&#10;        else:&#10;            st.info(err)&#10;&#10;    # Normalize balances into DataFrame&#10;    try:&#10;        if balances and isinstance(balances, list):&#10;            bal_df = pd.DataFrame(balances)&#10;        elif balances and isinstance(balances, dict):&#10;            # sometimes API returns map&#10;            bal_df = pd.DataFrame(balances.get('balances') if 'balances' in balances else [balances])&#10;        else:&#10;            bal_df = pd.DataFrame(columns=['currency', 'balance', 'locked', 'avg_buy_price'])&#10;&#10;        # Accept multiple possible field names and normalize&#10;        if 'currency' not in bal_df.columns and 'unit' in bal_df.columns:&#10;            bal_df = bal_df.rename(columns={'unit': 'currency'})&#10;        if 'currency' not in bal_df.columns and 'coin' in bal_df.columns:&#10;            bal_df = bal_df.rename(columns={'coin': 'currency'})&#10;&#10;        # numeric conversions&#10;        for col in ('balance', 'locked', 'avg_buy_price'):&#10;            if col in bal_df.columns:&#10;                bal_df[col] = pd.to_numeric(bal_df[col], errors='coerce')&#10;&#10;        # If currency column named differently&#10;        if 'currency' not in bal_df.columns and 'currency_name' in bal_df.columns:&#10;            bal_df = bal_df.rename(columns={'currency_name': 'currency'})&#10;&#10;    except Exception:&#10;        bal_df = pd.DataFrame(columns=['currency', 'balance', 'locked', 'avg_buy_price'])&#10;&#10;    # Normalize positions&#10;    try:&#10;        if positions and isinstance(positions, list):&#10;            pos_df = pd.DataFrame(positions)&#10;        elif positions and isinstance(positions, dict):&#10;            pos_df = pd.DataFrame(positions.get('positions') if 'positions' in positions else [positions])&#10;        else:&#10;            pos_df = pd.DataFrame(columns=['symbol','side','qty','entry_price','unrealized_pnl'])&#10;        # common conversions&#10;        for c in ['qty','entry_price','unrealized_pnl','unrealized_pnl_usdt','avg_price']:&#10;            if c in pos_df.columns:&#10;                pos_df[c] = pd.to_numeric(pos_df[c], errors='coerce')&#10;        if 'unrealized_pnl' not in pos_df.columns and 'unrealized_pnl_usdt' in pos_df.columns:&#10;            pos_df['unrealized_pnl'] = pos_df['unrealized_pnl_usdt']&#10;        if 'symbol' not in pos_df.columns and 'ticker' in pos_df.columns:&#10;            pos_df = pos_df.rename(columns={'ticker':'symbol'})&#10;        if 'side' not in pos_df.columns:&#10;            for cand in ('position_side','direction'):&#10;                if cand in pos_df.columns:&#10;                    pos_df['side'] = pos_df[cand]&#10;                    break&#10;    except Exception:&#10;        pos_df = pd.DataFrame(columns=['symbol','side','qty','entry_price','unrealized_pnl'])&#10;&#10;    # Fetch history for chart&#10;    history = []&#10;    try:&#10;        resp_hist = api_request('get', '/positions/history', timeout=8)&#10;        if resp_hist and resp_hist.status_code == 200:&#10;            history = resp_hist.json().get('history', []) or []&#10;    except Exception:&#10;        history = []&#10;&#10;    # Compute KRW-equivalent values for balances using backend price fetch&#10;    try:&#10;        bal_df = bal_df.copy()&#10;        bal_df['currency'] = bal_df['currency'].astype(str)&#10;        # build market tickers for non-KRW currencies (e.g., BTC -&gt; KRW-BTC)&#10;        markets = []&#10;        currency_to_market = {}&#10;        for cur in bal_df['currency'].unique():&#10;            cur_up = cur.upper()&#10;            if cur_up == 'KRW' or cur_up.startswith('KRW'):&#10;                continue&#10;            market = f&quot;KRW-{cur_up}&quot;&#10;            markets.append(market)&#10;            currency_to_market[cur_up] = market&#10;&#10;        price_map: dict = {}&#10;        if markets:&#10;            # fetch latest close price for those markets via backend batch (count=1)&#10;            try:&#10;                kline_map = fetch_klines_batch_from_backend(markets, timeframe='minute1', count=1)&#10;                for m, df in kline_map.items():&#10;                    price = None&#10;                    try:&#10;                        if df is not None and hasattr(df, 'empty') and not df.empty and 'close' in df.columns:&#10;                            # get last available close&#10;                            price = float(df['close'].iloc[-1])&#10;                    except Exception:&#10;                        price = None&#10;                    price_map[m] = price&#10;            except Exception:&#10;                price_map = {}&#10;&#10;        # add price_krw and value_krw columns&#10;        def _get_price_krw(cur):&#10;            try:&#10;                cu = str(cur).upper()&#10;                if cu == 'KRW' or cu.startswith('KRW'):&#10;                    return 1.0&#10;                m = currency_to_market.get(cu)&#10;                if not m:&#10;                    return None&#10;                return price_map.get(m)&#10;            except Exception:&#10;                return None&#10;&#10;        bal_df['price_krw'] = bal_df['currency'].apply(_get_price_krw)&#10;        # value_krw: for KRW currency, balance is already KRW; otherwise balance * price_krw&#10;        def _compute_value(row):&#10;            try:&#10;                bal = float(row.get('balance') or 0)&#10;            except Exception:&#10;                bal = 0.0&#10;            pr = row.get('price_krw')&#10;            cur = str(row.get('currency') or '').upper()&#10;            if cur == 'KRW' or cur.startswith('KRW'):&#10;                return bal&#10;            if pr is None:&#10;                return None&#10;            return bal * float(pr)&#10;&#10;        bal_df['value_krw'] = bal_df.apply(_compute_value, axis=1)&#10;&#10;    except Exception:&#10;        # fallback to original simple KRW sum&#10;        bal_df['price_krw'] = None&#10;        bal_df['value_krw'] = None&#10;&#10;    # Top metrics: use server-reported KRW cash and compute converted asset value from available prices only&#10;    available_krw_payload = float(positions_payload.get('available_krw') or 0.0)&#10;    total_equity_payload = float(positions_payload.get('total_equity_krw') or 0.0)&#10;    excluded_assets = positions_payload.get('excluded_assets') or []&#10;    krw_cash = float(available_krw_payload or reported_krw_from_server or 0.0)&#10;    conv_sum = total_equity_payload if total_equity_payload else 0.0&#10;    try:&#10;        if not bal_df.empty and 'value_krw' in bal_df.columns and 'currency' in bal_df.columns:&#10;            # only include non-KRW assets where value_krw is a real number (not None/NaN)&#10;            nonkrw = bal_df[~bal_df['currency'].astype(str).str.upper().str.contains('KRW', na=False)]&#10;            conv_sum = float(nonkrw['value_krw'].dropna().sum())&#10;    except Exception:&#10;        conv_sum = 0.0&#10;&#10;    # Compute total unrealized PnL&#10;    total_unrealized = 0.0&#10;    try:&#10;        if not pos_df.empty and 'unrealized_pnl' in pos_df.columns:&#10;            total_unrealized = pos_df['unrealized_pnl'].dropna().sum()&#10;    except Exception:&#10;        total_unrealized = 0.0&#10;&#10;    c1, c2, c3 = st.columns(3)&#10;    c1.metric('원화 현금 잔고', f&quot;{krw_cash:,.0f} 원&quot;)&#10;    c2.metric('평가자산 총액(원)', f&quot;{(total_equity_payload or (krw_cash + conv_sum)):,.0f} 원&quot;)&#10;    c3.metric('총 미확정 손익', f&quot;{total_unrealized:,.0f} 원&quot;)&#10;&#10;    # Show balances table with KRW conversion columns&#10;    try:&#10;        # Prepare display dataframe&#10;        if not bal_df.empty:&#10;            disp = bal_df[['currency', 'balance', 'price_krw', 'value_krw']].copy()&#10;&#10;            def _fmt_amount(v):&#10;                try:&#10;                    if v is None or (isinstance(v, float) and pd.isna(v)):&#10;                        return '-'&#10;                    f = float(v)&#10;                    if abs(f) &gt;= 1:&#10;                        return f&quot;{f:,.0f}&quot;&#10;                    return f&quot;{f:.8f}&quot;&#10;                except Exception:&#10;                    return str(v)&#10;&#10;            def _fmt_price(v):&#10;                try:&#10;                    if v is None or (isinstance(v, float) and pd.isna(v)):&#10;                        return '-'&#10;                    f = float(v)&#10;                    if f &gt;= 1:&#10;                        return f&quot;{f:,.0f}&quot;&#10;                    return f&quot;{f:.8f}&quot;&#10;                except Exception:&#10;                    return str(v)&#10;&#10;            disp['잔고'] = disp['balance'].apply(_fmt_amount)&#10;            disp['현재가(원)'] = disp['price_krw'].apply(_fmt_price)&#10;            disp['가치(원)'] = disp['value_krw'].apply(lambda v: _fmt_amount(v) if v is not None and not pd.isna(v) else '-')&#10;            disp = disp.rename(columns={'currency': '화폐'})&#10;            disp = disp[['화폐', '잔고', '현재가(원)', '가치(원)']]&#10;            _safe_dataframe(disp, hide_index=True)&#10;&#10;            # show total caption and note missing price entries&#10;            missing_prices = bal_df[bal_df['value_krw'].isna() &amp; ~bal_df['currency'].astype(str).str.upper().str.contains('KRW')]['currency'].tolist()&#10;            st.caption(f&quot;추정 포트폴리오 총액(원화, 현금+환산): {krw_cash+conv_sum:,.0f} 원&quot;)&#10;            if missing_prices:&#10;                st.info(f&quot;아래 종목은 현재가가 없어 환산에서 제외되었습니다: {', '.join(missing_prices)}&quot;)&#10;        else:&#10;            st.info('잔고 정보가 없습니다.')&#10;    except Exception as e:&#10;        st.warning(f'잔고 테이블 표시 중 오류: {e}')&#10;&#10;    st.divider()&#10;&#10;    # Positions table and PnL chart&#10;    try:&#10;        if pos_df.empty:&#10;            st.info('보유 포지션이 없습니다.')&#10;        else:&#10;            # ensure required columns exist even if backend omits them&#10;            required_cols = ['symbol', 'size', 'entry_price', 'current_price', 'unrealized_pnl', 'unrealized_pnl_rate', 'notional_krw']&#10;            for col in required_cols:&#10;                if col not in pos_df.columns:&#10;                    pos_df[col] = None&#10;            disp = pos_df[required_cols].copy()&#10;            disp = disp.rename(columns={&#10;                'symbol': '종목티커',&#10;                'size': '수량',&#10;                'entry_price': '진입가격',&#10;                'current_price': '현재가격',&#10;                'unrealized_pnl': '평가손익',&#10;                'unrealized_pnl_rate': '손익비율',&#10;                'notional_krw': '평가금액',&#10;            })&#10;            for col in ('수량','진입가격','현재가격','평가손익','평가금액'):&#10;                disp[col] = disp[col].map(lambda v: f&quot;{float(v):,.0f}&quot; if v not in (None, '') and pd.notna(v) else '-')&#10;            disp['손익비율'] = disp['손익비율'].map(lambda v: f&quot;{float(v):.2f}%&quot; if v not in (None, '') and pd.notna(v) else '-')&#10;            _safe_dataframe(disp, hide_index=True)&#10;            if excluded_assets:&#10;                symbols = [item.get('symbol') for item in excluded_assets if isinstance(item, dict) and item.get('symbol')]&#10;                if symbols:&#10;                    st.info(f&quot;현재가 미수신으로 제외된 종목: {', '.join(symbols)}&quot;)&#10;            st.caption(f&quot;산출된 포지션: {len(disp)}개 · 가격 조회된 종목: {positions_payload.get('prices_fetched', 0)}개&quot;)&#10;            if history:&#10;                chart_cols = st.columns(2)&#10;                line_rows = []&#10;                for record in sorted(history, key=lambda item: item.get('ts', 0)):&#10;                    ts_value = float(record.get('ts', 0))&#10;                    row = {'date': pd.to_datetime(ts_value, unit='s', errors='coerce')}&#10;                    for snapshot in record.get('positions', []):&#10;                        symbol = snapshot.get('symbol')&#10;                        notional = snapshot.get('notional_krw')&#10;                        if symbol and notional is not None:&#10;                            row[symbol] = float(notional)&#10;                    line_rows.append(row)&#10;                if line_rows:&#10;                    line_df = pd.DataFrame(line_rows).set_index('date').sort_index()&#10;                else:&#10;                    line_df = pd.DataFrame()&#10;&#10;                # Time-series line chart for position values&#10;                with chart_cols[0]:&#10;                    st.subheader('포지션 가치 추이')&#10;                    if line_df.empty:&#10;                        st.info('포지션 가치 변화 차트에 사용할 데이터가 없습니다.')&#10;                    else:&#10;                        fig_line = go.Figure()&#10;                        for sym in line_df.columns:&#10;                            if sym == 'date':&#10;                                continue&#10;                            fig_line.add_trace(go.Scatter(&#10;                                x=line_df.index,&#10;                                y=line_df[sym],&#10;                                mode='lines',&#10;                                name=sym,&#10;                                hovertemplate='%{x}&lt;br&gt;%{y:,.0f} 원&lt;extra&gt;&lt;/extra&gt;'&#10;                            ))&#10;                        fig_line.update_layout(title='포지션별 가치 변화', xaxis_title='날짜', yaxis_title='가치 (KRW)', margin=dict(l=10,r=10,t=30,b=30), height=320)&#10;                        _safe_plotly_chart(fig_line)&#10;&#10;                # Bar chart for unrealized PnL&#10;                with chart_cols[1]:&#10;                    st.subheader('포지션별 손익 현황')&#10;                    pnl_df = pos_df[['symbol','unrealized_pnl']].copy()&#10;                    pnl_df = pnl_df.sort_values('unrealized_pnl')&#10;                    if pnl_df['unrealized_pnl'].dropna().empty:&#10;                        st.info('손익 차트에 사용할 데이터가 부족합니다.')&#10;                    else:&#10;                        colors = ['#d64f3a' if v&gt;0 else '#1e40af' for v in pnl_df['unrealized_pnl'].fillna(0)]&#10;                        fig_bar = go.Figure()&#10;                        fig_bar.add_trace(go.Bar(&#10;                            x=pnl_df['symbol'],&#10;                            y=pnl_df['unrealized_pnl'],&#10;                            marker_color=colors,&#10;                            name='평가손익',&#10;                            hovertemplate='%{x}&lt;br&gt;%{y:,.0f}원&lt;extra&gt;&lt;/extra&gt;'&#10;                        ))&#10;                        fig_bar.update_layout(title='포지션별 손익', xaxis_title='종목', yaxis_title='손익 (원)', bargap=0.2, margin=dict(l=10,r=10,t=30,b=30), height=320)&#10;                        fig_bar.update_yaxes(zeroline=True, zerolinewidth=2, zerolinecolor='#94a3b8')&#10;                        _safe_plotly_chart(fig_bar)&#10;    except Exception as e:&#10;        st.error(f'포지션 표시 중 오류: {e}')&#10;&#10;&#10;def fetch_ai_history(limit: int = 100):&#10;    try:&#10;        resp = api_request('get', '/ai/history', params={'limit': limit}, timeout=10)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def fetch_bot_status():&#10;    try:&#10;        resp = api_request('get', '/bot/status', timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def update_bot_control_api(enabled: Optional[bool] = None, interval_sec: Optional[float] = None):&#10;    payload = {}&#10;    if enabled is not None:&#10;        payload['enabled'] = enabled&#10;    if interval_sec is not None:&#10;        payload['interval_sec'] = interval_sec&#10;    if not payload:&#10;        return None, RuntimeError('enabled 또는 interval_sec 중 하나가 필요합니다.')&#10;    try:&#10;        resp = api_request('post', '/bot/control', json=payload, timeout=10)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def render_bot_control_page():&#10;    st.title('자동매매봇 관리')&#10;    st.write('서버의 trading_bot 실행 여부, 검사 주기 등을 바꿀 수 있는 제어 화면입니다.')&#10;    status, err = fetch_bot_status()&#10;    if err:&#10;        st.error(f'봇 상태 조회 실패: {err}')&#10;        status = {}&#10;    enabled = bool(status.get('bot_enabled'))&#10;    interval = float(status.get('bot_interval_sec', cfg.get('loop_interval_sec', 5)))&#10;    st.metric('자동매매 허용', '활성' if enabled else '중지됨')&#10;    st.metric('검사 주기(초)', f'{interval:.1f}')&#10;&#10;    with st.form('bot_control_form'):&#10;        desired_interval = st.number_input('리플레이 주기 (초)', min_value=0.5, value=interval, step=0.5)&#10;        col1, col2, col3 = st.columns(3)&#10;        start = col1.form_submit_button('봇 시작')&#10;        stop = col2.form_submit_button('봇 중지')&#10;        update = col3.form_submit_button('주기 저장')&#10;        if start:&#10;            _, err = update_bot_control_api(enabled=True, interval_sec=desired_interval)&#10;            if err:&#10;                st.error(f'시작 실패: {err}')&#10;            else:&#10;                st.success('봇 시작 요청 완료')&#10;                _trigger_rerun()&#10;        if stop:&#10;            _, err = update_bot_control_api(enabled=False)&#10;            if err:&#10;                st.error(f'중지 실패: {err}')&#10;            else:&#10;                st.warning('봇 정지 요청 완료')&#10;                _trigger_rerun()&#10;        if update:&#10;            _, err = update_bot_control_api(interval_sec=desired_interval)&#10;            if err:&#10;                st.error(f'주기 업데이트 실패: {err}')&#10;            else:&#10;                st.success('주기를 저장했습니다.')&#10;                _trigger_rerun()&#10;&#10;    st.caption('설정을 바꾼 이후에는 trading_bot 또는 config 재로딩을 확인하세요.')&#10;&#10;&#10;def render_ai_report_page():&#10;    st.title('AI 자문 리포트')&#10;    st.caption('OpenAI와 Gemini가 내린 최신 자문 결과를 한눈에 확인합니다.')&#10;&#10;    history_payload, history_err = fetch_ai_history(limit=100)&#10;    if history_err:&#10;        st.error(f'AI 자문 이력 조회 실패: {history_err}')&#10;        return&#10;&#10;    items = history_payload.get('items') if isinstance(history_payload, dict) else None&#10;    if not items:&#10;        st.info('AI 자문 이력이 아직 없습니다. 봇을 실행해 기록을 쌓아주세요.')&#10;        return&#10;&#10;    latest = items[-1]&#10;    openai_payload = _get_ai_source_payload(latest, 'openai')&#10;    gemini_payload = _get_ai_source_payload(latest, 'gemini')&#10;    latest_ts = _format_ts_kst(latest.get('ts'))&#10;    st.subheader(f'1) 최신 자문 비교 (생성: {latest_ts})')&#10;    latest_cols = st.columns(2, gap='large')&#10;&#10;    def _render_model_card(col, label: str, payload: Dict[str, Any] | None):&#10;        with col:&#10;            st.markdown(f&quot;### {label}&quot;)&#10;            if not payload:&#10;                st.info('데이터 없음')&#10;                return&#10;            decision = payload.get('decision') or payload.get('action') or 'N/A'&#10;            st.metric('결정', decision)&#10;            confidence = _get_ai_confidence(payload)&#10;            conf_str = _format_confidence(confidence)&#10;            if conf_str != '-':&#10;                st.caption(f&quot;신뢰도: {conf_str}&quot;)&#10;            st.caption(f&quot;모델: {payload.get('model', '-')}&quot;)&#10;            reasoning = payload.get('reason') or payload.get('reasoning')&#10;            if reasoning:&#10;                st.write(reasoning)&#10;            with st.expander('원문 JSON 보기', expanded=False):&#10;                st.json(payload)&#10;&#10;    _render_model_card(latest_cols[0], 'OpenAI', openai_payload)&#10;    _render_model_card(latest_cols[1], 'Gemini', gemini_payload)&#10;&#10;    st.subheader('2) 입력 캔들 차트')&#10;    chart_df = _prepare_ai_chart_df(latest)&#10;    if chart_df is None or chart_df.empty:&#10;        st.info('차트 데이터가 없습니다. 마지막 기록에서는 `klines` 필드가 비어 있으므로 차트를 그릴 수 없습니다. `runtime/history/ai_decisions.json`을 확인해서 실제 캔들 데이터를 포함하도록 봇 설정을 조정하세요.')&#10;    else:&#10;        chart_fig = plot_candles_with_indicators(chart_df, cfg.get('market', 'KRW-BTC'), ma_windows=[20, 60], rsi_period=14)&#10;        chart_fig.update_layout(height=520)&#10;        _safe_plotly_chart(chart_fig)&#10;&#10;    st.subheader('3) 입력 전문')&#10;    with st.expander('입력 JSON', expanded=False):&#10;        context_payload = latest.get('context') or {}&#10;        if isinstance(context_payload, str):&#10;            context_payload = _parse_json_field(context_payload)&#10;        st.json(context_payload)&#10;&#10;    st.subheader('4) 자문 히스토리')&#10;    history_rows = []&#10;    for item in reversed(items):&#10;        history_openai = _get_ai_source_payload(item, 'openai')&#10;        history_gemini = _get_ai_source_payload(item, 'gemini')&#10;        history_rows.append({&#10;            '시각(KST)': _format_ts_kst(item.get('ts')),&#10;            '최종 결정': item.get('decision'),&#10;            '사유': item.get('reason'),&#10;            'OpenAI': history_openai.get('decision') if history_openai else '-',&#10;            'OpenAI 신뢰도': _format_confidence(_get_ai_confidence(history_openai)) if history_openai else '-',&#10;            'Gemini': history_gemini.get('decision') if history_gemini else '-',&#10;            'Gemini 신뢰도': _format_confidence(_get_ai_confidence(history_gemini)) if history_gemini else '-',&#10;        })&#10;    df_history = pd.DataFrame(history_rows)&#10;    _safe_dataframe(df_history.fillna('-'), hide_index=True)&#10;&#10;&#10;def _format_confidence(value: Any) -&gt; str:&#10;    if value is None:&#10;        return '-'&#10;    try:&#10;        val = float(value)&#10;    except Exception:&#10;        return str(value)&#10;    if val &gt; 1:&#10;        return f&quot;{val:.1f}%&quot;&#10;    return f&quot;{val * 100:.1f}%&quot;&#10;&#10;&#10;def _format_ts_kst(ts: Any) -&gt; str:&#10;    if ts is None:&#10;        return '-'&#10;    try:&#10;        value = float(ts)&#10;    except Exception:&#10;        return '-'&#10;    if value &gt; 1e12:&#10;        value /= 1000.0&#10;    dt = pd.to_datetime(value, unit='s', utc=True)&#10;    try:&#10;        dt = dt.tz_convert('Asia/Seoul')&#10;    except Exception:&#10;        dt = dt.tz_localize('Asia/Seoul', ambiguous='NaT', nonexistent='shift_forward')&#10;    return dt.strftime('%Y-%m-%d %H:%M:%S')&#10;&#10;&#10;def _parse_json_field(value: Any) -&gt; Any:&#10;    if isinstance(value, str):&#10;        try:&#10;            return json.loads(value)&#10;        except Exception:&#10;            return value&#10;    return value&#10;&#10;&#10;def _get_ai_source_payload(entry: Dict[str, Any], provider: str) -&gt; Optional[Dict[str, Any]]:&#10;    payload = entry.get(provider)&#10;    if isinstance(payload, dict):&#10;        return payload&#10;    sources = entry.get('ai_sources') or {}&#10;    return sources.get(provider) if isinstance(sources, dict) else None&#10;&#10;&#10;def _get_ai_confidence(payload: Any) -&gt; Optional[float]:&#10;    if payload is None:&#10;        return None&#10;    if isinstance(payload, dict) and payload.get('confidence') is not None:&#10;        return payload.get('confidence')&#10;    if isinstance(payload, dict):&#10;        raw = payload.get('raw')&#10;        if raw is not None:&#10;            conf = _get_ai_confidence(raw)&#10;            if conf is not None:&#10;                return conf&#10;    if isinstance(payload, dict):&#10;        for value in payload.values():&#10;            conf = _get_ai_confidence(value)&#10;            if conf is not None:&#10;                return conf&#10;    if isinstance(payload, list):&#10;        for item in payload:&#10;            conf = _get_ai_confidence(item)&#10;            if conf is not None:&#10;                return conf&#10;    return None&#10;&#10;&#10;def _prepare_ai_chart_df(entry: Dict[str, Any]) -&gt; pd.DataFrame | None:&#10;    klines = entry.get('klines')&#10;    if isinstance(klines, str):&#10;        klines = _parse_json_field(klines)&#10;    if not klines:&#10;        context = entry.get('context') or {}&#10;        if isinstance(context, str):&#10;            context = _parse_json_field(context) or {}&#10;        markets = isinstance(context, dict) and context.get('markets') or []&#10;        if markets:&#10;            market = markets[0]&#10;            timeframe = market.get('timeframes', {})&#10;            for tf_cfg in timeframe.values():&#10;                candles = tf_cfg.get('candles') or tf_cfg.get('history') or tf_cfg.get('klines')&#10;                if candles:&#10;                    klines = candles&#10;                    break&#10;        if not klines:&#10;            return None&#10;    try:&#10;        df = pd.DataFrame(klines)&#10;    except Exception:&#10;        return None&#10;    rename_map = {&#10;        't': 'time',&#10;        'candle_date_time_kst': 'time',&#10;        'trade_price': 'close',&#10;        'opening_price': 'open',&#10;        'high_price': 'high',&#10;        'low_price': 'low',&#10;        'volume': 'volume',&#10;    }&#10;    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})&#10;    if 'time' not in df.columns:&#10;        return None&#10;    try:&#10;        df['time'] = pd.to_datetime(df['time'])&#10;    except Exception:&#10;        try:&#10;            df['time'] = pd.to_datetime(df['time'].astype(str))&#10;        except Exception:&#10;            return None&#10;    for col in ['open', 'high', 'low', 'close', 'volume']:&#10;        if col in df.columns:&#10;            df[col] = pd.to_numeric(df[col], errors='coerce')&#10;    df = df.sort_values('time').dropna(subset=['time']).reset_index(drop=True)&#10;    if df.empty:&#10;        return None&#10;    return df&#10;&#10;&#10;# --- Main app logic ---&#10;# Sidebar button menu for page selection (user prefers buttons, fixed order)&#10;sb = st.sidebar&#10;sb.title('업비트 트레이더')&#10;sb.caption('원하는 기능으로 바로 가기')&#10;&#10;# Fixed NAV order requested by user&#10;NAV_OPTIONS = [&#10;    'WebSocket 모니터링',&#10;    '종목스크리닝',&#10;    'AI 자문 리포트',&#10;    '자동매매봇 관리',&#10;    '원화잔고 및 포지션 분석',&#10;    '설정 편집',&#10;]&#10;&#10;# Ensure page state exists&#10;if 'page' not in st.session_state:&#10;    st.session_state['page'] = NAV_OPTIONS[0]&#10;&#10;selected_tab = st.session_state['page']&#10;nav_container = sb.container()&#10;pending_selection = None&#10;for nav_option in NAV_OPTIONS:&#10;    is_selected = selected_tab == nav_option&#10;    btn_type = 'primary' if is_selected else 'secondary'&#10;    try:&#10;        clicked = nav_container.button(&#10;            nav_option,&#10;            key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;,&#10;            width='stretch',&#10;            type=btn_type,&#10;        )&#10;    except TypeError:&#10;        # Older Streamlit doesn't support `type` or `width` kwargs; try fallbacks&#10;        try:&#10;            clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;, use_container_width=True)&#10;        except Exception:&#10;            clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;)&#10;    if clicked:&#10;        pending_selection = nav_option&#10;&#10;if pending_selection and pending_selection != selected_tab:&#10;    st.session_state['page'] = pending_selection&#10;    # trigger a rerun so UI reflects selection immediately&#10;    try:&#10;        rerun_fn = getattr(st, 'rerun', None) or getattr(st, 'experimental_rerun', None)&#10;        if rerun_fn:&#10;            rerun_fn()&#10;    except Exception:&#10;        pass&#10;&#10;# page dispatch using session state&#10;page = st.session_state.get('page', NAV_OPTIONS[0])&#10;if page == 'WebSocket 모니터링':&#10;    render_ws_monitoring_page()&#10;elif page == '종목스크리닝':&#10;    render_screening_page()&#10;elif page == 'AI 자문 리포트':&#10;    render_ai_report_page()&#10;elif page == '원화잔고 및 포지션 분석':&#10;    try:&#10;        render_positions_page()&#10;    except Exception as e:&#10;        st.error(f'원화잔고/포지션 페이지 렌더링 중 오류: {e}')&#10;elif page == '설정 편집':&#10;    render_config_page(cfg)&#10;elif page == '자동매매봇 관리':&#10;    render_bot_control_page()&#10;" />
              <option name="updatedContent" value="import streamlit as st&#10;try:&#10;    from streamlit_autorefresh import st_autorefresh as _autorefresh_component&#10;except ImportError:&#10;    _autorefresh_component = None&#10;import sys&#10;# reload-test: touch ui file to verify backend reload behavior (do not remove)&#10;import requests&#10;from requests.adapters import HTTPAdapter&#10;from urllib3.util.retry import Retry&#10;from pathlib import Path&#10;from typing import Any, Dict, Tuple, Optional&#10;import pandas as pd&#10;import plotly.graph_objects as go&#10;from plotly.subplots import make_subplots&#10;import time&#10;import os&#10;import json&#10;&#10;project_root = Path(__file__).resolve().parents[1]&#10;if str(project_root) not in sys.path:&#10;    sys.path.insert(0, str(project_root))&#10;try:&#10;    from server.config import load_config, save_config as save_local&#10;except Exception as err:&#10;    raise RuntimeError(f'server.config.load_config import failed: {err}')&#10;&#10;&#10;def validate_config(cfg: Dict[str, Any]) -&gt; Tuple[bool, str]:&#10;    &quot;&quot;&quot;Basic validation for runtime config used by the UI form.&#10;    Returns (True, '') if valid, otherwise (False, 'reason').&#10;    &quot;&quot;&quot;&#10;    if not isinstance(cfg, dict):&#10;        return False, '설정 데이터가 딕셔너리가 아닙니다.'&#10;    if not cfg.get('market'):&#10;        return False, 'Market 값이 필요합니다.'&#10;    if not isinstance(cfg.get('candle_count', 0), int) or cfg.get('candle_count', 0) &lt;= 0:&#10;        return False, 'Candle count 는 1 이상의 정수여야 합니다.'&#10;    order = cfg.get('order_settings', {})&#10;    if not isinstance(order.get('trade_amount_krw', 0), (int, float)) or order.get('trade_amount_krw', 0) &lt;= 0:&#10;        return False, 'Trade amount_krw 는 0보다 큰 숫자여야 합니다.'&#10;    kelly = cfg.get('kelly_criterion', {})&#10;    if cfg.get('use_kelly_criterion'):&#10;        wr = float(kelly.get('win_rate', 0))&#10;        pr = float(kelly.get('payoff_ratio', 0))&#10;        frac = float(kelly.get('fraction', 0))&#10;        if not (0 &lt;= wr &lt;= 1):&#10;            return False, 'Kelly win_rate 는 0~1 범위여야 합니다.'&#10;        if pr &lt;= 0:&#10;            return False, 'Kelly payoff_ratio 는 양수여야 합니다.'&#10;        if not (0 &lt;= frac &lt;= 1):&#10;            return False, 'Kelly fraction 은 0~1 범위여야 합니다.'&#10;    return True, ''&#10;&#10;&#10;RUNTIME_CONFIG = Path(__file__).resolve().parents[1] / 'runtime' / 'config.json'&#10;&#10;st.set_page_config(page_title='Upbit Trader', layout='wide')&#10;&#10;# Helper to render DataFrame safely across Streamlit versions and hide index when requested&#10;def _safe_dataframe(df: 'pd.DataFrame', hide_index: bool = False, **kwargs):&#10;    &quot;&quot;&quot;Render a pandas DataFrame while attempting to hide the index and use full width.&#10;    Tries the newer `width='stretch'` API first, then falls back to `use_container_width=True`,&#10;    and finally to the basic st.dataframe if needed.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return st.dataframe(df, hide_index=hide_index, width='stretch', **kwargs)&#10;    except TypeError:&#10;        try:&#10;            return st.dataframe(df, hide_index=hide_index, use_container_width=True, **kwargs)&#10;        except TypeError:&#10;            # Older Streamlit may not support hide_index; fallback to st.table (no hide)&#10;            try:&#10;                return st.table(df)&#10;            except Exception:&#10;                return st.write(df)&#10;&#10;&#10;def _safe_plotly_chart(fig, **kwargs):&#10;    &quot;&quot;&quot;Render a plotly figure using newer width='stretch' API if available, otherwise fall back to use_container_width.&quot;&quot;&quot;&#10;    try:&#10;        return st.plotly_chart(fig, width='stretch', **kwargs)&#10;    except TypeError:&#10;        try:&#10;            return st.plotly_chart(fig, use_container_width=True, **kwargs)&#10;        except Exception:&#10;            return st.write('차트를 표시할 수 없습니다.')&#10;&#10;&#10;# Callback for strategy selectbox to trigger immediate rerun so fields update&#10;def _on_strategy_change():&#10;    # mark change and request a rerun so Streamlit re-renders dynamic fields immediately&#10;    st.session_state['_strategy_changed'] = True&#10;    _trigger_rerun()&#10;&#10;&#10;def _trigger_rerun() -&gt; None:&#10;    rerun = getattr(st, 'rerun', None) or getattr(st, 'experimental_rerun', None)&#10;    if rerun:&#10;        try:&#10;            rerun()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;# API base URL for backend calls: read from env var STREAMLIT_API_BASE (set by docker-compose)&#10;# If not set, fall back to localhost for local development.&#10;API_BASE = os.getenv('STREAMLIT_API_BASE', 'http://127.0.0.1:8000')&#10;AUTO_REFRESH_KEY = 'ws_auto_refresh_enabled'&#10;&#10;&#10;# Create a requests session with retry/backoff to make UI-server comms more resilient&#10;def _build_session():&#10;    session = requests.Session()&#10;    retries = Retry(&#10;        total=3,&#10;        backoff_factor=0.6,&#10;        status_forcelist=(429, 500, 502, 503, 504),&#10;        allowed_methods=(&quot;GET&quot;, &quot;POST&quot;),&#10;        raise_on_status=False,&#10;    )&#10;    adapter = HTTPAdapter(max_retries=retries)&#10;    session.mount(&quot;http://&quot;, adapter)&#10;    session.mount(&quot;https://&quot;, adapter)&#10;    return session&#10;&#10;_API_SESSION = _build_session()&#10;&#10;def api_request(method: str, path: str, params=None, json=None, timeout=10):&#10;    &quot;&quot;&quot;Call server API with retries and return requests.Response or raise Exception with friendly message.&quot;&quot;&quot;&#10;    if not API_BASE:&#10;        raise RuntimeError(&quot;API Base URL is not set in the sidebar&quot;)&#10;    url = API_BASE.rstrip(&quot;/&quot;) + &quot;/&quot; + path.lstrip(&quot;/&quot;)&#10;    try:&#10;        if method.lower() == &quot;get&quot;:&#10;            resp = _API_SESSION.get(url, params=params, timeout=timeout)&#10;        else:&#10;            resp = _API_SESSION.post(url, json=json, timeout=timeout)&#10;        resp.raise_for_status()&#10;        return resp&#10;    except requests.exceptions.RequestException as e:&#10;        # Wrap low-level error to present user-friendly message in UI&#10;        raise RuntimeError(f&quot;서버 호출 실패: {e}&quot;) from e&#10;&#10;&#10;def fetch_ws_status():&#10;    try:&#10;        resp = api_request('get', '/ws/status', timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def fetch_ws_trades(symbol: str, limit: int = 20):&#10;    try:&#10;        resp = api_request('get', '/ws/trades', params={'symbol': symbol, 'limit': limit}, timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def _format_ws_ts(ts: Any) -&gt; str:&#10;    if ts is None:&#10;        return '-'&#10;    try:&#10;        value = float(ts)&#10;    except Exception:&#10;        return '-'&#10;    if value &gt; 1e12:&#10;        value /= 1000.0&#10;    dt = pd.to_datetime(value, unit='s', utc=True)&#10;    try:&#10;        dt = dt.tz_convert('Asia/Seoul')&#10;    except Exception:&#10;        dt = dt.tz_localize('Asia/Seoul', ambiguous='NaT', nonexistent='shift_forward')&#10;    return dt.strftime('%Y-%m-%d %H:%M:%S')&#10;&#10;&#10;def fetch_ws_stats(last_hour_sec: int = 3600, recent_limit: int = 10):&#10;    try:&#10;        resp = api_request('get', '/ws/stats', params={'last_hour_sec': last_hour_sec, 'recent_limit': recent_limit}, timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def fetch_ws_executions(limit: int = 0):&#10;    try:&#10;        params = {'limit': limit} if limit else {}&#10;        resp = api_request('get', '/ws/executions', params=params, timeout=10)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def _format_ws_trade_timestamp(payload: Dict[str, Any]) -&gt; str:&#10;    ts = payload.get('trade_timestamp') or payload.get('timestamp')&#10;    try:&#10;        if ts is None:&#10;            return '-'&#10;        tsf = float(ts) / 1000.0 if ts &gt; 1e12 else float(ts)&#10;        return pd.to_datetime(tsf, unit='s').strftime('%H:%M:%S')&#10;    except Exception:&#10;        return '-'&#10;&#10;&#10;def fetch_ws_ticker_data():&#10;    try:&#10;        resp = api_request('get', '/ws/ticker_data', timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def _render_autorefresh_button() -&gt; bool:&#10;    enabled = st.session_state.get(AUTO_REFRESH_KEY, False)&#10;    status_label = 'ON' if enabled else 'OFF'&#10;    icon = '' if enabled else '⚪'&#10;    label = f&quot;{icon} 5초 자동 새로고침 ({status_label})&quot;&#10;    clicked = st.button(label, key='ws_autorefresh_toggle', help='클릭하면 자동 새로고침을 켜거나 끕니다.')&#10;    if clicked:&#10;        enabled = not enabled&#10;        st.session_state[AUTO_REFRESH_KEY] = enabled&#10;        _trigger_rerun()&#10;    return enabled&#10;&#10;&#10;def _apply_autorefresh_if_enabled():&#10;    enabled = st.session_state.get(AUTO_REFRESH_KEY, False)&#10;    if not enabled:&#10;        return&#10;    if _autorefresh_component is None:&#10;        st.caption('streamlit-autorefresh 모듈이 없어 자동 갱신을 사용할 수 없습니다.')&#10;        return&#10;    _autorefresh_component(interval=5000, key='ws_ticker_autorefresh')&#10;&#10;&#10;# --- Upbit public klines helper (cached) ---&#10;@st.cache_data(ttl=10)&#10;def fetch_klines_cached(market: str, timeframe: str = 'minute1', count: int = 200) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;&#10;    UI-side fetch function disabled.&#10;    The UI must not call Upbit public API directly — always go through the backend `/klines_batch` endpoint.&#10;    This function returns None to force the UI to rely on backend data and avoid causing 429 Too Many Requests.&#10;    &quot;&quot;&quot;&#10;    # Return None immediately to prevent direct Upbit calls from the UI.&#10;    st.warning('UI는 직접 Upbit 호출을 하지 않습니다. 백엔드의 prefetch가 완료될 때까지 대기하세요.')&#10;    return None&#10;&#10;&#10;def fetch_klines_batch_from_backend(tickers: list[str], timeframe: str = 'minute15', count: int = 100) -&gt; Dict[str, pd.DataFrame | None]:&#10;    &quot;&quot;&quot;Call server /klines_batch to get klines for multiple tickers. Returns mapping ticker-&gt;DataFrame or None.&#10;    Falls back to empty dict on error.&#10;    &quot;&quot;&quot;&#10;    url = f&quot;{API_BASE.rstrip('/')}/klines_batch&quot;&#10;    try:&#10;        resp = requests.post(url, json={'tickers': tickers, 'timeframe': timeframe, 'count': count}, timeout=15)&#10;        resp.raise_for_status()&#10;        data = resp.json().get('klines', {})&#10;        result = {}&#10;        for t, v in data.items():&#10;            if not v:&#10;                result[t] = None&#10;                continue&#10;            df = pd.DataFrame(v)&#10;            df = df.rename(columns={&#10;                'candle_date_time_kst': 'time',&#10;                'opening_price': 'open',&#10;                'high_price': 'high',&#10;                'low_price': 'low',&#10;                'trade_price': 'close',&#10;                'candle_acc_trade_volume': 'volume'&#10;            })&#10;            cols = [c for c in ['time','open','high','low','close','volume'] if c in df.columns]&#10;            df = df[cols]&#10;            if 'time' in df.columns:&#10;                df['time'] = pd.to_datetime(df['time'])&#10;            for col in ['open','high','low','close','volume']:&#10;                if col in df.columns:&#10;                    df[col] = pd.to_numeric(df[col], errors='coerce')&#10;            df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;            result[t] = df&#10;        return result&#10;    except Exception as e:&#10;        st.warning(f'백엔드 batch klines 호출 실패: {e}')&#10;        return {}&#10;&#10;&#10;def compute_volatility_from_df(df: pd.DataFrame | None) -&gt; float | None:&#10;    &quot;&quot;&quot;Compute volatility as (max_high - min_low) / mean_close * 100.&#10;    Returns percent float or None if cannot compute.&#10;    &quot;&quot;&quot;&#10;    if df is None:&#10;        return None&#10;    try:&#10;        if not hasattr(df, 'empty') or df.empty:&#10;            return None&#10;        if 'high' not in df.columns or 'low' not in df.columns or 'close' not in df.columns:&#10;            return None&#10;        max_high = float(df['high'].max())&#10;        min_low = float(df['low'].min())&#10;        mean_close = float(df['close'].mean()) if float(df['close'].mean() or 0) != 0 else None&#10;        if mean_close is None or mean_close == 0:&#10;            return None&#10;        vol = (max_high - min_low) / mean_close * 100.0&#10;        return float(vol)&#10;    except Exception:&#10;        return None&#10;&#10;&#10;def _normalize_klines_df(df: pd.DataFrame | None, min_length: int = 30) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;Validate and normalize a kline DataFrame for plotting.&#10;    - Ensures time column exists and is datetime&#10;    - Renames common Upbit keys if needed&#10;    - Sorts ascending by time, drops duplicate timestamps&#10;    - Converts numeric columns and fills small gaps&#10;    - Returns None if data is invalid&#10;    &quot;&quot;&quot;&#10;    if df is None:&#10;        return None&#10;    # Accept list-of-dicts as well&#10;    if not isinstance(df, pd.DataFrame):&#10;        try:&#10;            df = pd.DataFrame(df)&#10;        except Exception:&#10;            return None&#10;&#10;    # Map common Upbit field names to expected ones&#10;    rename_map = {&#10;        'candle_date_time_kst': 'time',&#10;        'opening_price': 'open',&#10;        'high_price': 'high',&#10;        'low_price': 'low',&#10;        'trade_price': 'close',&#10;        'candle_acc_trade_volume': 'volume'&#10;    }&#10;    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})&#10;&#10;    # required columns&#10;    required = ['time', 'open', 'high', 'low', 'close', 'volume']&#10;    if 'time' not in df.columns:&#10;        return None&#10;&#10;    # time -&gt; datetime&#10;    try:&#10;        df['time'] = pd.to_datetime(df['time'])&#10;    except Exception:&#10;        try:&#10;            df['time'] = pd.to_datetime(df['time'].astype(str))&#10;        except Exception:&#10;            return None&#10;&#10;    # sort ascending and dedupe&#10;    df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;    if df['time'].duplicated().any():&#10;        df = df[~df['time'].duplicated(keep='last')].reset_index(drop=True)&#10;&#10;    # ensure numeric&#10;    for col in ['open', 'high', 'low', 'close', 'volume']:&#10;        if col in df.columns:&#10;            df[col] = pd.to_numeric(df[col], errors='coerce')&#10;        else:&#10;            df[col] = pd.NA&#10;&#10;    # fill small gaps for price columns&#10;    try:&#10;        df[['open', 'high', 'low', 'close']] = df[['open', 'high', 'low', 'close']].ffill().bfill()&#10;        df['volume'] = df['volume'].fillna(0)&#10;    except Exception:&#10;        pass&#10;&#10;    if len(df) &lt; min_length:&#10;        st.warning(f'차트에 필요한 데이터가 부족합니다: {len(df)}개 (최소 {min_length} 필요)')&#10;        return df&#10;    return df&#10;&#10;&#10;# --- Indicator helpers and plotting ---&#10;def compute_rsi(series: pd.Series, period: int = 14) -&gt; pd.Series:&#10;    # Standard Wilder's RSI calculation without forcing initial values to 0.&#10;    delta = series.diff()&#10;    up = delta.clip(lower=0)&#10;    down = -1 * delta.clip(upper=0)&#10;    ma_up = up.rolling(period, min_periods=period).mean()&#10;    ma_down = down.rolling(period, min_periods=period).mean()&#10;    rs = ma_up / ma_down&#10;    rsi = 100 - (100 / (1 + rs))&#10;    return rsi&#10;&#10;&#10;def plot_candles_with_indicators(df: pd.DataFrame, ticker: str, ma_windows: list[int], rsi_period: int):&#10;    # Create subplot: row1 = candlestick+MA, row2 = volume bars, row3 = RSI&#10;    fig = make_subplots(rows=3, cols=1, shared_xaxes=True, row_heights=[0.6, 0.2, 0.2], vertical_spacing=0.03)&#10;&#10;    # Row 1: Candlestick — set colors: rising(red), falling(blue)&#10;    fig.add_trace(go.Candlestick(x=df['time'], open=df['open'], high=df['high'], low=df['low'], close=df['close'], name='OHLC', increasing=dict(line=dict(color='red'), fillcolor='red'), decreasing=dict(line=dict(color='blue'), fillcolor='blue')), row=1, col=1)&#10;&#10;    # moving averages on top&#10;    for w in ma_windows:&#10;        ma = df['close'].rolling(w).mean()&#10;        fig.add_trace(go.Scatter(x=df['time'], y=ma, mode='lines', name=f'MA{w}', line=dict(width=1.2)), row=1, col=1)&#10;&#10;    # Row 2: Volume bars&#10;    # color volume bars green when close &gt;= open else red&#10;    try:&#10;        # rising -&gt; red, falling -&gt; blue&#10;        colors = ['red' if c &gt;= o else 'blue' for o, c in zip(df['open'], df['close'])]&#10;    except Exception:&#10;        colors = 'gray'&#10;    if 'volume' not in df.columns:&#10;        df['volume'] = 0&#10;    fig.add_trace(go.Bar(x=df['time'], y=df['volume'], name='Volume', marker=dict(color=colors), hovertemplate='Volume: %{y:,.0f}&lt;extra&gt;&lt;/extra&gt;'), row=2, col=1)&#10;    # Keep volume axis independent&#10;    fig.update_yaxes(title_text='Volume', row=2, col=1)&#10;&#10;    # Row 3: RSI&#10;    rsi = compute_rsi(df['close'], period=rsi_period)&#10;    fig.add_trace(go.Scatter(x=df['time'], y=rsi, mode='lines', name=f'RSI({rsi_period})', line=dict(color='purple', width=2.0), connectgaps=False, hovertemplate='RSI: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'), row=3, col=1)&#10;    # RSI bands (draw as shapes for visibility)&#10;    fig.add_hline(y=70, line=dict(color='red', dash='dash'), row=3, col=1)&#10;    fig.add_hline(y=30, line=dict(color='green', dash='dash'), row=3, col=1)&#10;    fig.update_yaxes(range=[0,100], row=3, col=1)&#10;&#10;    # layout tweaks&#10;    fig.update_layout(height=520, margin=dict(l=10, r=10, t=30, b=20), showlegend=True, hovermode='x unified')&#10;    fig.update_xaxes(rangebreaks=[dict(bounds=[&quot;sat&quot;,&quot;mon&quot;])], rangeslider_visible=False)&#10;    return fig&#10;&#10;&#10;# Load existing config&#10;cfg = load_config()&#10;&#10;# --- Page renderers ---&#10;&#10;def render_config_page(cfg: Dict[str, Any]):&#10;    st.title('설정 편집')&#10;&#10;    # Strategy selector placed outside the form so changes immediately re-render detail fields.&#10;    _strategy_opts = ['VolatilityBreakout', 'DualMomentum', 'RSI']&#10;    _default = cfg.get('strategy_name', 'VolatilityBreakout')&#10;    try:&#10;        _default_idx = _strategy_opts.index(_default) if _default in _strategy_opts else 0&#10;    except Exception:&#10;        _default_idx = 0&#10;    # initialize session state key if missing so we can read it inside the form&#10;    if 'cfg_strategy' not in st.session_state:&#10;        st.session_state['cfg_strategy'] = _strategy_opts[_default_idx]&#10;    strategy_name = st.selectbox('전략 (어떤 방식을 쓸까요?)', options=_strategy_opts, index=_default_idx, key='cfg_strategy', help='어떤 거래 전략을 쓸지 골라요. 예: 변동성 돌파, 모멘텀, RSI')&#10;&#10;    # Now the form (other widgets and save buttons). Inside the form read the currently selected strategy&#10;    with st.form('config_form', clear_on_submit=False):&#10;        # use the session_state value so fields update immediately when the selectbox changes&#10;        strategy_name = st.session_state.get('cfg_strategy', _strategy_opts[_default_idx])&#10;&#10;        # --- 전략별 상세 설정: 전략 선택 바로 아래에 위치하도록 함 ---&#10;        st.caption('선택한 전략에 따라 여기서 세부 옵션을 정해요.')&#10;        strategy_params = cfg.get('strategy_params', {})&#10;        if strategy_name == 'RSI':&#10;            rsi = strategy_params.get('RSI', {})&#10;            rsi_period = st.number_input('RSI 기간 (몇개 캔들로 계산할지)', min_value=1, value=int(rsi.get('period', 14)), help='RSI를 계산할 때 몇 개의 캔들을 볼지 정해요. 보통 14')&#10;            rsi_oversold = st.number_input('과매도 기준 (0~100)', min_value=0, max_value=100, value=int(rsi.get('oversold', 30)), help='이 값 아래면 너무 싸게 팔려서 사도 되는 상태예요.')&#10;            rsi_overbought = st.number_input('과매수 기준 (0~100)', min_value=0, max_value=100, value=int(rsi.get('overbought', 70)), help='이 값 위면 너무 비싸게 사져서 팔아야 할 수도 있어요.')&#10;        elif strategy_name == 'VolatilityBreakout':&#10;            vb = strategy_params.get('VolatilityBreakout', {})&#10;            k_value = st.number_input('변동성 비율 k (0~1)', min_value=0.0, max_value=1.0, value=float(vb.get('k_value', 0.5)), help='지난 기간의 변동성에서 몇 퍼센트만큼 돌파를 보면 진입할지 정하는 수치예요. 0.5가 보통 사용됩니다.')&#10;            target_vol_pct_default = vb.get('target_vol_pct', cfg.get('vb_target_vol_pct', 30.0))&#10;            target_vol_pct = st.number_input('목표 변동성 비율 (%)', min_value=1.0, max_value=100.0, value=float(target_vol_pct_default), help='시장 변동성이 이 값 이상인지 보고 매매 여부를 판단해요.')&#10;        elif strategy_name == 'DualMomentum':&#10;            dm = strategy_params.get('DualMomentum', {})&#10;            window = st.number_input('모멘텀 계산 창 길이', min_value=1, value=int(dm.get('window', 12)), help='모멘텀을 계산할 때 몇 기간을 볼지 정해요. 숫자가 크면 더 긴 흐름을 봐요.')&#10;&#10;        # 기본 정보(전략 상세 바로 아래에 위치)&#10;        market = st.text_input('거래할 마켓 (예: KRW-BTC)', value=cfg.get('market', 'KRW-BTC'), help='어떤 코인을 거래할지 적어요. 예: KRW-BTC는 비트코인입니다.')&#10;        timeframe = st.text_input('캔들 시간 단위 (예: minute5)', value=cfg.get('timeframe', 'minute5'), help='한 개의 캔들이 몇 분/시간인지 적어요. 예: minute5 = 5분')&#10;        candle_count = st.number_input('캔들 개수(그래프 표시 길이)', min_value=1, value=int(cfg.get('candle_count', 200)), help='차트에 보여줄 과거 데이터의 개수예요. 숫자가 크면 긴 기간을 보여줘요.')&#10;        loop_interval_sec = st.number_input('루프 실행 간격(초)', min_value=1, value=int(cfg.get('loop_interval_sec', 5)), help='자동으로 확인할 때 몇 초마다 할지 정해요.')&#10;&#10;        st.subheader('주문 관련 설정 (돈/수량)')&#10;        order_settings = cfg.get('order_settings', {})&#10;        min_order_amount = st.number_input('최소 주문 금액 (원)', min_value=1000, value=int(order_settings.get('min_order_amount', 5500)), help='거래소에서 허용하는 최소 주문 금액이에요. 이 값보다 작으면 주문 못해요.')&#10;        trade_amount_krw = st.number_input('한 번 거래할 금액 (원)', min_value=1000, value=int(order_settings.get('trade_amount_krw', 6000)), help='한 번 매수할 때 쓰는 돈이에요. 예: 6000원')&#10;&#10;        st.subheader('켈리공식 (돈을 얼마나 쓸지 계산하는 방법)')&#10;        use_kelly = st.checkbox('켈리공식 사용하기', value=bool(cfg.get('use_kelly_criterion', True)), help='켈리공식을 사용하면 이길 확률과 수익비율로 한 번에 투자할 돈을 계산해줘요.')&#10;        kelly = cfg.get('kelly_criterion', {})&#10;        win_rate = st.number_input('승률 (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('win_rate', 0.65)), help='거래했을 때 이길 확률을 0부터 1 사이로 적어요. 예: 0.65 = 65%')&#10;        payoff_ratio = st.number_input('평균 이익/손실 비율', min_value=0.0, value=float(kelly.get('payoff_ratio', 1.2)), help='이길 때 평균 이익이 손실보다 몇 배인지 적어요. 예: 1.2면 이익이 손실의 1.2배')&#10;        fraction = st.number_input('적용 비율 (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('fraction', 0.5)), help='켈리로 계산한 금액 중 얼마만 실제로 쓸지 0~1로 적어요. 예: 0.5는 반만 사용')&#10;&#10;        submit = st.form_submit_button('미리보기 업데이트')&#10;&#10;        # --- Prefetch &amp; Cache settings ---&#10;        st.subheader('미리받기(캐시) 설정 — 서버가 데이터를 미리 모아놓는 방법')&#10;        prefetch_cfg = cfg.get('prefetch', {}) if isinstance(cfg.get('prefetch', {}), dict) else {}&#10;        # Top-level prefetch keys (stored at root level, not inside 'prefetch' for backward compatibility)&#10;        prefetch_count = st.number_input('미리 받을 캔들 수 (종목당)', min_value=1, value=int(cfg.get('prefetch_count', cfg.get('candle_count', 200))), help='서버가 각 종목에서 미리 받아둘 캔들 수예요. 그래프 길이에 영향을 줍니다.')&#10;        prefetch_interval_sec = st.number_input('미리수집 반복 간격(초)', min_value=1, value=int(cfg.get('prefetch_interval_sec', 30)), help='서버가 미리 데이터를 모으는 간격이에요. 숫자가 작으면 더 자주 업데이트합니다.')&#10;        prefetch_batch_size = st.number_input('한번에 모을 종목 수', min_value=1, value=int(cfg.get('prefetch_batch_size', 5)), help='한 번에 몇 종목씩 모을지 정해요. 너무 크면 호출이 몰려서 실패할 수 있어요.')&#10;        prefetch_parallelism = st.number_input('동시 작업 수(스레드)', min_value=1, value=int(cfg.get('prefetch_parallelism', 3)), help='몇 개의 작업을 동시에 실행할지 정해요. 숫자가 크면 빨라지지만 컴퓨터에 부담이 들어요.')&#10;        prefetch_sleep_sec = st.number_input('종목 사이 쉬는 시간(초)', min_value=0.0, value=float(cfg.get('prefetch_sleep_sec', 0.2)), help='한 종목을 처리한 뒤 잠깐 쉬는 시간이에요. 서버 과부하를 줄여요.')&#10;        prefetch_min_interval_sec = st.number_input('Redis 없을 때 최소 간격(초)', min_value=1, value=int(cfg.get('prefetch_min_interval_sec', 60)), help='Redis가 없으면 미리받기 사이 간격을 더 길게 해요.')&#10;        prefetch_no_redis_max_count = st.number_input('Redis 없을 때 최대 캔들 수', min_value=1, value=int(cfg.get('prefetch_no_redis_max_count', 120)), help='Redis가 없을 때는 너무 많이 가져오지 않도록 제한해요.')&#10;        prefetch_rate_per_sec = st.number_input('초당 허용 호출(토큰)', min_value=0.0, value=float(cfg.get('prefetch_rate_per_sec', 5)), help='초당 몇 번의 호출을 허용할지 토큰으로 정해요.')&#10;        prefetch_rate_capacity = st.number_input('버스트 허용 토큰(추가 여유)', min_value=1, value=int(cfg.get('prefetch_rate_capacity', int(prefetch_rate_per_sec or 1))), help='잠깐 동안 더 많은 호출을 허용할 수 있는 여유량이에요.')&#10;        prefetch_max_concurrent = st.number_input('최대 동시 작업 수', min_value=1, value=int(cfg.get('prefetch_max_concurrent', 3)), help='한 번에 병렬로 수행할 최대 작업 수예요.')&#10;        prefetch_token_wait_timeout = st.number_input('토큰 대기 최대 시간(초)', min_value=0.0, value=float(cfg.get('prefetch_token_wait_timeout', 10.0)), help='토큰을 기다리는 최대 시간이에요. 너무 작으면 실패할 수 있어요.')&#10;        # Cache TTL&#10;        klines_cache_ttl = st.number_input('차트 데이터 캐시 유지시간(초)', min_value=1, value=int(cfg.get('KLINES_CACHE_TTL', os.getenv('KLINES_CACHE_TTL', '600'))), help='서버가 저장해두는 데이터가 얼마나 오래 유지될지 초 단위로 적어요.')&#10;&#10;        # AI ensemble settings&#10;        st.subheader('AI 조합 방법 (여러 AI를 어떻게 합칠까?)')&#10;        ai_ensemble = cfg.get('ai_ensemble', {}) if isinstance(cfg.get('ai_ensemble', {}), dict) else {}&#10;        ai_strategy = st.selectbox('AI 합치는 방식', options=['UNANIMOUS', 'MAJORITY', 'AVERAGE'], index=0 if ai_ensemble.get('strategy') is None else ['UNANIMOUS','MAJORITY','AVERAGE'].index(ai_ensemble.get('strategy', 'UNANIMOUS')), help='여러 AI가 모두 같은 의견일 때만 따를지(UNANIMOUS), 과반수 의견을 따를지(MAJORITY), 평균을 낼지(AVERAGE) 골라요.')&#10;        openai_model = st.text_input('OpenAI 모델 이름', value=ai_ensemble.get('openai_model', cfg.get('OPENAI_MODEL', 'gpt-5.1-nano')), help='OpenAI에서 사용할 모델 이름을 적어요. 특별히 모르면 기본값 그대로 두세요.')&#10;        gemini_model = st.text_input('Gemini 모델 이름', value=ai_ensemble.get('gemini_model', cfg.get('GEMINI_MODEL', 'gemini-2.5-flash')), help='Gemini에서 사용할 모델 이름을 적어요. 모르면 기본값 사용')&#10;&#10;        # Universe (comma separated tickers)&#10;        st.subheader('관심 종목 목록 (우리가 볼 종목들)')&#10;        universe_list = cfg.get('universe')&#10;        if isinstance(universe_list, list):&#10;            universe_str = ','.join(universe_list)&#10;        else:&#10;            universe_str = str(universe_list or '')&#10;        universe_input = st.text_area('관심 종목 (콤마로 구분, 예: KRW-BTC,KRW-ETH)', value=universe_str, height=80, help='여기에 보고 싶은 종목들을 쉼표로 구분해서 적어요. 예: KRW-BTC,KRW-ETH')&#10;&#10;    new_cfg = {&#10;        'strategy_name': strategy_name,&#10;        'market': market,&#10;        'timeframe': timeframe,&#10;        'candle_count': candle_count,&#10;        'loop_interval_sec': loop_interval_sec,&#10;        'order_settings': {&#10;            'min_order_amount': min_order_amount,&#10;            'trade_amount_krw': trade_amount_krw,&#10;        },&#10;        'use_kelly_criterion': use_kelly,&#10;        'kelly_criterion': {&#10;            'win_rate': win_rate,&#10;            'payoff_ratio': payoff_ratio,&#10;            'fraction': fraction,&#10;        },&#10;        'strategy_params': {}&#10;    }&#10;&#10;    if strategy_name == 'RSI':&#10;        new_cfg['strategy_params']['RSI'] = {&#10;            'period': rsi_period,&#10;            'oversold': rsi_oversold,&#10;            'overbought': rsi_overbought,&#10;        }&#10;    elif strategy_name == 'VolatilityBreakout':&#10;        new_cfg['strategy_params']['VolatilityBreakout'] = {&#10;            'k_value': k_value,&#10;            'target_vol_pct': target_vol_pct,&#10;        }&#10;    elif strategy_name == 'DualMomentum':&#10;        new_cfg['strategy_params']['DualMomentum'] = {'window': window}&#10;&#10;    # attach AI ensemble and universe&#10;    new_cfg['ai_ensemble'] = {&#10;        'strategy': ai_strategy,&#10;        'openai_model': openai_model,&#10;        'gemini_model': gemini_model,&#10;    }&#10;    # parse universe string into list&#10;    universe_parsed = [s.strip() for s in universe_input.split(',') if s.strip()]&#10;    if universe_parsed:&#10;        new_cfg['universe'] = universe_parsed&#10;    else:&#10;        # keep existing if empty&#10;        if isinstance(cfg.get('universe'), list):&#10;            new_cfg['universe'] = cfg.get('universe')&#10;&#10;    st.divider()&#10;    st.header('설정 액션')&#10;    valid, message = validate_config(new_cfg)&#10;    if not valid:&#10;        st.error('유효성 검사 실패: ' + message)&#10;&#10;    col_a, col_b, col_c = st.columns(3)&#10;    with col_a:&#10;        if st.button('로컬에 저장'):&#10;            if not valid:&#10;                st.error('저장 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    save_local(new_cfg)&#10;                    st.success('저장 완료: runtime/config.json')&#10;                except Exception as e:&#10;                    st.error('로컬 저장 실패: ' + str(e))&#10;    with col_b:&#10;        if st.button('서버에 전송'):&#10;            if not valid:&#10;                st.error('전송 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    resp = api_request('post', '/config', json={'config': new_cfg}, timeout=10)&#10;                    st.success('서버에 전송 완료')&#10;                except Exception as e:&#10;                    st.error(str(e))&#10;    with col_c:&#10;        if st.button('서버 재로딩 요청'):&#10;            try:&#10;                resp = api_request('post', '/reload', timeout=5)&#10;                st.success('서버 재로딩 요청 성공')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;&#10;&#10;def render_ws_monitoring_page():&#10;    st.title('WebSocket 모니터링')&#10;    st.write('실시간 WebSocket 스트리밍 현황과 체결 기록을 한눈에 확인합니다.')&#10;&#10;    stats, stats_err = fetch_ws_stats()&#10;    if stats_err:&#10;        st.warning(f'WebSocket 통계 수집 오류: {stats_err}')&#10;        stats = None&#10;&#10;    if stats:&#10;        cols = st.columns(4)&#10;        metrics = (&#10;            ('시세 수신 성공', stats.get('ticker_success', 0)),&#10;            ('시세 수신 실패', stats.get('ticker_failure', 0)),&#10;            ('체결 수신 성공', stats.get('order_success', 0)),&#10;            ('체결 수신 실패', stats.get('order_failure', 0)),&#10;        )&#10;        for col, (label, value) in zip(cols, metrics):&#10;            col.metric(label, f&quot;{int(value):,}&quot;)&#10;        status_text = '실행 중' if stats.get('running') else '대기 중'&#10;        st.caption(&#10;            f&quot;WebSocket 상태: {status_text} · 구독 종목: {len(stats.get('targets', []))} · &quot;&#10;            f&quot;최근 1시간 시세 성공:{stats.get('last_hour_ticker_success', 0)}, 실패:{stats.get('last_hour_ticker_failure', 0)} / &quot;&#10;            f&quot;체결 성공:{stats.get('last_hour_order_success', 0)}, 실패:{stats.get('last_hour_order_failure', 0)}&quot;&#10;        )&#10;    else:&#10;        st.info('WebSocket 통계를 불러올 수 없습니다. 리스너 실행 여부를 확인해 주세요.')&#10;&#10;    st.divider()&#10;    st.subheader('WebSocket 제어')&#10;    btn_col1, btn_col2, btn_col3 = st.columns(3)&#10;    with btn_col1:&#10;        if st.button('WebSocket 시작', key='ws_ctrl_start'):&#10;            try:&#10;                api_request('post', '/ws/start', timeout=5)&#10;                st.success('WebSocket 리스너 시작 요청이 전송되었습니다.')&#10;            except Exception as exc:&#10;                st.error(f'WebSocket 시작 실패: {exc}')&#10;    with btn_col2:&#10;        if st.button('WebSocket 중지', key='ws_ctrl_stop'):&#10;            try:&#10;                api_request('post', '/ws/stop', timeout=5)&#10;                st.success('WebSocket 리스너 중지 요청이 전송되었습니다.')&#10;            except Exception as exc:&#10;                st.error(f'WebSocket 중지 실패: {exc}')&#10;    with btn_col3:&#10;        if st.button('상태 새로 고침', key='ws_ctrl_refresh'):&#10;            _trigger_rerun()&#10;&#10;    st.divider()&#10;    enabled = st.session_state.get(AUTO_REFRESH_KEY, False)&#10;    enabled = _render_autorefresh_button()&#10;    st.session_state[AUTO_REFRESH_KEY] = enabled&#10;    _apply_autorefresh_if_enabled()&#10;&#10;    st.subheader('분봉 수신 현황 (최근 10개)')&#10;    rows = []&#10;    if stats:&#10;        for item in stats.get('recent_ticker_events', []):&#10;            rows.append({&#10;                '시간': _format_ws_ts(item.get('ts')),&#10;                '종목': item.get('symbol') or '-',&#10;                '타입': item.get('type') or '-',&#10;                '현재가' : item.get('trade_price') or '-',&#10;                '결과': '성공' if item.get('success') else '실패',&#10;            })&#10;    if rows:&#10;        _safe_dataframe(pd.DataFrame(rows), hide_index=True)&#10;    else:&#10;        st.info('최근 분봉 수신 기록이 없습니다.')&#10;&#10;    st.subheader('심볼별 최신 티커 정보 (5초 자동 갱신)')&#10;    ticker_data, ticker_err = fetch_ws_ticker_data()&#10;    if ticker_err:&#10;        st.warning(f'티커 데이터 조회 오류: {ticker_err}')&#10;    elif ticker_data and isinstance(ticker_data.get('tickers'), list):&#10;        df_tickers = pd.DataFrame(ticker_data['tickers'])&#10;        if not df_tickers.empty:&#10;            df_tickers = df_tickers.rename(columns={&#10;                'symbol': '심볼',&#10;                'opening_price': '시가',&#10;                'high_price': '고가',&#10;                'low_price': '저가',&#10;                'trade_price': '현재가',&#10;                'prev_closing_price': '전일종가',&#10;                'change': '전일대비변동',&#10;            })&#10;            if 'timestamp' in df_tickers.columns:&#10;                df_tickers['최근 수신'] = df_tickers['timestamp'].apply(_format_ws_ts)&#10;            display_cols = ['심볼', '시가', '고가', '저가', '현재가', '전일종가', '전일대비변동', '최근 수신']&#10;            available_cols = [c for c in display_cols if c in df_tickers.columns]&#10;            df_display = df_tickers[available_cols]&#10;            _safe_dataframe(df_display.fillna('-'), hide_index=True)&#10;        else:&#10;            st.info('티커 데이터가 아직 없습니다.')&#10;    else:&#10;        if ticker_err is None:&#10;            st.info('티커 데이터 로딩 대기 중입니다.')&#10;&#10;    st.subheader('체결 수신 현황 (exec_history)')&#10;    executions, exec_err = fetch_ws_executions()&#10;    exec_table = []&#10;    if exec_err:&#10;        st.warning(f'체결 기록 조회 오류: {exec_err}')&#10;    elif executions and isinstance(executions.get('executions'), list):&#10;        data = executions['executions']&#10;        for entry in sorted(data, key=lambda e: e.get('ts', 0), reverse=True):&#10;            exec_table.append({&#10;                '시간': _format_ws_ts(entry.get('ts')),&#10;                '심볼': entry.get('symbol') or '-',&#10;                '사이드': entry.get('side') or entry.get('ask_bid') or '-',&#10;                '체결가': entry.get('price') or entry.get('order_price') or '-',&#10;                '수량': entry.get('size') or entry.get('trade_volume') or '-',&#10;                '장부가': entry.get('entry_price') or '-',&#10;            })&#10;    if exec_table:&#10;        try:&#10;            df_exec = pd.DataFrame(exec_table)&#10;            def _format_side(label: str) -&gt; str:&#10;                try:&#10;                    key = str(label or '').strip().lower()&#10;                except Exception:&#10;                    return label&#10;                if key in ('ask', 'sell', '매도'):&#10;                    return '매도'&#10;                if key in ('bid', 'buy', '매수'):&#10;                    return '매수'&#10;                return label&#10;            if '사이드' in df_exec.columns:&#10;                df_exec['사이드'] = df_exec['사이드'].map(_format_side)&#10;            _safe_dataframe(df_exec, hide_index=True)&#10;        except Exception:&#10;            st.write(exec_table)&#10;    else:&#10;        if not exec_err:&#10;            st.info('체결 기록이 없습니다. WebSocket 리스너가 실행 중인지 확인하세요.')&#10;&#10;&#10;def render_screening_page():&#10;    st.title('종목 스크리닝')&#10;    st.caption('변동성 TOP 종목을 조회합니다. (최근 캔들 기준)')&#10;    st.code('변동성은 (max_high - min_low) / mean_close 로 계산됩니다.')&#10;&#10;    # Controls moved into the page (previously in sidebar)&#10;    ctrl_col1, ctrl_col2, ctrl_col3 = st.columns([1,1,1])&#10;    market_prefix = ctrl_col1.text_input('마켓 접두사 (예: KRW)', value='KRW', key='scr_market_prefix')&#10;    top_n = ctrl_col2.number_input('Top N', min_value=1, max_value=50, value=10, key='scr_top_n')&#10;    # timeframe placed in the third column for grouping&#10;    timeframe = ctrl_col3.selectbox('Timeframe', options=['minute5','minute15','minute60','day'], index=1, key='scr_timeframe')&#10;&#10;    # Place the search button in a dedicated full-width row so it spans the page&#10;    full_row = st.columns([1])[0]&#10;    try:&#10;        # Use width='stretch' when supported&#10;        search_clicked = full_row.button('조회', key='scr_search', width='stretch')&#10;    except TypeError:&#10;        # Fallback for older Streamlit versions&#10;        search_clicked = full_row.button('조회', key='scr_search')&#10;&#10;    # When search clicked, fetch data and then render charts below&#10;    if 'search_clicked' not in st.session_state:&#10;        st.session_state['search_clicked'] = False&#10;    if search_clicked:&#10;        st.session_state['search_clicked'] = True&#10;        st.session_state['screening_query'] = {&#10;            'market_prefix': market_prefix,&#10;            'top_n': top_n,&#10;            'timeframe': timeframe,&#10;        }&#10;&#10;    if not st.session_state.get('search_clicked'):&#10;        st.info('조회 버튼을 눌러 변동성 TOP 종목을 검색하세요.')&#10;        return&#10;&#10;    # read query&#10;    query = st.session_state.get('screening_query', {})&#10;    market_prefix = query.get('market_prefix', 'KRW')&#10;    requested_n = int(query.get('top_n', 10))&#10;    timeframe = query.get('timeframe', 'minute15')&#10;&#10;    with st.spinner('변동성 TOP 종목 조회 중...'):&#10;        # Try multiple backend endpoints for compatibility&#10;        candidate_paths = [&#10;            ('post', '/screening/top_volatility'),&#10;            ('get', '/screen/volatility_top'),&#10;            ('get', '/screen/volatility_top'),&#10;        ]&#10;        tickers = []&#10;        last_exception = None&#10;        for method, path in candidate_paths:&#10;            try:&#10;                if method == 'get':&#10;                    resp = api_request('get', path, params={'market_prefix': market_prefix, 'top_n': requested_n, 'timeframe': timeframe}, timeout=8)&#10;                else:&#10;                    resp = api_request('post', path, json={'market_prefix': market_prefix, 'top_n': requested_n, 'timeframe': timeframe}, timeout=10)&#10;                j = resp.json()&#10;                # support different key names&#10;                tickers = j.get('tickers') or j.get('top') or j.get('top_tickers') or j.get('top', [])&#10;                # if server returns objects, try to extract ticker strings&#10;                if tickers and isinstance(tickers, list) and isinstance(tickers[0], dict):&#10;                    # expect dict with 'ticker' or 'symbol'&#10;                    tickers = [it.get('ticker') or it.get('symbol') or it.get('market') for it in tickers]&#10;                # filter empties&#10;                tickers = [t for t in (tickers or []) if t]&#10;                if tickers:&#10;                    break&#10;            except Exception as e:&#10;                last_exception = e&#10;                continue&#10;&#10;        if not tickers:&#10;            if last_exception:&#10;                st.error(f'스케리닝 조회 실패: {last_exception}')&#10;            else:&#10;                st.warning('조건에 맞는 종목이 없습니다.')&#10;            return&#10;&#10;        # fetch klines in batch&#10;        backend_data = fetch_klines_batch_from_backend(tickers, timeframe=timeframe, count=200)&#10;&#10;        # Compute volatility (%) per ticker from backend_data and show a ranked table&#10;        vol_rows = []&#10;        for t in tickers:&#10;            dfk = backend_data.get(t)&#10;            dfk_norm = _normalize_klines_df(dfk, min_length=5)&#10;            vol = compute_volatility_from_df(dfk_norm)&#10;            vol_rows.append({'ticker': t, 'volatility_pct': None if vol is None else float(vol)})&#10;        try:&#10;            df_top = pd.DataFrame(vol_rows)&#10;            # sort by volatility (ascending), NaNs at the end&#10;            df_top = df_top.sort_values('volatility_pct', ascending=False, na_position='last').reset_index(drop=True)&#10;            df_top.insert(0, 'rank', range(1, len(df_top) + 1))&#10;            # pretty formatting column&#10;            def _fmt(v):&#10;                try:&#10;                    if v is None or (isinstance(v, float) and (pd.isna(v))):&#10;                        return '-'&#10;                    return f&quot;{float(v):.2f}%&quot;&#10;                except Exception:&#10;                    return '-'&#10;            df_top['변동성(%)'] = df_top['volatility_pct'].apply(_fmt)&#10;            df_display = df_top[['rank','ticker','변동성(%)']]&#10;            _safe_dataframe(df_display, hide_index=True)&#10;        except Exception as e:&#10;            st.warning(f'상단 변동성 표 생성 중 오류: {e}')&#10;&#10;        # Diagnostics: show which tickers have data and which not&#10;        missing = []&#10;        insufficient = []&#10;        for t in tickers:&#10;            df = backend_data.get(t)&#10;            if df is None:&#10;                missing.append(t)&#10;            else:&#10;                try:&#10;                    if hasattr(df, 'shape') and df.shape[0] &lt; 10:&#10;                        insufficient.append((t, int(df.shape[0])))&#10;                except Exception:&#10;                    pass&#10;        if missing:&#10;            st.warning(f&quot;데이터가 없는 종목: {', '.join(missing)} (백엔드가 캐시를 아직 채우지 않았거나 수집 실패)&quot;)&#10;        if insufficient:&#10;            st.info('샘플이 적은 종목: ' + ', '.join([f&quot;{t}({n})&quot; for t,n in insufficient]))&#10;&#10;        # Render a grid: 5 rows x 2 cols (max 10)&#10;        max_slots = requested_n&#10;        display_items = tickers[:max_slots]&#10;        display_n = len(display_items)&#10;        rows = (max_slots + 1) // 2&#10;        idx = 0&#10;        for r in range(rows):&#10;            cols = st.columns(2, gap='small')&#10;            for c in range(2):&#10;                if idx &gt;= display_n:&#10;                    with cols[c]:&#10;                        st.empty()&#10;                    idx += 1&#10;                    continue&#10;                ticker = display_items[idx]&#10;                with cols[c]:&#10;                    st.subheader(f&quot;{idx+1}. {ticker}&quot;)&#10;                    df = backend_data.get(ticker)&#10;                    df = _normalize_klines_df(df, min_length=30)&#10;                    if df is None or (hasattr(df, 'empty') and df.empty):&#10;                        st.info('차트 데이터를 불러올 수 없습니다. (백엔드 캐시 또는 수집 상태를 확인하세요)')&#10;                    else:&#10;                        # smaller chart per grid cell&#10;                        fig = plot_candles_with_indicators(df, ticker, ma_windows=[20, 60], rsi_period=14)&#10;                        fig.update_layout(height=320, margin=dict(l=8, r=8, t=24, b=12))&#10;                        _safe_plotly_chart(fig)&#10;                idx += 1&#10;        st.caption(f&quot;표시된 종목: {display_n} / 요청한 TopN: {requested_n}&quot;)&#10;&#10;&#10;def render_positions_page():&#10;    st.title('원화잔고 및 포지션 분석')&#10;    st.write('원화 잔고와 보유 포지션을 요약하고 간단한 시각화를 제공합니다.')&#10;&#10;    balances = None&#10;    positions = None&#10;    positions_payload: Dict[str, Any] = {}&#10;    api_errors: list[str] = []&#10;&#10;    # Try dedicated endpoints first&#10;    reported_krw_from_server = 0.0&#10;    balances_response_meta = {}&#10;    try:&#10;        resp = api_request('get', '/balances', timeout=6)&#10;        if resp and resp.status_code == 200:&#10;            j = resp.json()&#10;            # API returns {'balances': [...], 'reported_krw_balance':..., 'cached':..., 'cached_ts':...}&#10;            if isinstance(j, dict):&#10;                balances = j.get('balances') if 'balances' in j else j&#10;                reported_krw_from_server = float(j.get('reported_krw_balance') or 0.0)&#10;                balances_response_meta = {k: j.get(k) for k in ('cached','cached_ts') if k in j}&#10;            else:&#10;                balances = j&#10;    except Exception as e:&#10;        api_errors.append(f&quot;/balances 호출 실패: {e}&quot;)&#10;&#10;    try:&#10;        resp2 = api_request('get', '/positions', timeout=6)&#10;        if resp2 and resp2.status_code == 200:&#10;            j2 = resp2.json()&#10;            if isinstance(j2, dict):&#10;                positions_payload = j2&#10;                positions = j2.get('positions')&#10;            else:&#10;                positions = j2&#10;    except Exception as e:&#10;        api_errors.append(f&quot;/positions 호출 실패: {e}&quot;)&#10;&#10;    # If both endpoints failed, try returning /status for diagnostics&#10;    if balances is None and positions is None:&#10;        try:&#10;            resp3 = api_request('get', '/debug/status', timeout=4)&#10;            if resp3 and resp3.status_code == 200:&#10;                st.info('백엔드 상태:')&#10;                st.json(resp3.json())&#10;        except Exception:&#10;            pass&#10;&#10;    # Show API warnings (but avoid noisy raw exceptions)&#10;    for err in api_errors:&#10;        if 'keys not configured' in err or '503' in err:&#10;            st.warning('서버에 API 키가 설정되지 않아 잔고를 조회할 수 없습니다. (관리자 설정 필요)')&#10;        else:&#10;            st.info(err)&#10;&#10;    # Normalize balances into DataFrame&#10;    try:&#10;        if balances and isinstance(balances, list):&#10;            bal_df = pd.DataFrame(balances)&#10;        elif balances and isinstance(balances, dict):&#10;            # sometimes API returns map&#10;            bal_df = pd.DataFrame(balances.get('balances') if 'balances' in balances else [balances])&#10;        else:&#10;            bal_df = pd.DataFrame(columns=['currency', 'balance', 'locked', 'avg_buy_price'])&#10;&#10;        # Accept multiple possible field names and normalize&#10;        if 'currency' not in bal_df.columns and 'unit' in bal_df.columns:&#10;            bal_df = bal_df.rename(columns={'unit': 'currency'})&#10;        if 'currency' not in bal_df.columns and 'coin' in bal_df.columns:&#10;            bal_df = bal_df.rename(columns={'coin': 'currency'})&#10;&#10;        # numeric conversions&#10;        for col in ('balance', 'locked', 'avg_buy_price'):&#10;            if col in bal_df.columns:&#10;                bal_df[col] = pd.to_numeric(bal_df[col], errors='coerce')&#10;&#10;        # If currency column named differently&#10;        if 'currency' not in bal_df.columns and 'currency_name' in bal_df.columns:&#10;            bal_df = bal_df.rename(columns={'currency_name': 'currency'})&#10;&#10;    except Exception:&#10;        bal_df = pd.DataFrame(columns=['currency', 'balance', 'locked', 'avg_buy_price'])&#10;&#10;    # Normalize positions&#10;    try:&#10;        if positions and isinstance(positions, list):&#10;            pos_df = pd.DataFrame(positions)&#10;        elif positions and isinstance(positions, dict):&#10;            pos_df = pd.DataFrame(positions.get('positions') if 'positions' in positions else [positions])&#10;        else:&#10;            pos_df = pd.DataFrame(columns=['symbol','side','qty','entry_price','unrealized_pnl'])&#10;        # common conversions&#10;        for c in ['qty','entry_price','unrealized_pnl','unrealized_pnl_usdt','avg_price']:&#10;            if c in pos_df.columns:&#10;                pos_df[c] = pd.to_numeric(pos_df[c], errors='coerce')&#10;        if 'unrealized_pnl' not in pos_df.columns and 'unrealized_pnl_usdt' in pos_df.columns:&#10;            pos_df['unrealized_pnl'] = pos_df['unrealized_pnl_usdt']&#10;        if 'symbol' not in pos_df.columns and 'ticker' in pos_df.columns:&#10;            pos_df = pos_df.rename(columns={'ticker':'symbol'})&#10;        if 'side' not in pos_df.columns:&#10;            for cand in ('position_side','direction'):&#10;                if cand in pos_df.columns:&#10;                    pos_df['side'] = pos_df[cand]&#10;                    break&#10;    except Exception:&#10;        pos_df = pd.DataFrame(columns=['symbol','side','qty','entry_price','unrealized_pnl'])&#10;&#10;    # Fetch history for chart&#10;    history = []&#10;    try:&#10;        resp_hist = api_request('get', '/positions/history', timeout=8)&#10;        if resp_hist and resp_hist.status_code == 200:&#10;            history = resp_hist.json().get('history', []) or []&#10;    except Exception:&#10;        history = []&#10;&#10;    # Compute KRW-equivalent values for balances using backend price fetch&#10;    try:&#10;        bal_df = bal_df.copy()&#10;        bal_df['currency'] = bal_df['currency'].astype(str)&#10;        # build market tickers for non-KRW currencies (e.g., BTC -&gt; KRW-BTC)&#10;        markets = []&#10;        currency_to_market = {}&#10;        for cur in bal_df['currency'].unique():&#10;            cur_up = cur.upper()&#10;            if cur_up == 'KRW' or cur_up.startswith('KRW'):&#10;                continue&#10;            market = f&quot;KRW-{cur_up}&quot;&#10;            markets.append(market)&#10;            currency_to_market[cur_up] = market&#10;&#10;        price_map: dict = {}&#10;        if markets:&#10;            # fetch latest close price for those markets via backend batch (count=1)&#10;            try:&#10;                kline_map = fetch_klines_batch_from_backend(markets, timeframe='minute1', count=1)&#10;                for m, df in kline_map.items():&#10;                    price = None&#10;                    try:&#10;                        if df is not None and hasattr(df, 'empty') and not df.empty and 'close' in df.columns:&#10;                            # get last available close&#10;                            price = float(df['close'].iloc[-1])&#10;                    except Exception:&#10;                        price = None&#10;                    price_map[m] = price&#10;            except Exception:&#10;                price_map = {}&#10;&#10;        # add price_krw and value_krw columns&#10;        def _get_price_krw(cur):&#10;            try:&#10;                cu = str(cur).upper()&#10;                if cu == 'KRW' or cu.startswith('KRW'):&#10;                    return 1.0&#10;                m = currency_to_market.get(cu)&#10;                if not m:&#10;                    return None&#10;                return price_map.get(m)&#10;            except Exception:&#10;                return None&#10;&#10;        bal_df['price_krw'] = bal_df['currency'].apply(_get_price_krw)&#10;        # value_krw: for KRW currency, balance is already KRW; otherwise balance * price_krw&#10;        def _compute_value(row):&#10;            try:&#10;                bal = float(row.get('balance') or 0)&#10;            except Exception:&#10;                bal = 0.0&#10;            pr = row.get('price_krw')&#10;            cur = str(row.get('currency') or '').upper()&#10;            if cur == 'KRW' or cur.startswith('KRW'):&#10;                return bal&#10;            if pr is None:&#10;                return None&#10;            return bal * float(pr)&#10;&#10;        bal_df['value_krw'] = bal_df.apply(_compute_value, axis=1)&#10;&#10;    except Exception:&#10;        # fallback to original simple KRW sum&#10;        bal_df['price_krw'] = None&#10;        bal_df['value_krw'] = None&#10;&#10;    # Top metrics: use server-reported KRW cash and compute converted asset value from available prices only&#10;    available_krw_payload = float(positions_payload.get('available_krw') or 0.0)&#10;    total_equity_payload = float(positions_payload.get('total_equity_krw') or 0.0)&#10;    excluded_assets = positions_payload.get('excluded_assets') or []&#10;    krw_cash = float(available_krw_payload or reported_krw_from_server or 0.0)&#10;    conv_sum = total_equity_payload if total_equity_payload else 0.0&#10;    try:&#10;        if not bal_df.empty and 'value_krw' in bal_df.columns and 'currency' in bal_df.columns:&#10;            # only include non-KRW assets where value_krw is a real number (not None/NaN)&#10;            nonkrw = bal_df[~bal_df['currency'].astype(str).str.upper().str.contains('KRW', na=False)]&#10;            conv_sum = float(nonkrw['value_krw'].dropna().sum())&#10;    except Exception:&#10;        conv_sum = 0.0&#10;&#10;    # Compute total unrealized PnL&#10;    total_unrealized = 0.0&#10;    try:&#10;        if not pos_df.empty and 'unrealized_pnl' in pos_df.columns:&#10;            total_unrealized = pos_df['unrealized_pnl'].dropna().sum()&#10;    except Exception:&#10;        total_unrealized = 0.0&#10;&#10;    c1, c2, c3 = st.columns(3)&#10;    c1.metric('원화 현금 잔고', f&quot;{krw_cash:,.0f} 원&quot;)&#10;    c2.metric('평가자산 총액(원)', f&quot;{(total_equity_payload or (krw_cash + conv_sum)):,.0f} 원&quot;)&#10;    c3.metric('총 미확정 손익', f&quot;{total_unrealized:,.0f} 원&quot;)&#10;&#10;    # Show balances table with KRW conversion columns&#10;    try:&#10;        # Prepare display dataframe&#10;        if not bal_df.empty:&#10;            disp = bal_df[['currency', 'balance', 'price_krw', 'value_krw']].copy()&#10;&#10;            def _fmt_amount(v):&#10;                try:&#10;                    if v is None or (isinstance(v, float) and pd.isna(v)):&#10;                        return '-'&#10;                    f = float(v)&#10;                    if abs(f) &gt;= 1:&#10;                        return f&quot;{f:,.0f}&quot;&#10;                    return f&quot;{f:.8f}&quot;&#10;                except Exception:&#10;                    return str(v)&#10;&#10;            def _fmt_price(v):&#10;                try:&#10;                    if v is None or (isinstance(v, float) and pd.isna(v)):&#10;                        return '-'&#10;                    f = float(v)&#10;                    if f &gt;= 1:&#10;                        return f&quot;{f:,.0f}&quot;&#10;                    return f&quot;{f:.8f}&quot;&#10;                except Exception:&#10;                    return str(v)&#10;&#10;            disp['잔고'] = disp['balance'].apply(_fmt_amount)&#10;            disp['현재가(원)'] = disp['price_krw'].apply(_fmt_price)&#10;            disp['가치(원)'] = disp['value_krw'].apply(lambda v: _fmt_amount(v) if v is not None and not pd.isna(v) else '-')&#10;            disp = disp.rename(columns={'currency': '화폐'})&#10;            disp = disp[['화폐', '잔고', '현재가(원)', '가치(원)']]&#10;            _safe_dataframe(disp, hide_index=True)&#10;&#10;            # show total caption and note missing price entries&#10;            missing_prices = bal_df[bal_df['value_krw'].isna() &amp; ~bal_df['currency'].astype(str).str.upper().str.contains('KRW')]['currency'].tolist()&#10;            st.caption(f&quot;추정 포트폴리오 총액(원화, 현금+환산): {krw_cash+conv_sum:,.0f} 원&quot;)&#10;            if missing_prices:&#10;                st.info(f&quot;아래 종목은 현재가가 없어 환산에서 제외되었습니다: {', '.join(missing_prices)}&quot;)&#10;        else:&#10;            st.info('잔고 정보가 없습니다.')&#10;    except Exception as e:&#10;        st.warning(f'잔고 테이블 표시 중 오류: {e}')&#10;&#10;    st.divider()&#10;&#10;    # Positions table and PnL chart&#10;    try:&#10;        if pos_df.empty:&#10;            st.info('보유 포지션이 없습니다.')&#10;        else:&#10;            # ensure required columns exist even if backend omits them&#10;            required_cols = ['symbol', 'size', 'entry_price', 'current_price', 'unrealized_pnl', 'unrealized_pnl_rate', 'notional_krw']&#10;            for col in required_cols:&#10;                if col not in pos_df.columns:&#10;                    pos_df[col] = None&#10;            disp = pos_df[required_cols].copy()&#10;            disp = disp.rename(columns={&#10;                'symbol': '종목티커',&#10;                'size': '수량',&#10;                'entry_price': '진입가격',&#10;                'current_price': '현재가격',&#10;                'unrealized_pnl': '평가손익',&#10;                'unrealized_pnl_rate': '손익비율',&#10;                'notional_krw': '평가금액',&#10;            })&#10;            for col in ('수량','진입가격','현재가격','평가손익','평가금액'):&#10;                disp[col] = disp[col].map(lambda v: f&quot;{float(v):,.0f}&quot; if v not in (None, '') and pd.notna(v) else '-')&#10;            disp['손익비율'] = disp['손익비율'].map(lambda v: f&quot;{float(v):.2f}%&quot; if v not in (None, '') and pd.notna(v) else '-')&#10;            _safe_dataframe(disp, hide_index=True)&#10;            if excluded_assets:&#10;                symbols = [item.get('symbol') for item in excluded_assets if isinstance(item, dict) and item.get('symbol')]&#10;                if symbols:&#10;                    st.info(f&quot;현재가 미수신으로 제외된 종목: {', '.join(symbols)}&quot;)&#10;            st.caption(f&quot;산출된 포지션: {len(disp)}개 · 가격 조회된 종목: {positions_payload.get('prices_fetched', 0)}개&quot;)&#10;            if history:&#10;                chart_cols = st.columns(2)&#10;                line_rows = []&#10;                for record in sorted(history, key=lambda item: item.get('ts', 0)):&#10;                    ts_value = float(record.get('ts', 0))&#10;                    row = {'date': pd.to_datetime(ts_value, unit='s', errors='coerce')}&#10;                    for snapshot in record.get('positions', []):&#10;                        symbol = snapshot.get('symbol')&#10;                        notional = snapshot.get('notional_krw')&#10;                        if symbol and notional is not None:&#10;                            row[symbol] = float(notional)&#10;                    line_rows.append(row)&#10;                if line_rows:&#10;                    line_df = pd.DataFrame(line_rows).set_index('date').sort_index()&#10;                else:&#10;                    line_df = pd.DataFrame()&#10;&#10;                # Time-series line chart for position values&#10;                with chart_cols[0]:&#10;                    st.subheader('포지션 가치 추이')&#10;                    if line_df.empty:&#10;                        st.info('포지션 가치 변화 차트에 사용할 데이터가 없습니다.')&#10;                    else:&#10;                        fig_line = go.Figure()&#10;                        for sym in line_df.columns:&#10;                            if sym == 'date':&#10;                                continue&#10;                            fig_line.add_trace(go.Scatter(&#10;                                x=line_df.index,&#10;                                y=line_df[sym],&#10;                                mode='lines',&#10;                                name=sym,&#10;                                hovertemplate='%{x}&lt;br&gt;%{y:,.0f} 원&lt;extra&gt;&lt;/extra&gt;'&#10;                            ))&#10;                        fig_line.update_layout(title='포지션별 가치 변화', xaxis_title='날짜', yaxis_title='가치 (KRW)', margin=dict(l=10,r=10,t=30,b=30), height=320)&#10;                        _safe_plotly_chart(fig_line)&#10;&#10;                # Bar chart for unrealized PnL&#10;                with chart_cols[1]:&#10;                    st.subheader('포지션별 손익 현황')&#10;                    pnl_df = pos_df[['symbol','unrealized_pnl']].copy()&#10;                    pnl_df = pnl_df.sort_values('unrealized_pnl')&#10;                    if pnl_df['unrealized_pnl'].dropna().empty:&#10;                        st.info('손익 차트에 사용할 데이터가 부족합니다.')&#10;                    else:&#10;                        colors = ['#d64f3a' if v&gt;0 else '#1e40af' for v in pnl_df['unrealized_pnl'].fillna(0)]&#10;                        fig_bar = go.Figure()&#10;                        fig_bar.add_trace(go.Bar(&#10;                            x=pnl_df['symbol'],&#10;                            y=pnl_df['unrealized_pnl'],&#10;                            marker_color=colors,&#10;                            name='평가손익',&#10;                            hovertemplate='%{x}&lt;br&gt;%{y:,.0f}원&lt;extra&gt;&lt;/extra&gt;'&#10;                        ))&#10;                        fig_bar.update_layout(title='포지션별 손익', xaxis_title='종목', yaxis_title='손익 (원)', bargap=0.2, margin=dict(l=10,r=10,t=30,b=30), height=320)&#10;                        fig_bar.update_yaxes(zeroline=True, zerolinewidth=2, zerolinecolor='#94a3b8')&#10;                        _safe_plotly_chart(fig_bar)&#10;    except Exception as e:&#10;        st.error(f'포지션 표시 중 오류: {e}')&#10;&#10;&#10;def fetch_ai_history(limit: int = 100):&#10;    try:&#10;        resp = api_request('get', '/ai/history', params={'limit': limit}, timeout=10)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def fetch_bot_status():&#10;    try:&#10;        resp = api_request('get', '/bot/status', timeout=5)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def update_bot_control_api(enabled: Optional[bool] = None, interval_sec: Optional[float] = None):&#10;    payload = {}&#10;    if enabled is not None:&#10;        payload['enabled'] = enabled&#10;    if interval_sec is not None:&#10;        payload['interval_sec'] = interval_sec&#10;    if not payload:&#10;        return None, RuntimeError('enabled 또는 interval_sec 중 하나가 필요합니다.')&#10;    try:&#10;        resp = api_request('post', '/bot/control', json=payload, timeout=10)&#10;        return resp.json(), None&#10;    except Exception as exc:&#10;        return None, exc&#10;&#10;&#10;def render_bot_control_page():&#10;    st.title('자동매매봇 관리')&#10;    st.write('서버의 trading_bot 실행 여부, 검사 주기 등을 바꿀 수 있는 제어 화면입니다.')&#10;    status, err = fetch_bot_status()&#10;    if err:&#10;        st.error(f'봇 상태 조회 실패: {err}')&#10;        status = {}&#10;    enabled = bool(status.get('bot_enabled'))&#10;    interval = float(status.get('bot_interval_sec', cfg.get('loop_interval_sec', 5)))&#10;    st.metric('자동매매 허용', '활성' if enabled else '중지됨')&#10;    st.metric('검사 주기(초)', f'{interval:.1f}')&#10;&#10;    with st.form('bot_control_form'):&#10;        desired_interval = st.number_input('리플레이 주기 (초)', min_value=0.5, value=interval, step=0.5)&#10;        col1, col2, col3 = st.columns(3)&#10;        start = col1.form_submit_button('봇 시작')&#10;        stop = col2.form_submit_button('봇 중지')&#10;        update = col3.form_submit_button('주기 저장')&#10;        if start:&#10;            _, err = update_bot_control_api(enabled=True, interval_sec=desired_interval)&#10;            if err:&#10;                st.error(f'시작 실패: {err}')&#10;            else:&#10;                st.success('봇 시작 요청 완료')&#10;                _trigger_rerun()&#10;        if stop:&#10;            _, err = update_bot_control_api(enabled=False)&#10;            if err:&#10;                st.error(f'중지 실패: {err}')&#10;            else:&#10;                st.warning('봇 정지 요청 완료')&#10;                _trigger_rerun()&#10;        if update:&#10;            _, err = update_bot_control_api(interval_sec=desired_interval)&#10;            if err:&#10;                st.error(f'주기 업데이트 실패: {err}')&#10;            else:&#10;                st.success('주기를 저장했습니다.')&#10;                _trigger_rerun()&#10;&#10;    st.caption('설정을 바꾼 이후에는 trading_bot 또는 config 재로딩을 확인하세요.')&#10;&#10;&#10;def render_ai_report_page():&#10;    st.title('AI 자문 리포트')&#10;    st.caption('OpenAI와 Gemini가 내린 최신 자문 결과를 한눈에 확인합니다.')&#10;&#10;    history_payload, history_err = fetch_ai_history(limit=100)&#10;    if history_err:&#10;        st.error(f'AI 자문 이력 조회 실패: {history_err}')&#10;        return&#10;&#10;    items = history_payload.get('items') if isinstance(history_payload, dict) else None&#10;    if not items:&#10;        st.info('AI 자문 이력이 아직 없습니다. 봇을 실행해 기록을 쌓아주세요.')&#10;        return&#10;&#10;    latest = items[-1]&#10;    openai_payload = _get_ai_source_payload(latest, 'openai')&#10;    gemini_payload = _get_ai_source_payload(latest, 'gemini')&#10;    latest_ts = _format_ts_kst(latest.get('ts'))&#10;    st.subheader(f'1) 최신 자문 비교 (생성: {latest_ts})')&#10;    latest_cols = st.columns(2, gap='large')&#10;&#10;    def _render_model_card(col, label: str, payload: Dict[str, Any] | None):&#10;        with col:&#10;            st.markdown(f&quot;### {label}&quot;)&#10;            if not payload:&#10;                st.info('데이터 없음')&#10;                return&#10;            decision = payload.get('decision') or payload.get('action') or 'N/A'&#10;            st.metric('결정', decision)&#10;            confidence = _get_ai_confidence(payload)&#10;            conf_str = _format_confidence(confidence)&#10;            if conf_str != '-':&#10;                st.caption(f&quot;신뢰도: {conf_str}&quot;)&#10;            st.caption(f&quot;모델: {payload.get('model', '-')}&quot;)&#10;            reasoning = payload.get('reason') or payload.get('reasoning')&#10;            if reasoning:&#10;                st.write(reasoning)&#10;            with st.expander('원문 JSON 보기', expanded=False):&#10;                st.json(payload)&#10;&#10;    _render_model_card(latest_cols[0], 'OpenAI', openai_payload)&#10;    _render_model_card(latest_cols[1], 'Gemini', gemini_payload)&#10;&#10;    st.subheader('2) 입력 캔들 차트')&#10;    chart_df = _prepare_ai_chart_df(latest)&#10;    if chart_df is None or chart_df.empty:&#10;        st.info('차트 데이터가 없습니다. 마지막 기록에서는 `klines` 필드가 비어 있으므로 차트를 그릴 수 없습니다. `runtime/history/ai_decisions.json`을 확인해서 실제 캔들 데이터를 포함하도록 봇 설정을 조정하세요.')&#10;    else:&#10;        chart_fig = plot_candles_with_indicators(chart_df, cfg.get('market', 'KRW-BTC'), ma_windows=[20, 60], rsi_period=14)&#10;        chart_fig.update_layout(height=520)&#10;        _safe_plotly_chart(chart_fig)&#10;&#10;    st.subheader('3) 입력 전문')&#10;    with st.expander('입력 JSON', expanded=False):&#10;        context_payload = latest.get('context') or {}&#10;        if isinstance(context_payload, str):&#10;            context_payload = _parse_json_field(context_payload)&#10;        st.json(context_payload)&#10;&#10;    st.subheader('4) 자문 히스토리')&#10;    history_rows = []&#10;    for item in reversed(items):&#10;        history_openai = _get_ai_source_payload(item, 'openai')&#10;        history_gemini = _get_ai_source_payload(item, 'gemini')&#10;        history_rows.append({&#10;            '시각(KST)': _format_ts_kst(item.get('ts')),&#10;            '최종 결정': item.get('decision'),&#10;            '사유': item.get('reason'),&#10;            'OpenAI': history_openai.get('decision') if history_openai else '-',&#10;            'OpenAI 신뢰도': _format_confidence(_get_ai_confidence(history_openai)) if history_openai else '-',&#10;            'Gemini': history_gemini.get('decision') if history_gemini else '-',&#10;            'Gemini 신뢰도': _format_confidence(_get_ai_confidence(history_gemini)) if history_gemini else '-',&#10;        })&#10;    df_history = pd.DataFrame(history_rows)&#10;    _safe_dataframe(df_history.fillna('-'), hide_index=True)&#10;&#10;&#10;def _format_confidence(value: Any) -&gt; str:&#10;    if value is None:&#10;        return '-'&#10;    try:&#10;        val = float(value)&#10;    except Exception:&#10;        return str(value)&#10;    if val &gt; 1:&#10;        return f&quot;{val:.1f}%&quot;&#10;    return f&quot;{val * 100:.1f}%&quot;&#10;&#10;&#10;def _format_ts_kst(ts: Any) -&gt; str:&#10;    if ts is None:&#10;        return '-'&#10;    try:&#10;        value = float(ts)&#10;    except Exception:&#10;        return '-'&#10;    if value &gt; 1e12:&#10;        value /= 1000.0&#10;    dt = pd.to_datetime(value, unit='s', utc=True)&#10;    try:&#10;        dt = dt.tz_convert('Asia/Seoul')&#10;    except Exception:&#10;        dt = dt.tz_localize('Asia/Seoul', ambiguous='NaT', nonexistent='shift_forward')&#10;    return dt.strftime('%Y-%m-%d %H:%M:%S')&#10;&#10;&#10;def _parse_json_field(value: Any) -&gt; Any:&#10;    if isinstance(value, str):&#10;        try:&#10;            return json.loads(value)&#10;        except Exception:&#10;            return value&#10;    return value&#10;&#10;&#10;def _get_ai_source_payload(entry: Dict[str, Any], provider: str) -&gt; Optional[Dict[str, Any]]:&#10;    payload = entry.get(provider)&#10;    if isinstance(payload, dict):&#10;        return payload&#10;    sources = entry.get('ai_sources') or {}&#10;    return sources.get(provider) if isinstance(sources, dict) else None&#10;&#10;&#10;def _get_ai_confidence(payload: Any) -&gt; Optional[float]:&#10;    if payload is None:&#10;        return None&#10;    if isinstance(payload, dict) and payload.get('confidence') is not None:&#10;        return payload.get('confidence')&#10;    if isinstance(payload, dict):&#10;        raw = payload.get('raw')&#10;        if raw is not None:&#10;            conf = _get_ai_confidence(raw)&#10;            if conf is not None:&#10;                return conf&#10;    if isinstance(payload, dict):&#10;        for value in payload.values():&#10;            conf = _get_ai_confidence(value)&#10;            if conf is not None:&#10;                return conf&#10;    if isinstance(payload, list):&#10;        for item in payload:&#10;            conf = _get_ai_confidence(item)&#10;            if conf is not None:&#10;                return conf&#10;    return None&#10;&#10;&#10;def _prepare_ai_chart_df(entry: Dict[str, Any]) -&gt; pd.DataFrame | None:&#10;    klines = entry.get('klines')&#10;    if isinstance(klines, str):&#10;        klines = _parse_json_field(klines)&#10;    if not klines:&#10;        context = entry.get('context') or {}&#10;        if isinstance(context, str):&#10;            context = _parse_json_field(context) or {}&#10;        markets = isinstance(context, dict) and context.get('markets') or []&#10;        if markets:&#10;            market = markets[0]&#10;            timeframe = market.get('timeframes', {})&#10;            for tf_cfg in timeframe.values():&#10;                candles = tf_cfg.get('candles') or tf_cfg.get('history') or tf_cfg.get('klines')&#10;                if candles:&#10;                    klines = candles&#10;                    break&#10;        if not klines:&#10;            return None&#10;    try:&#10;        df = pd.DataFrame(klines)&#10;    except Exception:&#10;        return None&#10;    rename_map = {&#10;        't': 'time',&#10;        'candle_date_time_kst': 'time',&#10;        'trade_price': 'close',&#10;        'opening_price': 'open',&#10;        'high_price': 'high',&#10;        'low_price': 'low',&#10;        'volume': 'volume',&#10;    }&#10;    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})&#10;    if 'time' not in df.columns:&#10;        return None&#10;    try:&#10;        df['time'] = pd.to_datetime(df['time'])&#10;    except Exception:&#10;        try:&#10;            df['time'] = pd.to_datetime(df['time'].astype(str))&#10;        except Exception:&#10;            return None&#10;    for col in ['open', 'high', 'low', 'close', 'volume']:&#10;        if col in df.columns:&#10;            df[col] = pd.to_numeric(df[col], errors='coerce')&#10;    df = df.sort_values('time').dropna(subset=['time']).reset_index(drop=True)&#10;    if df.empty:&#10;        return None&#10;    return df&#10;&#10;&#10;# --- Main app logic ---&#10;# Sidebar button menu for page selection (user prefers buttons, fixed order)&#10;sb = st.sidebar&#10;sb.title('업비트 트레이더')&#10;sb.caption('원하는 기능으로 바로 가기')&#10;&#10;# Fixed NAV order requested by user&#10;NAV_OPTIONS = [&#10;    'WebSocket 모니터링',&#10;    '종목스크리닝',&#10;    'AI 자문 리포트',&#10;    '자동매매봇 관리',&#10;    '원화잔고 및 포지션 분석',&#10;    '설정 편집',&#10;]&#10;&#10;# Ensure page state exists&#10;if 'page' not in st.session_state:&#10;    st.session_state['page'] = NAV_OPTIONS[0]&#10;&#10;selected_tab = st.session_state['page']&#10;nav_container = sb.container()&#10;pending_selection = None&#10;for nav_option in NAV_OPTIONS:&#10;    is_selected = selected_tab == nav_option&#10;    btn_type = 'primary' if is_selected else 'secondary'&#10;    try:&#10;        clicked = nav_container.button(&#10;            nav_option,&#10;            key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;,&#10;            width='stretch',&#10;            type=btn_type,&#10;        )&#10;    except TypeError:&#10;        # Older Streamlit doesn't support `type` or `width` kwargs; try fallbacks&#10;        try:&#10;            clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;, use_container_width=True)&#10;        except Exception:&#10;            clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;)&#10;    if clicked:&#10;        pending_selection = nav_option&#10;&#10;if pending_selection and pending_selection != selected_tab:&#10;    st.session_state['page'] = pending_selection&#10;    # trigger a rerun so UI reflects selection immediately&#10;    try:&#10;        rerun_fn = getattr(st, 'rerun', None) or getattr(st, 'experimental_rerun', None)&#10;        if rerun_fn:&#10;            rerun_fn()&#10;    except Exception:&#10;        pass&#10;&#10;# page dispatch using session state&#10;page = st.session_state.get('page', NAV_OPTIONS[0])&#10;if page == 'WebSocket 모니터링':&#10;    render_ws_monitoring_page()&#10;elif page == '종목스크리닝':&#10;    render_screening_page()&#10;elif page == 'AI 자문 리포트':&#10;    render_ai_report_page()&#10;elif page == '원화잔고 및 포지션 분석':&#10;    try:&#10;        render_positions_page()&#10;    except Exception as e:&#10;        st.error(f'원화잔고/포지션 페이지 렌더링 중 오류: {e}')&#10;elif page == '설정 편집':&#10;    render_config_page(cfg)&#10;elif page == '자동매매봇 관리':&#10;    render_bot_control_page()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>