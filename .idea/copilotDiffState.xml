<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ui/ui_dashboard.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/ui_dashboard.py" />
              <option name="originalContent" value="import streamlit as st&#10;# reload-test: touch ui file to verify backend reload behavior (do not remove)&#10;import requests&#10;from requests.adapters import HTTPAdapter&#10;from urllib3.util.retry import Retry&#10;from pathlib import Path&#10;from typing import Any, Dict, Tuple&#10;import pandas as pd&#10;import plotly.graph_objects as go&#10;from plotly.subplots import make_subplots&#10;import time&#10;import random&#10;import os&#10;# Ensure process timezone is KST (Asia/Seoul) so Streamlit displays local times correctly&#10;os.environ.setdefault('TZ', 'Asia/Seoul')&#10;try:&#10;    time.tzset()&#10;except Exception:&#10;    # time.tzset may not be available on all platforms (Windows), ignore if unavailable&#10;    pass&#10;&#10;# Import configuration helpers from server package&#10;try:&#10;    from server.config import load_config, save_config as save_local&#10;except Exception:&#10;    # In case UI runs in an environment where server package isn't available on PYTHONPATH,&#10;    # fall back to a stub that will raise an informative error when used.&#10;    def load_config():&#10;        raise RuntimeError('server.config.load_config not available in PYTHONPATH')&#10;&#10;    def save_local(cfg):&#10;        raise RuntimeError('server.config.save_config not available in PYTHONPATH')&#10;&#10;&#10;def validate_config(cfg: Dict[str, Any]) -&gt; Tuple[bool, str]:&#10;    &quot;&quot;&quot;Basic validation for runtime config used by the UI form.&#10;    Returns (True, '') if valid, otherwise (False, 'reason').&#10;    &quot;&quot;&quot;&#10;    if not isinstance(cfg, dict):&#10;        return False, '설정 데이터가 딕셔너리가 아닙니다.'&#10;    if not cfg.get('market'):&#10;        return False, 'Market 값이 필요합니다.'&#10;    if not isinstance(cfg.get('candle_count', 0), int) or cfg.get('candle_count', 0) &lt;= 0:&#10;        return False, 'Candle count 는 1 이상의 정수여야 합니다.'&#10;    order = cfg.get('order_settings', {})&#10;    if not isinstance(order.get('trade_amount_krw', 0), (int, float)) or order.get('trade_amount_krw', 0) &lt;= 0:&#10;        return False, 'Trade amount_krw 는 0보다 큰 숫자여야 합니다.'&#10;    kelly = cfg.get('kelly_criterion', {})&#10;    if cfg.get('use_kelly_criterion'):&#10;        wr = float(kelly.get('win_rate', 0))&#10;        pr = float(kelly.get('payoff_ratio', 0))&#10;        frac = float(kelly.get('fraction', 0))&#10;        if not (0 &lt;= wr &lt;= 1):&#10;            return False, 'Kelly win_rate 는 0~1 범위여야 합니다.'&#10;        if pr &lt;= 0:&#10;            return False, 'Kelly payoff_ratio 는 양수여야 합니다.'&#10;        if not (0 &lt;= frac &lt;= 1):&#10;            return False, 'Kelly fraction 은 0~1 범위여야 합니다.'&#10;    return True, ''&#10;&#10;&#10;RUNTIME_CONFIG = Path(__file__).resolve().parents[1] / 'runtime' / 'config.json'&#10;&#10;st.set_page_config(page_title='Upbit Trader', layout='wide')&#10;&#10;# Helper to render DataFrame safely across Streamlit versions and hide index when requested&#10;def _safe_dataframe(df: 'pd.DataFrame', hide_index: bool = False, **kwargs):&#10;    &quot;&quot;&quot;Render a pandas DataFrame while attempting to hide the index and use full width.&#10;    Tries the newer `width='stretch'` API first, then falls back to `use_container_width=True`,&#10;    and finally to the basic st.dataframe if needed.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return st.dataframe(df, hide_index=hide_index, width='stretch', **kwargs)&#10;    except TypeError:&#10;        try:&#10;            return st.dataframe(df, hide_index=hide_index, use_container_width=True, **kwargs)&#10;        except TypeError:&#10;            # Older Streamlit may not support hide_index; fallback to st.table (no hide)&#10;            try:&#10;                return st.table(df)&#10;            except Exception:&#10;                return st.write(df)&#10;&#10;&#10;# API base URL for backend calls: read from env var STREAMLIT_API_BASE (set by docker-compose)&#10;# If not set, fall back to localhost for local development.&#10;API_BASE = os.getenv('STREAMLIT_API_BASE', 'http://127.0.0.1:8000')&#10;&#10;# Create a requests session with retry/backoff to make UI-server comms more resilient&#10;def _build_session():&#10;    session = requests.Session()&#10;    retries = Retry(&#10;        total=3,&#10;        backoff_factor=0.6,&#10;        status_forcelist=(429, 500, 502, 503, 504),&#10;        allowed_methods=(&quot;GET&quot;, &quot;POST&quot;),&#10;        raise_on_status=False,&#10;    )&#10;    adapter = HTTPAdapter(max_retries=retries)&#10;    session.mount(&quot;http://&quot;, adapter)&#10;    session.mount(&quot;https://&quot;, adapter)&#10;    return session&#10;&#10;_API_SESSION = _build_session()&#10;&#10;def api_request(method: str, path: str, params=None, json=None, timeout=10):&#10;    &quot;&quot;&quot;Call server API with retries and return requests.Response or raise Exception with friendly message.&quot;&quot;&quot;&#10;    if not API_BASE:&#10;        raise RuntimeError(&quot;API Base URL is not set in the sidebar&quot;)&#10;    url = API_BASE.rstrip(&quot;/&quot;) + &quot;/&quot; + path.lstrip(&quot;/&quot;)&#10;    try:&#10;        if method.lower() == &quot;get&quot;:&#10;            resp = _API_SESSION.get(url, params=params, timeout=timeout)&#10;        else:&#10;            resp = _API_SESSION.post(url, json=json, timeout=timeout)&#10;        resp.raise_for_status()&#10;        return resp&#10;    except requests.exceptions.RequestException as e:&#10;        # Wrap low-level error to present user-friendly message in UI&#10;        raise RuntimeError(f&quot;서버 호출 실패: {e}&quot;) from e&#10;&#10;&#10;# --- Upbit public klines helper (cached) ---&#10;@st.cache_data(ttl=10)&#10;def fetch_klines_cached(market: str, timeframe: str = 'minute1', count: int = 200) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;&#10;    UI-side fetch function disabled.&#10;    The UI must not call Upbit public API directly — always go through the backend `/klines_batch` endpoint.&#10;    This function returns None to force the UI to rely on backend data and avoid causing 429 Too Many Requests.&#10;    &quot;&quot;&quot;&#10;    # Return None immediately to prevent direct Upbit calls from the UI.&#10;    st.warning('UI는 직접 Upbit 호출을 하지 않습니다. 백엔드의 prefetch가 완료될 때까지 대기하세요.')&#10;    return None&#10;&#10;&#10;def fetch_klines_batch_from_backend(tickers: list[str], timeframe: str = 'minute15', count: int = 100) -&gt; Dict[str, pd.DataFrame | None]:&#10;    &quot;&quot;&quot;Call server /klines_batch to get klines for multiple tickers. Returns mapping ticker-&gt;DataFrame or None.&#10;    Falls back to empty dict on error.&#10;    &quot;&quot;&quot;&#10;    url = f&quot;{API_BASE.rstrip('/')}/klines_batch&quot;&#10;    try:&#10;        resp = requests.post(url, json={'tickers': tickers, 'timeframe': timeframe, 'count': count}, timeout=15)&#10;        resp.raise_for_status()&#10;        data = resp.json().get('klines', {})&#10;        result = {}&#10;        for t, v in data.items():&#10;            if not v:&#10;                result[t] = None&#10;                continue&#10;            df = pd.DataFrame(v)&#10;            df = df.rename(columns={&#10;                'candle_date_time_kst': 'time',&#10;                'opening_price': 'open',&#10;                'high_price': 'high',&#10;                'low_price': 'low',&#10;                'trade_price': 'close',&#10;                'candle_acc_trade_volume': 'volume'&#10;            })&#10;            cols = [c for c in ['time','open','high','low','close','volume'] if c in df.columns]&#10;            df = df[cols]&#10;            if 'time' in df.columns:&#10;                df['time'] = pd.to_datetime(df['time'])&#10;            for col in ['open','high','low','close','volume']:&#10;                if col in df.columns:&#10;                    df[col] = pd.to_numeric(df[col], errors='coerce')&#10;            df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;            result[t] = df&#10;        return result&#10;    except Exception as e:&#10;        st.warning(f'백엔드 batch klines 호출 실패: {e}')&#10;        return {}&#10;&#10;&#10;def _normalize_klines_df(df: pd.DataFrame | None, min_length: int = 30) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;Validate and normalize a kline DataFrame for plotting.&#10;    - Ensures time column exists and is datetime&#10;    - Renames common Upbit keys if needed&#10;    - Sorts ascending by time, drops duplicate timestamps&#10;    - Converts numeric columns and fills small gaps&#10;    - Returns None if data is invalid&#10;    &quot;&quot;&quot;&#10;    if df is None:&#10;        return None&#10;    # Accept list-of-dicts as well&#10;    if not isinstance(df, pd.DataFrame):&#10;        try:&#10;            df = pd.DataFrame(df)&#10;        except Exception:&#10;            return None&#10;&#10;    # Map common Upbit field names to expected ones&#10;    rename_map = {&#10;        'candle_date_time_kst': 'time',&#10;        'opening_price': 'open',&#10;        'high_price': 'high',&#10;        'low_price': 'low',&#10;        'trade_price': 'close',&#10;        'candle_acc_trade_volume': 'volume'&#10;    }&#10;    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})&#10;&#10;    # required columns&#10;    required = ['time', 'open', 'high', 'low', 'close', 'volume']&#10;    if 'time' not in df.columns:&#10;        return None&#10;&#10;    # time -&gt; datetime&#10;    try:&#10;        df['time'] = pd.to_datetime(df['time'])&#10;    except Exception:&#10;        try:&#10;            df['time'] = pd.to_datetime(df['time'].astype(str))&#10;        except Exception:&#10;            return None&#10;&#10;    # sort ascending and dedupe&#10;    df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;    if df['time'].duplicated().any():&#10;        df = df[~df['time'].duplicated(keep='last')].reset_index(drop=True)&#10;&#10;    # ensure numeric&#10;    for col in ['open', 'high', 'low', 'close', 'volume']:&#10;        if col in df.columns:&#10;            df[col] = pd.to_numeric(df[col], errors='coerce')&#10;        else:&#10;            df[col] = pd.NA&#10;&#10;    # fill small gaps for price columns&#10;    try:&#10;        df[['open', 'high', 'low', 'close']] = df[['open', 'high', 'low', 'close']].ffill().bfill()&#10;        df['volume'] = df['volume'].fillna(0)&#10;    except Exception:&#10;        pass&#10;&#10;    if len(df) &lt; min_length:&#10;        st.warning(f'차트에 필요한 데이터가 부족합니다: {len(df)}개 (최소 {min_length} 필요)')&#10;        return df&#10;    return df&#10;&#10;&#10;# --- Indicator helpers and plotting ---&#10;def compute_rsi(series: pd.Series, period: int = 14) -&gt; pd.Series:&#10;    # Standard Wilder's RSI calculation without forcing initial values to 0.&#10;    delta = series.diff()&#10;    up = delta.clip(lower=0)&#10;    down = -1 * delta.clip(upper=0)&#10;    ma_up = up.rolling(period, min_periods=period).mean()&#10;    ma_down = down.rolling(period, min_periods=period).mean()&#10;    rs = ma_up / ma_down&#10;    rsi = 100 - (100 / (1 + rs))&#10;    return rsi&#10;&#10;&#10;def plot_candles_with_indicators(df: pd.DataFrame, ticker: str, ma_windows: list[int], rsi_period: int):&#10;    # Create subplot: row1 = candlestick+MA, row2 = volume bars, row3 = RSI&#10;    fig = make_subplots(rows=3, cols=1, shared_xaxes=True, row_heights=[0.6, 0.2, 0.2], vertical_spacing=0.03)&#10;&#10;    # Row 1: Candlestick — set colors: rising(red), falling(blue)&#10;    fig.add_trace(go.Candlestick(x=df['time'], open=df['open'], high=df['high'], low=df['low'], close=df['close'], name='OHLC', increasing=dict(line=dict(color='red'), fillcolor='red'), decreasing=dict(line=dict(color='blue'), fillcolor='blue')), row=1, col=1)&#10;&#10;    # moving averages on top&#10;    for w in ma_windows:&#10;        ma = df['close'].rolling(w).mean()&#10;        fig.add_trace(go.Scatter(x=df['time'], y=ma, mode='lines', name=f'MA{w}', line=dict(width=1.2)), row=1, col=1)&#10;&#10;    # Row 2: Volume bars&#10;    # color volume bars green when close &gt;= open else red&#10;    try:&#10;        # rising -&gt; red, falling -&gt; blue&#10;        colors = ['red' if c &gt;= o else 'blue' for o, c in zip(df['open'], df['close'])]&#10;    except Exception:&#10;        colors = 'gray'&#10;    fig.add_trace(go.Bar(x=df['time'], y=df['volume'], name='Volume', marker=dict(color=colors), hovertemplate='Volume: %{y:,.0f}&lt;extra&gt;&lt;/extra&gt;'), row=2, col=1)&#10;    # Keep volume axis independent&#10;    fig.update_yaxes(title_text='Volume', row=2, col=1)&#10;&#10;    # Row 3: RSI&#10;    rsi = compute_rsi(df['close'], period=rsi_period)&#10;    fig.add_trace(go.Scatter(x=df['time'], y=rsi, mode='lines', name=f'RSI({rsi_period})', line=dict(color='purple', width=2.0), connectgaps=False, hovertemplate='RSI: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'), row=3, col=1)&#10;    # RSI bands (draw as shapes for visibility)&#10;    fig.add_hline(y=70, line=dict(color='red', dash='dash'), row=3, col=1)&#10;    fig.add_hline(y=30, line=dict(color='green', dash='dash'), row=3, col=1)&#10;    fig.update_yaxes(range=[0,100], row=3, col=1)&#10;&#10;    # layout tweaks&#10;    fig.update_layout(height=520, margin=dict(l=10, r=10, t=30, b=20), showlegend=True, hovermode='x unified')&#10;    fig.update_xaxes(rangebreaks=[dict(bounds=[&quot;sat&quot;,&quot;mon&quot;])], rangeslider_visible=False)&#10;    return fig&#10;&#10;&#10;# Load existing config&#10;cfg = load_config()&#10;&#10;# --- Page renderers ---&#10;&#10;def render_config_page(cfg: Dict[str, Any]):&#10;    st.title('설정 편집')&#10;    with st.form('config_form', clear_on_submit=False):&#10;        strategy_name = st.selectbox('전략 선택', options=['VolatilityBreakout', 'DualMomentum', 'RSI'], index=['VolatilityBreakout', 'DualMomentum', 'RSI'].index(cfg.get('strategy_name', 'VolatilityBreakout')) if cfg.get('strategy_name') in ['VolatilityBreakout', 'DualMomentum', 'RSI'] else 0)&#10;        market = st.text_input('Market (예: KRW-BTC)', value=cfg.get('market', 'KRW-BTC'))&#10;        timeframe = st.text_input('Timeframe (예: minute5)', value=cfg.get('timeframe', 'minute5'))&#10;        candle_count = st.number_input('Candle count', min_value=1, value=int(cfg.get('candle_count', 200)))&#10;        loop_interval_sec = st.number_input('Loop interval (sec)', min_value=1, value=int(cfg.get('loop_interval_sec', 5)))&#10;&#10;        st.subheader('주문 설정')&#10;        order_settings = cfg.get('order_settings', {})&#10;        min_order_amount = st.number_input('Min order amount (KRW)', min_value=1000, value=int(order_settings.get('min_order_amount', 5500)))&#10;        trade_amount_krw = st.number_input('Trade amount (KRW)', min_value=1000, value=int(order_settings.get('trade_amount_krw', 6000)))&#10;&#10;        st.subheader('켈리공식 설정')&#10;        use_kelly = st.checkbox('Kelly 적용', value=bool(cfg.get('use_kelly_criterion', True)))&#10;        kelly = cfg.get('kelly_criterion', {})&#10;        win_rate = st.number_input('Win rate (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('win_rate', 0.65)))&#10;        payoff_ratio = st.number_input('Payoff ratio', min_value=0.0, value=float(kelly.get('payoff_ratio', 1.2)))&#10;        fraction = st.number_input('Fraction (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('fraction', 0.5)))&#10;&#10;        st.subheader('전략별 파라미터')&#10;        strategy_params = cfg.get('strategy_params', {})&#10;        if strategy_name == 'RSI':&#10;            rsi = strategy_params.get('RSI', {})&#10;            rsi_period = st.number_input('RSI period', min_value=1, value=int(rsi.get('period', 14)))&#10;            rsi_oversold = st.number_input('RSI oversold', min_value=0, max_value=100, value=int(rsi.get('oversold', 30)))&#10;            rsi_overbought = st.number_input('RSI overbought', min_value=0, max_value=100, value=int(rsi.get('overbought', 70)))&#10;        elif strategy_name == 'VolatilityBreakout':&#10;            vb = strategy_params.get('VolatilityBreakout', {})&#10;            k_value = st.number_input('k value (0~1)', min_value=0.0, max_value=1.0, value=float(vb.get('k_value', 0.5)))&#10;        elif strategy_name == 'DualMomentum':&#10;            dm = strategy_params.get('DualMomentum', {})&#10;            window = st.number_input('Window (periods)', min_value=1, value=int(dm.get('window', 12)))&#10;&#10;        submit = st.form_submit_button('미리보기 업데이트')&#10;&#10;    new_cfg = {&#10;        'strategy_name': strategy_name,&#10;        'market': market,&#10;        'timeframe': timeframe,&#10;        'candle_count': candle_count,&#10;        'loop_interval_sec': loop_interval_sec,&#10;        'order_settings': {&#10;            'min_order_amount': min_order_amount,&#10;            'trade_amount_krw': trade_amount_krw,&#10;        },&#10;        'use_kelly_criterion': use_kelly,&#10;        'kelly_criterion': {&#10;            'win_rate': win_rate,&#10;            'payoff_ratio': payoff_ratio,&#10;            'fraction': fraction,&#10;        },&#10;        'strategy_params': {}&#10;    }&#10;&#10;    if strategy_name == 'RSI':&#10;        new_cfg['strategy_params']['RSI'] = {&#10;            'period': rsi_period,&#10;            'oversold': rsi_oversold,&#10;            'overbought': rsi_overbought,&#10;        }&#10;    elif strategy_name == 'VolatilityBreakout':&#10;        new_cfg['strategy_params']['VolatilityBreakout'] = {'k_value': k_value}&#10;    elif strategy_name == 'DualMomentum':&#10;        new_cfg['strategy_params']['DualMomentum'] = {'window': window}&#10;&#10;    st.divider()&#10;    st.header('설정 액션')&#10;    valid, message = validate_config(new_cfg)&#10;    if not valid:&#10;        st.error('유효성 검사 실패: ' + message)&#10;&#10;    col_a, col_b, col_c = st.columns(3)&#10;    with col_a:&#10;        if st.button('로컬에 저장'):&#10;            if not valid:&#10;                st.error('저장 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    save_local(new_cfg)&#10;                    st.success('저장 완료: runtime/config.json')&#10;                except Exception as e:&#10;                    st.error('로컬 저장 실패: ' + str(e))&#10;    with col_b:&#10;        if st.button('서버에 전송'):&#10;            if not valid:&#10;                st.error('전송 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    resp = api_request('post', '/config', json={'config': new_cfg}, timeout=10)&#10;                    st.success('서버에 전송 완료')&#10;                except Exception as e:&#10;                    st.error(str(e))&#10;    with col_c:&#10;        if st.button('서버 재로딩 요청'):&#10;            try:&#10;                resp = api_request('post', '/reload', timeout=5)&#10;                st.success('서버 재로딩 요청 성공')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;&#10;&#10;def render_screening_page():&#10;    st.title('종목 스크리닝')&#10;    st.caption('변동성 TOP 종목을 조회합니다. (최근 캔들 기준)')&#10;    st.code('변동성은 (max_high - min_low) / mean_close 로 계산됩니다.')&#10;&#10;    # Controls moved into the page (previously in sidebar)&#10;    ctrl_col1, ctrl_col2, ctrl_col3 = st.columns([1,1,1])&#10;    market_prefix = ctrl_col1.text_input('마켓 접두사 (예: KRW)', value='KRW', key='scr_market_prefix')&#10;    top_n = ctrl_col2.number_input('Top N', min_value=1, max_value=50, value=10, key='scr_top_n')&#10;    # timeframe placed in the third column for grouping&#10;    timeframe = ctrl_col3.selectbox('Timeframe', options=['minute5','minute15','minute60','day'], index=1, key='scr_timeframe')&#10;&#10;    # Place the search button in a dedicated full-width row so it spans the page&#10;    full_row = st.columns([1])[0]&#10;    try:&#10;        # Use width='stretch' when supported&#10;        search_clicked = full_row.button('조회', key='scr_search', width='stretch')&#10;    except TypeError:&#10;        # Fallback for older Streamlit versions&#10;        search_clicked = full_row.button('조회', key='scr_search')&#10;&#10;    # When search clicked, fetch data and then render charts below&#10;    if 'search_clicked' not in st.session_state:&#10;        st.session_state['search_clicked'] = False&#10;    if search_clicked:&#10;        st.session_state['search_clicked'] = True&#10;        # remember last query params to re-render charts on interaction&#10;        st.session_state['last_search'] = {'market_prefix': market_prefix, 'top_n': top_n, 'timeframe': timeframe}&#10;&#10;    if st.session_state.get('search_clicked'):&#10;        params = st.session_state.get('last_search', {})&#10;        try:&#10;            resp = api_request('get', '/screen/volatility_top', params={'market_prefix': params.get('market_prefix','KRW'), 'top_n': params.get('top_n',10), 'timeframe': params.get('timeframe','minute15')}, timeout=10)&#10;            data = resp.json().get('top', [])&#10;            # determine requested N early&#10;            requested_n = int(params.get('top_n', 10))&#10;            # present a ranked table with ranks starting from 1&#10;            df_top = None&#10;            try:&#10;                df_top = pd.DataFrame(data)&#10;                # If volatility present, sort by it descending to ensure ranking order&#10;                if 'volatility' in df_top.columns:&#10;                    df_top = df_top.sort_values(by='volatility', ascending=False).reset_index(drop=True)&#10;                if not df_top.empty:&#10;                    df_top.insert(0, 'rank', range(1, len(df_top) + 1))&#10;                # display table without the default index column&#10;                _safe_dataframe(df_top, hide_index=True)&#10;            except Exception:&#10;                try:&#10;                    df_fallback = pd.DataFrame(data)&#10;                    _safe_dataframe(df_fallback, hide_index=True)&#10;                except Exception:&#10;                    # last resort: plain st.table&#10;                    st.table(data)&#10;&#10;            # build items list from sorted df_top when available, otherwise fallback to raw data&#10;            if isinstance(df_top, pd.DataFrame) and not df_top.empty:&#10;                sorted_items = df_top.to_dict(orient='records')&#10;            else:&#10;                sorted_items = data&#10;&#10;            # Chart controls (placed near the table)&#10;            control_cols = st.columns([1,1,1])&#10;            with control_cols[0]:&#10;                ma1 = st.number_input('MA1 window', min_value=1, value=20, key='ma1_s')&#10;            with control_cols[1]:&#10;                ma2 = st.number_input('MA2 window', min_value=1, value=60, key='ma2_s')&#10;            with control_cols[2]:&#10;                rsi_p = st.number_input('RSI period', min_value=5, value=14, key='rsi_p_s')&#10;&#10;            # limit to requested top_n and render in a grid&#10;            items = sorted_items[:requested_n]&#10;            display_n = len(items)&#10;            # Try batch fetch from backend to reduce Upbit calls&#10;            tickers = [it.get('ticker') for it in items]&#10;            backend_data = fetch_klines_batch_from_backend(tickers, timeframe=params.get('timeframe','minute15'), count=200)&#10;            # If some tickers are missing in the backend result (None), retry via backend a few times&#10;            missing = [t for t in tickers if backend_data.get(t) is None]&#10;            if missing:&#10;                retries = 3&#10;                for attempt in range(1, retries+1):&#10;                    if not missing:&#10;                        break&#10;                    # request only the missing tickers as a batch&#10;                    try:&#10;                        more = fetch_klines_batch_from_backend(missing, timeframe=params.get('timeframe','minute15'), count=200)&#10;                        for k, v in (more or {}).items():&#10;                            backend_data[k] = v&#10;                        # recompute missing list&#10;                        missing = [t for t in tickers if backend_data.get(t) is None]&#10;                    except Exception:&#10;                        # ignore and backoff&#10;                        pass&#10;                    if missing and attempt &lt; retries:&#10;                        time.sleep(0.8 * attempt)&#10;&#10;            # Render rows of 2 columns based on actual display_n&#10;            for row_start in range(0, display_n, 2):&#10;                cols = st.columns(2, gap='small')&#10;                for col_idx in range(2):&#10;                    idx = row_start + col_idx&#10;                    if idx &gt;= display_n:&#10;                        with cols[col_idx]:&#10;                            st.empty()&#10;                        continue&#10;                    item = items[idx]&#10;                    ticker = item.get('ticker')&#10;                    vol = item.get('volatility')&#10;                    with cols[col_idx]:&#10;                        st.subheader(f&quot;{idx+1}. {ticker} — vol={vol:.4f}&quot;)&#10;                        df = backend_data.get(ticker)&#10;                        # normalize/check df before plotting&#10;                        df = _normalize_klines_df(df, min_length=50)&#10;                        if df is None or (hasattr(df, 'empty') and df.empty):&#10;                            # Backend could not provide data (maybe prefetch miss or Upbit limit).&#10;                            # Show a user-friendly message and skip direct Upbit calls from the UI to avoid causing a 429.&#10;                            st.info('차트 데이터를 아직 불러올 수 없습니다. 잠시 후 다시 시도하세요. (백엔드에서 데이터 수집 중일 수 있음)')&#10;                        else:&#10;                            # Create a more compact chart for the grid&#10;                            fig = plot_candles_with_indicators(df, ticker, ma_windows=[ma1, ma2], rsi_period=int(rsi_p))&#10;                            fig.update_layout(height=340, margin=dict(l=10, r=10, t=30, b=20))&#10;                            st.plotly_chart(fig, width='stretch')&#10;                    # slight pause to avoid tight loop/rate limits&#10;                    time.sleep(0.08)&#10;            # show count info&#10;            st.caption(f&quot;표시된 종목: {display_n} / 요청한 TopN: {requested_n}&quot;)&#10;        except Exception as e:&#10;            st.error(str(e))&#10;&#10;&#10;def render_watcher_page(cfg: Dict[str, Any]):&#10;    st.title('이벤트 감시자 관리')&#10;    st.write('웹소켓 대신 폴링(간단) 방식으로 체크를 수행합니다. 서버의 /watcher/start, /watcher/stop를 사용합니다.')&#10;&#10;    watch_market = st.text_input('감시할 마켓', value=cfg.get('market', 'KRW-BTC'))&#10;    watch_interval = st.number_input('체크 간격(초)', min_value=0.2, value=1.0)&#10;    cb_vol_k = st.slider('Volatility K', min_value=0.0, max_value=1.0, value=float(cfg.get('strategy_params', {}).get('VolatilityBreakout', {}).get('k_value', 0.5)))&#10;    cb_vol_mul = st.number_input('Volume Spike Multiplier', min_value=1, value=3)&#10;&#10;    colx, coly = st.columns(2)&#10;    with colx:&#10;        if st.button('Watcher 시작'):&#10;            payload = {&#10;                'market': watch_market,&#10;                'interval': float(watch_interval),&#10;                'callbacks': [&#10;                    {'type': 'volatility_breakout', 'k': float(cb_vol_k)},&#10;                    {'type': 'volume_spike', 'multiplier': int(cb_vol_mul)}&#10;                ]&#10;            }&#10;            try:&#10;                resp = api_request('post', '/watcher/start', json=payload, timeout=10)&#10;                st.success('Watcher 시작 요청 전송됨')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;    with coly:&#10;        if st.button('Watcher 중지'):&#10;            try:&#10;                resp = api_request('post', '/watcher/stop', timeout=10)&#10;                st.success('Watcher 중지 요청 전송됨')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;&#10;&#10;def render_about_page():&#10;    # kept as an unused fallback; keep minimal content&#10;    st.title('도움말 / 정보')&#10;    st.write('이 UI는 여러 페이지로 구성됩니다. 서버가 로컬에서 실행 중이어야 합니다.')&#10;&#10;&#10;# --- Sidebar navigation (pure Streamlit) ---&#10;def _ensure_page_state():&#10;    if 'page' not in st.session_state:&#10;        st.session_state['page'] = '설정 편집'&#10;&#10;&#10;def _rerun_app() -&gt; None:&#10;    &quot;&quot;&quot;Trigger a Streamlit rerun, compatible with new and old APIs.&quot;&quot;&quot;&#10;    rerun_fn = getattr(st, &quot;rerun&quot;, None) or getattr(st, &quot;experimental_rerun&quot;, None)&#10;    if rerun_fn:&#10;        try:&#10;            rerun_fn()&#10;        except Exception:&#10;            # ignore if rerun not permitted in some environments&#10;            pass&#10;&#10;&#10;def _sidebar_menu():&#10;     _ensure_page_state()&#10;     NAV_OPTIONS = ['종목 스크리닝', '이벤트 감시자 관리', '원화잔고 및 포지션 분석', '설정 편집']&#10;     sb = st.sidebar&#10;&#10;     # Small header block (kept minimal). This parallels the user's example but uses&#10;     # only tiny localized CSS. Unsafe HTML is limited to this small header.&#10;     sb.markdown(&#10;         &quot;Upbit Trader&quot;,&#10;     )&#10;&#10;     # Ensure a nav state that mirrors page&#10;     if 'nav_menu' not in st.session_state:&#10;         st.session_state['nav_menu'] = st.session_state.get('page', '설정 편집')&#10;&#10;     selected_tab = st.session_state['nav_menu']&#10;&#10;     # Render menu buttons inside a container to keep layout stable&#10;     nav_container = sb.container()&#10;     pending_selection = None&#10;     for nav_option in NAV_OPTIONS:&#10;         is_selected = selected_tab == nav_option&#10;         btn_type = 'primary' if is_selected else 'secondary'&#10;         try:&#10;             clicked = nav_container.button(&#10;                 nav_option,&#10;                 key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;,&#10;                 width='stretch',&#10;                 type=btn_type,&#10;             )&#10;         except TypeError:&#10;             # Older Streamlit versions may not support `type` or `width`.&#10;             # Fallback to basic button (width parameter may not be supported).&#10;             try:&#10;                 clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;, width='stretch')&#10;             except Exception:&#10;                 clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot; )&#10;         if clicked:&#10;             pending_selection = nav_option&#10;&#10;     if pending_selection and pending_selection != selected_tab:&#10;         st.session_state['nav_menu'] = pending_selection&#10;         st.session_state['page'] = pending_selection&#10;         # trigger a rerun so UI reflects selection immediately&#10;         _rerun_app()&#10;&#10;&#10;_sidebar_menu()&#10;&#10;# dispatch to pages based on session_state&#10;page = st.session_state.get('page', '설정 편집')&#10;if page == '종목 스크리닝':&#10;    render_screening_page()&#10;elif page == '이벤트 감시자 관리':&#10;    render_watcher_page(cfg)&#10;elif page == '원화잔고 및 포지션 분석':&#10;    # Simple positions/status view — attempt to call backend /status if available&#10;    def render_positions_page():&#10;        st.title('원화잔고 및 포지션 분석')&#10;        try:&#10;            resp = requests.get(f&quot;{API_BASE.rstrip('/')}/status&quot;, timeout=5)&#10;            if resp.status_code == 200:&#10;                st.json(resp.json())&#10;            else:&#10;                st.info('백엔드 /status 응답이 없습니다.')&#10;        except Exception:&#10;            st.info('백엔드 상태를 불러올 수 없습니다. 필요한 API가 동작중인지 확인하세요.')&#10;&#10;    render_positions_page()&#10;elif page == '설정 편집':&#10;    render_config_page(cfg)&#10;else:&#10;    render_about_page()&#10;&#10;st.divider()&#10;st.caption('주의: 이 UI는 인증이 없습니다. 로컬 개발 환경에서만 사용하세요.')&#10;" />
              <option name="updatedContent" value="import streamlit as st&#10;# reload-test: touch ui file to verify backend reload behavior (do not remove)&#10;import requests&#10;from requests.adapters import HTTPAdapter&#10;from urllib3.util.retry import Retry&#10;from pathlib import Path&#10;from typing import Any, Dict, Tuple&#10;import pandas as pd&#10;import plotly.graph_objects as go&#10;from plotly.subplots import make_subplots&#10;import time&#10;import random&#10;import os&#10;# Ensure process timezone is KST (Asia/Seoul) so Streamlit displays local times correctly&#10;os.environ.setdefault('TZ', 'Asia/Seoul')&#10;try:&#10;    time.tzset()&#10;except Exception:&#10;    # time.tzset may not be available on all platforms (Windows), ignore if unavailable&#10;    pass&#10;&#10;# Import configuration helpers from server package&#10;try:&#10;    from server.config import load_config, save_config as save_local&#10;except Exception:&#10;    # In case UI runs in an environment where server package isn't available on PYTHONPATH,&#10;    # fall back to a stub that will raise an informative error when used.&#10;    def load_config():&#10;        raise RuntimeError('server.config.load_config not available in PYTHONPATH')&#10;&#10;    def save_local(cfg):&#10;        raise RuntimeError('server.config.save_config not available in PYTHONPATH')&#10;&#10;&#10;def validate_config(cfg: Dict[str, Any]) -&gt; Tuple[bool, str]:&#10;    &quot;&quot;&quot;Basic validation for runtime config used by the UI form.&#10;    Returns (True, '') if valid, otherwise (False, 'reason').&#10;    &quot;&quot;&quot;&#10;    if not isinstance(cfg, dict):&#10;        return False, '설정 데이터가 딕셔너리가 아닙니다.'&#10;    if not cfg.get('market'):&#10;        return False, 'Market 값이 필요합니다.'&#10;    if not isinstance(cfg.get('candle_count', 0), int) or cfg.get('candle_count', 0) &lt;= 0:&#10;        return False, 'Candle count 는 1 이상의 정수여야 합니다.'&#10;    order = cfg.get('order_settings', {})&#10;    if not isinstance(order.get('trade_amount_krw', 0), (int, float)) or order.get('trade_amount_krw', 0) &lt;= 0:&#10;        return False, 'Trade amount_krw 는 0보다 큰 숫자여야 합니다.'&#10;    kelly = cfg.get('kelly_criterion', {})&#10;    if cfg.get('use_kelly_criterion'):&#10;        wr = float(kelly.get('win_rate', 0))&#10;        pr = float(kelly.get('payoff_ratio', 0))&#10;        frac = float(kelly.get('fraction', 0))&#10;        if not (0 &lt;= wr &lt;= 1):&#10;            return False, 'Kelly win_rate 는 0~1 범위여야 합니다.'&#10;        if pr &lt;= 0:&#10;            return False, 'Kelly payoff_ratio 는 양수여야 합니다.'&#10;        if not (0 &lt;= frac &lt;= 1):&#10;            return False, 'Kelly fraction 은 0~1 범위여야 합니다.'&#10;    return True, ''&#10;&#10;&#10;RUNTIME_CONFIG = Path(__file__).resolve().parents[1] / 'runtime' / 'config.json'&#10;&#10;st.set_page_config(page_title='Upbit Trader', layout='wide')&#10;&#10;# Helper to render DataFrame safely across Streamlit versions and hide index when requested&#10;def _safe_dataframe(df: 'pd.DataFrame', hide_index: bool = False, **kwargs):&#10;    &quot;&quot;&quot;Render a pandas DataFrame while attempting to hide the index and use full width.&#10;    Tries the newer `width='stretch'` API first, then falls back to `use_container_width=True`,&#10;    and finally to the basic st.dataframe if needed.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return st.dataframe(df, hide_index=hide_index, width='stretch', **kwargs)&#10;    except TypeError:&#10;        try:&#10;            return st.dataframe(df, hide_index=hide_index, use_container_width=True, **kwargs)&#10;        except TypeError:&#10;            # Older Streamlit may not support hide_index; fallback to st.table (no hide)&#10;            try:&#10;                return st.table(df)&#10;            except Exception:&#10;                return st.write(df)&#10;&#10;&#10;# API base URL for backend calls: read from env var STREAMLIT_API_BASE (set by docker-compose)&#10;# If not set, fall back to localhost for local development.&#10;API_BASE = os.getenv('STREAMLIT_API_BASE', 'http://127.0.0.1:8000')&#10;&#10;# Create a requests session with retry/backoff to make UI-server comms more resilient&#10;def _build_session():&#10;    session = requests.Session()&#10;    retries = Retry(&#10;        total=3,&#10;        backoff_factor=0.6,&#10;        status_forcelist=(429, 500, 502, 503, 504),&#10;        allowed_methods=(&quot;GET&quot;, &quot;POST&quot;),&#10;        raise_on_status=False,&#10;    )&#10;    adapter = HTTPAdapter(max_retries=retries)&#10;    session.mount(&quot;http://&quot;, adapter)&#10;    session.mount(&quot;https://&quot;, adapter)&#10;    return session&#10;&#10;_API_SESSION = _build_session()&#10;&#10;def api_request(method: str, path: str, params=None, json=None, timeout=10):&#10;    &quot;&quot;&quot;Call server API with retries and return requests.Response or raise Exception with friendly message.&quot;&quot;&quot;&#10;    if not API_BASE:&#10;        raise RuntimeError(&quot;API Base URL is not set in the sidebar&quot;)&#10;    url = API_BASE.rstrip(&quot;/&quot;) + &quot;/&quot; + path.lstrip(&quot;/&quot;)&#10;    try:&#10;        if method.lower() == &quot;get&quot;:&#10;            resp = _API_SESSION.get(url, params=params, timeout=timeout)&#10;        else:&#10;            resp = _API_SESSION.post(url, json=json, timeout=timeout)&#10;        resp.raise_for_status()&#10;        return resp&#10;    except requests.exceptions.RequestException as e:&#10;        # Wrap low-level error to present user-friendly message in UI&#10;        raise RuntimeError(f&quot;서버 호출 실패: {e}&quot;) from e&#10;&#10;&#10;# --- Upbit public klines helper (cached) ---&#10;@st.cache_data(ttl=10)&#10;def fetch_klines_cached(market: str, timeframe: str = 'minute1', count: int = 200) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;&#10;    UI-side fetch function disabled.&#10;    The UI must not call Upbit public API directly — always go through the backend `/klines_batch` endpoint.&#10;    This function returns None to force the UI to rely on backend data and avoid causing 429 Too Many Requests.&#10;    &quot;&quot;&quot;&#10;    # Return None immediately to prevent direct Upbit calls from the UI.&#10;    st.warning('UI는 직접 Upbit 호출을 하지 않습니다. 백엔드의 prefetch가 완료될 때까지 대기하세요.')&#10;    return None&#10;&#10;&#10;def fetch_klines_batch_from_backend(tickers: list[str], timeframe: str = 'minute15', count: int = 100) -&gt; Dict[str, pd.DataFrame | None]:&#10;    &quot;&quot;&quot;Call server /klines_batch to get klines for multiple tickers. Returns mapping ticker-&gt;DataFrame or None.&#10;    Falls back to empty dict on error.&#10;    &quot;&quot;&quot;&#10;    url = f&quot;{API_BASE.rstrip('/')}/klines_batch&quot;&#10;    try:&#10;        resp = requests.post(url, json={'tickers': tickers, 'timeframe': timeframe, 'count': count}, timeout=15)&#10;        resp.raise_for_status()&#10;        data = resp.json().get('klines', {})&#10;        result = {}&#10;        for t, v in data.items():&#10;            if not v:&#10;                result[t] = None&#10;                continue&#10;            df = pd.DataFrame(v)&#10;            df = df.rename(columns={&#10;                'candle_date_time_kst': 'time',&#10;                'opening_price': 'open',&#10;                'high_price': 'high',&#10;                'low_price': 'low',&#10;                'trade_price': 'close',&#10;                'candle_acc_trade_volume': 'volume'&#10;            })&#10;            cols = [c for c in ['time','open','high','low','close','volume'] if c in df.columns]&#10;            df = df[cols]&#10;            if 'time' in df.columns:&#10;                df['time'] = pd.to_datetime(df['time'])&#10;            for col in ['open','high','low','close','volume']:&#10;                if col in df.columns:&#10;                    df[col] = pd.to_numeric(df[col], errors='coerce')&#10;            df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;            result[t] = df&#10;        return result&#10;    except Exception as e:&#10;        st.warning(f'백엔드 batch klines 호출 실패: {e}')&#10;        return {}&#10;&#10;&#10;def _normalize_klines_df(df: pd.DataFrame | None, min_length: int = 30) -&gt; pd.DataFrame | None:&#10;    &quot;&quot;&quot;Validate and normalize a kline DataFrame for plotting.&#10;    - Ensures time column exists and is datetime&#10;    - Renames common Upbit keys if needed&#10;    - Sorts ascending by time, drops duplicate timestamps&#10;    - Converts numeric columns and fills small gaps&#10;    - Returns None if data is invalid&#10;    &quot;&quot;&quot;&#10;    if df is None:&#10;        return None&#10;    # Accept list-of-dicts as well&#10;    if not isinstance(df, pd.DataFrame):&#10;        try:&#10;            df = pd.DataFrame(df)&#10;        except Exception:&#10;            return None&#10;&#10;    # Map common Upbit field names to expected ones&#10;    rename_map = {&#10;        'candle_date_time_kst': 'time',&#10;        'opening_price': 'open',&#10;        'high_price': 'high',&#10;        'low_price': 'low',&#10;        'trade_price': 'close',&#10;        'candle_acc_trade_volume': 'volume'&#10;    }&#10;    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})&#10;&#10;    # required columns&#10;    required = ['time', 'open', 'high', 'low', 'close', 'volume']&#10;    if 'time' not in df.columns:&#10;        return None&#10;&#10;    # time -&gt; datetime&#10;    try:&#10;        df['time'] = pd.to_datetime(df['time'])&#10;    except Exception:&#10;        try:&#10;            df['time'] = pd.to_datetime(df['time'].astype(str))&#10;        except Exception:&#10;            return None&#10;&#10;    # sort ascending and dedupe&#10;    df = df.sort_values('time', ascending=True).reset_index(drop=True)&#10;    if df['time'].duplicated().any():&#10;        df = df[~df['time'].duplicated(keep='last')].reset_index(drop=True)&#10;&#10;    # ensure numeric&#10;    for col in ['open', 'high', 'low', 'close', 'volume']:&#10;        if col in df.columns:&#10;            df[col] = pd.to_numeric(df[col], errors='coerce')&#10;        else:&#10;            df[col] = pd.NA&#10;&#10;    # fill small gaps for price columns&#10;    try:&#10;        df[['open', 'high', 'low', 'close']] = df[['open', 'high', 'low', 'close']].ffill().bfill()&#10;        df['volume'] = df['volume'].fillna(0)&#10;    except Exception:&#10;        pass&#10;&#10;    if len(df) &lt; min_length:&#10;        st.warning(f'차트에 필요한 데이터가 부족합니다: {len(df)}개 (최소 {min_length} 필요)')&#10;        return df&#10;    return df&#10;&#10;&#10;# --- Indicator helpers and plotting ---&#10;def compute_rsi(series: pd.Series, period: int = 14) -&gt; pd.Series:&#10;    # Standard Wilder's RSI calculation without forcing initial values to 0.&#10;    delta = series.diff()&#10;    up = delta.clip(lower=0)&#10;    down = -1 * delta.clip(upper=0)&#10;    ma_up = up.rolling(period, min_periods=period).mean()&#10;    ma_down = down.rolling(period, min_periods=period).mean()&#10;    rs = ma_up / ma_down&#10;    rsi = 100 - (100 / (1 + rs))&#10;    return rsi&#10;&#10;&#10;def plot_candles_with_indicators(df: pd.DataFrame, ticker: str, ma_windows: list[int], rsi_period: int):&#10;    # Create subplot: row1 = candlestick+MA, row2 = volume bars, row3 = RSI&#10;    fig = make_subplots(rows=3, cols=1, shared_xaxes=True, row_heights=[0.6, 0.2, 0.2], vertical_spacing=0.03)&#10;&#10;    # Row 1: Candlestick — set colors: rising(red), falling(blue)&#10;    fig.add_trace(go.Candlestick(x=df['time'], open=df['open'], high=df['high'], low=df['low'], close=df['close'], name='OHLC', increasing=dict(line=dict(color='red'), fillcolor='red'), decreasing=dict(line=dict(color='blue'), fillcolor='blue')), row=1, col=1)&#10;&#10;    # moving averages on top&#10;    for w in ma_windows:&#10;        ma = df['close'].rolling(w).mean()&#10;        fig.add_trace(go.Scatter(x=df['time'], y=ma, mode='lines', name=f'MA{w}', line=dict(width=1.2)), row=1, col=1)&#10;&#10;    # Row 2: Volume bars&#10;    # color volume bars green when close &gt;= open else red&#10;    try:&#10;        # rising -&gt; red, falling -&gt; blue&#10;        colors = ['red' if c &gt;= o else 'blue' for o, c in zip(df['open'], df['close'])]&#10;    except Exception:&#10;        colors = 'gray'&#10;    fig.add_trace(go.Bar(x=df['time'], y=df['volume'], name='Volume', marker=dict(color=colors), hovertemplate='Volume: %{y:,.0f}&lt;extra&gt;&lt;/extra&gt;'), row=2, col=1)&#10;    # Keep volume axis independent&#10;    fig.update_yaxes(title_text='Volume', row=2, col=1)&#10;&#10;    # Row 3: RSI&#10;    rsi = compute_rsi(df['close'], period=rsi_period)&#10;    fig.add_trace(go.Scatter(x=df['time'], y=rsi, mode='lines', name=f'RSI({rsi_period})', line=dict(color='purple', width=2.0), connectgaps=False, hovertemplate='RSI: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'), row=3, col=1)&#10;    # RSI bands (draw as shapes for visibility)&#10;    fig.add_hline(y=70, line=dict(color='red', dash='dash'), row=3, col=1)&#10;    fig.add_hline(y=30, line=dict(color='green', dash='dash'), row=3, col=1)&#10;    fig.update_yaxes(range=[0,100], row=3, col=1)&#10;&#10;    # layout tweaks&#10;    fig.update_layout(height=520, margin=dict(l=10, r=10, t=30, b=20), showlegend=True, hovermode='x unified')&#10;    fig.update_xaxes(rangebreaks=[dict(bounds=[&quot;sat&quot;,&quot;mon&quot;])], rangeslider_visible=False)&#10;    return fig&#10;&#10;&#10;# Load existing config&#10;cfg = load_config()&#10;&#10;# --- Page renderers ---&#10;&#10;def render_config_page(cfg: Dict[str, Any]):&#10;    st.title('설정 편집')&#10;    with st.form('config_form', clear_on_submit=False):&#10;        strategy_name = st.selectbox('전략 선택', options=['VolatilityBreakout', 'DualMomentum', 'RSI'], index=['VolatilityBreakout', 'DualMomentum', 'RSI'].index(cfg.get('strategy_name', 'VolatilityBreakout')) if cfg.get('strategy_name') in ['VolatilityBreakout', 'DualMomentum', 'RSI'] else 0)&#10;        market = st.text_input('Market (예: KRW-BTC)', value=cfg.get('market', 'KRW-BTC'))&#10;        timeframe = st.text_input('Timeframe (예: minute5)', value=cfg.get('timeframe', 'minute5'))&#10;        candle_count = st.number_input('Candle count', min_value=1, value=int(cfg.get('candle_count', 200)))&#10;        loop_interval_sec = st.number_input('Loop interval (sec)', min_value=1, value=int(cfg.get('loop_interval_sec', 5)))&#10;&#10;        st.subheader('주문 설정')&#10;        order_settings = cfg.get('order_settings', {})&#10;        min_order_amount = st.number_input('Min order amount (KRW)', min_value=1000, value=int(order_settings.get('min_order_amount', 5500)))&#10;        trade_amount_krw = st.number_input('Trade amount (KRW)', min_value=1000, value=int(order_settings.get('trade_amount_krw', 6000)))&#10;&#10;        st.subheader('켈리공식 설정')&#10;        use_kelly = st.checkbox('Kelly 적용', value=bool(cfg.get('use_kelly_criterion', True)))&#10;        kelly = cfg.get('kelly_criterion', {})&#10;        win_rate = st.number_input('Win rate (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('win_rate', 0.65)))&#10;        payoff_ratio = st.number_input('Payoff ratio', min_value=0.0, value=float(kelly.get('payoff_ratio', 1.2)))&#10;        fraction = st.number_input('Fraction (0~1)', min_value=0.0, max_value=1.0, value=float(kelly.get('fraction', 0.5)))&#10;&#10;        st.subheader('전략별 파라미터')&#10;        strategy_params = cfg.get('strategy_params', {})&#10;        if strategy_name == 'RSI':&#10;            rsi = strategy_params.get('RSI', {})&#10;            rsi_period = st.number_input('RSI period', min_value=1, value=int(rsi.get('period', 14)))&#10;            rsi_oversold = st.number_input('RSI oversold', min_value=0, max_value=100, value=int(rsi.get('oversold', 30)))&#10;            rsi_overbought = st.number_input('RSI overbought', min_value=0, max_value=100, value=int(rsi.get('overbought', 70)))&#10;        elif strategy_name == 'VolatilityBreakout':&#10;            vb = strategy_params.get('VolatilityBreakout', {})&#10;            k_value = st.number_input('k value (0~1)', min_value=0.0, max_value=1.0, value=float(vb.get('k_value', 0.5)))&#10;        elif strategy_name == 'DualMomentum':&#10;            dm = strategy_params.get('DualMomentum', {})&#10;            window = st.number_input('Window (periods)', min_value=1, value=int(dm.get('window', 12)))&#10;&#10;        submit = st.form_submit_button('미리보기 업데이트')&#10;&#10;    new_cfg = {&#10;        'strategy_name': strategy_name,&#10;        'market': market,&#10;        'timeframe': timeframe,&#10;        'candle_count': candle_count,&#10;        'loop_interval_sec': loop_interval_sec,&#10;        'order_settings': {&#10;            'min_order_amount': min_order_amount,&#10;            'trade_amount_krw': trade_amount_krw,&#10;        },&#10;        'use_kelly_criterion': use_kelly,&#10;        'kelly_criterion': {&#10;            'win_rate': win_rate,&#10;            'payoff_ratio': payoff_ratio,&#10;            'fraction': fraction,&#10;        },&#10;        'strategy_params': {}&#10;    }&#10;&#10;    if strategy_name == 'RSI':&#10;        new_cfg['strategy_params']['RSI'] = {&#10;            'period': rsi_period,&#10;            'oversold': rsi_oversold,&#10;            'overbought': rsi_overbought,&#10;        }&#10;    elif strategy_name == 'VolatilityBreakout':&#10;        new_cfg['strategy_params']['VolatilityBreakout'] = {'k_value': k_value}&#10;    elif strategy_name == 'DualMomentum':&#10;        new_cfg['strategy_params']['DualMomentum'] = {'window': window}&#10;&#10;    st.divider()&#10;    st.header('설정 액션')&#10;    valid, message = validate_config(new_cfg)&#10;    if not valid:&#10;        st.error('유효성 검사 실패: ' + message)&#10;&#10;    col_a, col_b, col_c = st.columns(3)&#10;    with col_a:&#10;        if st.button('로컬에 저장'):&#10;            if not valid:&#10;                st.error('저장 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    save_local(new_cfg)&#10;                    st.success('저장 완료: runtime/config.json')&#10;                except Exception as e:&#10;                    st.error('로컬 저장 실패: ' + str(e))&#10;    with col_b:&#10;        if st.button('서버에 전송'):&#10;            if not valid:&#10;                st.error('전송 실패: 유효성 검사 실패 - ' + message)&#10;            else:&#10;                try:&#10;                    resp = api_request('post', '/config', json={'config': new_cfg}, timeout=10)&#10;                    st.success('서버에 전송 완료')&#10;                except Exception as e:&#10;                    st.error(str(e))&#10;    with col_c:&#10;        if st.button('서버 재로딩 요청'):&#10;            try:&#10;                resp = api_request('post', '/reload', timeout=5)&#10;                st.success('서버 재로딩 요청 성공')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;&#10;&#10;def render_screening_page():&#10;    st.title('종목 스크리닝')&#10;    st.caption('변동성 TOP 종목을 조회합니다. (최근 캔들 기준)')&#10;    st.code('변동성은 (max_high - min_low) / mean_close 로 계산됩니다.')&#10;&#10;    # Controls moved into the page (previously in sidebar)&#10;    ctrl_col1, ctrl_col2, ctrl_col3 = st.columns([1,1,1])&#10;    market_prefix = ctrl_col1.text_input('마켓 접두사 (예: KRW)', value='KRW', key='scr_market_prefix')&#10;    top_n = ctrl_col2.number_input('Top N', min_value=1, max_value=50, value=10, key='scr_top_n')&#10;    # timeframe placed in the third column for grouping&#10;    timeframe = ctrl_col3.selectbox('Timeframe', options=['minute5','minute15','minute60','day'], index=1, key='scr_timeframe')&#10;&#10;    # Place the search button in a dedicated full-width row so it spans the page&#10;    full_row = st.columns([1])[0]&#10;    try:&#10;        # Use width='stretch' when supported&#10;        search_clicked = full_row.button('조회', key='scr_search', width='stretch')&#10;    except TypeError:&#10;        # Fallback for older Streamlit versions&#10;        search_clicked = full_row.button('조회', key='scr_search')&#10;&#10;    # When search clicked, fetch data and then render charts below&#10;    if 'search_clicked' not in st.session_state:&#10;        st.session_state['search_clicked'] = False&#10;    if search_clicked:&#10;        st.session_state['search_clicked'] = True&#10;        # remember last query params to re-render charts on interaction&#10;        st.session_state['last_search'] = {'market_prefix': market_prefix, 'top_n': top_n, 'timeframe': timeframe}&#10;&#10;    if st.session_state.get('search_clicked'):&#10;        params = st.session_state.get('last_search', {})&#10;        try:&#10;            resp = api_request('get', '/screen/volatility_top', params={'market_prefix': params.get('market_prefix','KRW'), 'top_n': params.get('top_n',10), 'timeframe': params.get('timeframe','minute15')}, timeout=10)&#10;            data = resp.json().get('top', [])&#10;            # determine requested N early&#10;            requested_n = int(params.get('top_n', 10))&#10;            # present a ranked table with ranks starting from 1&#10;            df_top = None&#10;            try:&#10;                df_top = pd.DataFrame(data)&#10;                # If volatility present, sort by it descending to ensure ranking order&#10;                if 'volatility' in df_top.columns:&#10;                    df_top = df_top.sort_values(by='volatility', ascending=False).reset_index(drop=True)&#10;                if not df_top.empty:&#10;                    df_top.insert(0, 'rank', range(1, len(df_top) + 1))&#10;                # display table without the default index column&#10;                _safe_dataframe(df_top, hide_index=True)&#10;            except Exception:&#10;                try:&#10;                    df_fallback = pd.DataFrame(data)&#10;                    _safe_dataframe(df_fallback, hide_index=True)&#10;                except Exception:&#10;                    # last resort: plain st.table&#10;                    st.table(data)&#10;&#10;            # build items list from sorted df_top when available, otherwise fallback to raw data&#10;            if isinstance(df_top, pd.DataFrame) and not df_top.empty:&#10;                sorted_items = df_top.to_dict(orient='records')&#10;            else:&#10;                sorted_items = data&#10;&#10;            # Chart controls (placed near the table)&#10;            control_cols = st.columns([1,1,1])&#10;            with control_cols[0]:&#10;                ma1 = st.number_input('MA1 window', min_value=1, value=20, key='ma1_s')&#10;            with control_cols[1]:&#10;                ma2 = st.number_input('MA2 window', min_value=1, value=60, key='ma2_s')&#10;            with control_cols[2]:&#10;                rsi_p = st.number_input('RSI period', min_value=5, value=14, key='rsi_p_s')&#10;&#10;            # limit to requested top_n and render in a grid&#10;            items = sorted_items[:requested_n]&#10;            display_n = len(items)&#10;            # Try batch fetch from backend to reduce Upbit calls&#10;            tickers = [it.get('ticker') for it in items]&#10;            backend_data = fetch_klines_batch_from_backend(tickers, timeframe=params.get('timeframe','minute15'), count=200)&#10;            # If some tickers are missing in the backend result (None), retry via backend a few times&#10;            missing = [t for t in tickers if backend_data.get(t) is None]&#10;            if missing:&#10;                retries = 3&#10;                for attempt in range(1, retries+1):&#10;                    if not missing:&#10;                        break&#10;                    # request only the missing tickers as a batch&#10;                    try:&#10;                        more = fetch_klines_batch_from_backend(missing, timeframe=params.get('timeframe','minute15'), count=200)&#10;                        for k, v in (more or {}).items():&#10;                            backend_data[k] = v&#10;                        # recompute missing list&#10;                        missing = [t for t in tickers if backend_data.get(t) is None]&#10;                    except Exception:&#10;                        # ignore and backoff&#10;                        pass&#10;                    if missing and attempt &lt; retries:&#10;                        time.sleep(0.8 * attempt)&#10;&#10;            # Render rows of 2 columns based on actual display_n&#10;            for row_start in range(0, display_n, 2):&#10;                cols = st.columns(2, gap='small')&#10;                for col_idx in range(2):&#10;                    idx = row_start + col_idx&#10;                    if idx &gt;= display_n:&#10;                        with cols[col_idx]:&#10;                            st.empty()&#10;                        continue&#10;                    item = items[idx]&#10;                    ticker = item.get('ticker')&#10;                    vol = item.get('volatility')&#10;                    with cols[col_idx]:&#10;                        st.subheader(f&quot;{idx+1}. {ticker} — vol={vol:.4f}&quot;)&#10;                        df = backend_data.get(ticker)&#10;                        # normalize/check df before plotting&#10;                        df = _normalize_klines_df(df, min_length=50)&#10;                        if df is None or (hasattr(df, 'empty') and df.empty):&#10;                            # Backend could not provide data (maybe prefetch miss or Upbit limit).&#10;                            # Show a user-friendly message and skip direct Upbit calls from the UI to avoid causing a 429.&#10;                            st.info('차트 데이터를 아직 불러올 수 없습니다. 잠시 후 다시 시도하세요. (백엔드에서 데이터 수집 중일 수 있음)')&#10;                        else:&#10;                            # Create a more compact chart for the grid&#10;                            fig = plot_candles_with_indicators(df, ticker, ma_windows=[ma1, ma2], rsi_period=int(rsi_p))&#10;                            fig.update_layout(height=340, margin=dict(l=10, r=10, t=30, b=20))&#10;                            st.plotly_chart(fig, width='stretch')&#10;                    # slight pause to avoid tight loop/rate limits&#10;                    time.sleep(0.08)&#10;            # show count info&#10;            st.caption(f&quot;표시된 종목: {display_n} / 요청한 TopN: {requested_n}&quot;)&#10;        except Exception as e:&#10;            st.error(str(e))&#10;&#10;&#10;def render_watcher_page(cfg: Dict[str, Any]):&#10;    st.title('이벤트 감시자 관리')&#10;    st.write('웹소켓 대신 폴링(간단) 방식으로 체크를 수행합니다. 서버의 /watcher/start, /watcher/stop를 사용합니다.')&#10;&#10;    watch_market = st.text_input('감시할 마켓', value=cfg.get('market', 'KRW-BTC'))&#10;    watch_interval = st.number_input('체크 간격(초)', min_value=0.2, value=1.0)&#10;    cb_vol_k = st.slider('Volatility K', min_value=0.0, max_value=1.0, value=float(cfg.get('strategy_params', {}).get('VolatilityBreakout', {}).get('k_value', 0.5)))&#10;    cb_vol_mul = st.number_input('Volume Spike Multiplier', min_value=1, value=3)&#10;&#10;    colx, coly = st.columns(2)&#10;    with colx:&#10;        if st.button('Watcher 시작'):&#10;            payload = {&#10;                'market': watch_market,&#10;                'interval': float(watch_interval),&#10;                'callbacks': [&#10;                    {'type': 'volatility_breakout', 'k': float(cb_vol_k)},&#10;                    {'type': 'volume_spike', 'multiplier': int(cb_vol_mul)}&#10;                ]&#10;            }&#10;            try:&#10;                resp = api_request('post', '/watcher/start', json=payload, timeout=10)&#10;                st.success('Watcher 시작 요청 전송됨')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;    with coly:&#10;        if st.button('Watcher 중지'):&#10;            try:&#10;                resp = api_request('post', '/watcher/stop', timeout=10)&#10;                st.success('Watcher 중지 요청 전송됨')&#10;            except Exception as e:&#10;                st.error(str(e))&#10;&#10;&#10;def render_about_page():&#10;    # kept as an unused fallback; keep minimal content&#10;    st.title('도움말 / 정보')&#10;    st.write('이 UI는 여러 페이지로 구성됩니다. 서버가 로컬에서 실행 중이어야 합니다.')&#10;&#10;&#10;# --- Sidebar navigation (pure Streamlit) ---&#10;def _ensure_page_state():&#10;    if 'page' not in st.session_state:&#10;        st.session_state['page'] = '설정 편집'&#10;&#10;&#10;def _rerun_app() -&gt; None:&#10;    &quot;&quot;&quot;Trigger a Streamlit rerun, compatible with new and old APIs.&quot;&quot;&quot;&#10;    rerun_fn = getattr(st, &quot;rerun&quot;, None) or getattr(st, &quot;experimental_rerun&quot;, None)&#10;    if rerun_fn:&#10;        try:&#10;            rerun_fn()&#10;        except Exception:&#10;            # ignore if rerun not permitted in some environments&#10;            pass&#10;&#10;&#10;def _sidebar_menu():&#10;     _ensure_page_state()&#10;     NAV_OPTIONS = ['종목 스크리닝', '이벤트 감시자 관리', '원화잔고 및 포지션 분석', '설정 편집']&#10;     sb = st.sidebar&#10;&#10;     # Small header block (kept minimal). This parallels the user's example but uses&#10;     # only tiny localized CSS. Unsafe HTML is limited to this small header.&#10;     sb.markdown(&#10;         &quot;Upbit Trader&quot;,&#10;     )&#10;&#10;     # Ensure a nav state that mirrors page&#10;     if 'nav_menu' not in st.session_state:&#10;         st.session_state['nav_menu'] = st.session_state.get('page', '설정 편집')&#10;&#10;     selected_tab = st.session_state['nav_menu']&#10;&#10;     # Render menu buttons inside a container to keep layout stable&#10;     nav_container = sb.container()&#10;     pending_selection = None&#10;     for nav_option in NAV_OPTIONS:&#10;         is_selected = selected_tab == nav_option&#10;         btn_type = 'primary' if is_selected else 'secondary'&#10;         try:&#10;             clicked = nav_container.button(&#10;                 nav_option,&#10;                 key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;,&#10;                 width='stretch',&#10;                 type=btn_type,&#10;             )&#10;         except TypeError:&#10;             # Older Streamlit versions may not support `type` or `width`.&#10;             # Fallback to basic button (width parameter may not be supported).&#10;             try:&#10;                 clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot;, width='stretch')&#10;             except Exception:&#10;                 clicked = nav_container.button(nav_option, key=f&quot;nav_btn_{nav_option.replace(' ', '_')}&quot; )&#10;         if clicked:&#10;             pending_selection = nav_option&#10;&#10;     if pending_selection and pending_selection != selected_tab:&#10;         st.session_state['nav_menu'] = pending_selection&#10;         st.session_state['page'] = pending_selection&#10;         # trigger a rerun so UI reflects selection immediately&#10;         _rerun_app()&#10;&#10;&#10;_sidebar_menu()&#10;&#10;# dispatch to pages based on session_state&#10;page = st.session_state.get('page', '설정 편집')&#10;if page == '종목 스크리닝':&#10;    render_screening_page()&#10;elif page == '이벤트 감시자 관리':&#10;    render_watcher_page(cfg)&#10;elif page == '원화잔고 및 포지션 분석':&#10;    # Simple positions/status view — attempt to call backend /status if available&#10;    def render_positions_page():&#10;        st.title('원화잔고 및 포지션 분석')&#10;        try:&#10;            resp = requests.get(f&quot;{API_BASE.rstrip('/')}/status&quot;, timeout=5)&#10;            if resp.status_code == 200:&#10;                st.json(resp.json())&#10;            else:&#10;                st.info('백엔드 /status 응답이 없습니다.')&#10;        except Exception:&#10;            st.info('백엔드 상태를 불러올 수 없습니다. 필요한 API가 동작중인지 확인하세요.')&#10;&#10;    render_positions_page()&#10;elif page == '설정 편집':&#10;    render_config_page(cfg)&#10;else:&#10;    render_about_page()&#10;&#10;st.divider()&#10;st.caption('주의: 이 UI는 인증이 없습니다. 로컬 개발 환경에서만 사용하세요.')" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>